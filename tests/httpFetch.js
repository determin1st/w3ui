// Generated by LiveScript 1.6.0
"use strict";
var httpFetch, toString$ = {}.toString;
httpFetch = function(){
  var consoleError, Api, jsonDecode, jsonEncode, textDecode, textEncode, apiCrypto, parseArguments, isFormData, FetchConfig, FetchOptions, FetchError, FetchData, FetchStream, FetchHandler, ApiHandler, newFormData, newQueryString, newPromise, newInstance, httpFetch;
  consoleError = function(msg){
    var a;
    a = '%chttpFetch: %c' + msg;
    console.log(a, 'font-weight:bold;color:gold', 'color:orangered;font-size:140%');
  };
  Api = [typeof fetch, typeof AbortController, typeof TextDecoder, typeof Proxy, typeof Promise, typeof WeakMap, typeof ReadableStream];
  if (Api.includes('undefined')) {
    consoleError('missing requirements');
    return null;
  }
  jsonDecode = function(s){
    var e;
    if (s) {
      try {
        return JSON.parse(s);
      } catch (e$) {
        e = e$;
        throw new FetchError(1, 'incorrect JSON: ' + s);
      }
    }
    return null;
  };
  jsonEncode = function(o){
    try {
      return JSON.stringify(o);
    } catch (e$) {
      e$;
      return null;
    }
  };
  textDecode = function(){
    var t;
    t = new TextDecoder('utf-8');
    return function(buf){
      return t.decode(buf);
    };
  }();
  textEncode = function(){
    var t;
    t = new TextEncoder();
    return function(str){
      return t.encode(str);
    };
  }();
  apiCrypto = function(){
    var CS, nullFunc, bufToHex, hexToBuf, bufToBigInt, bigIntToBuf;
    if (typeof crypto === 'undefined' || !crypto.subtle) {
      consoleError('Web Crypto API is not available');
      return null;
    }
    CS = crypto.subtle;
    nullFunc = function(){
      return null;
    };
    bufToHex = function(){
      var hex, i, n;
      hex = [];
      i = -1;
      n = 256;
      while (++i < n) {
        hex[i] = i.toString(16).padStart(2, '0');
      }
      return function(buf){
        var a, b, i, n;
        a = new Uint8Array(buf);
        b = [];
        i = -1;
        n = a.length;
        while (++i < n) {
          b[i] = hex[a[i]];
        }
        return b.join('');
      };
    }();
    hexToBuf = function(hex){
      var len, buf, i, j;
      if ((len = hex.length) % 2) {
        hex = '0' + hex;
        ++len;
      }
      len = len / 2;
      buf = new Uint8Array(len);
      i = -1;
      j = 0;
      while (++i < len) {
        buf[i] = parseInt(hex.slice(j, j + 2), 16);
        j += 2;
      }
      return buf;
    };
    bufToBigInt = function(buf){
      return BigInt('0x' + bufToHex(buf));
    };
    bigIntToBuf = function(bi, size){
      var buf, len, big;
      buf = hexToBuf(bi.toString(16));
      if (!size || (len = buf.length) === size) {
        return buf;
      }
      if (len > size) {
        buf = buf.slice(len - size);
      } else {
        big = new Uint8Array(size);
        big.set(buf, size - len);
        buf = big;
      }
      return buf;
    };
    return {
      cs: CS,
      secretManagersPool: new WeakMap(),
      keyParams: {
        name: 'ECDH',
        namedCurve: 'P-521'
      },
      derivePublicKey: {
        name: 'HMAC',
        hash: 'SHA-512',
        length: 528
      },
      deriveParams: {
        name: 'HMAC',
        hash: 'SHA-512',
        length: 528
      },
      generateKeyPair: async function(){
        var k, a;
        k = (await CS.generateKey(this.keyParams, true, ['deriveKey'])['catch'](nullFunc));
        if (k === null) {
          return null;
        }
        a = (await CS.exportKey('spki', k.publicKey)['catch'](nullFunc));
        return a === null
          ? null
          : [k.privateKey, a];
      },
      generateHashPair: async function(){
        var a, b;
        a = (await CS.generateKey(this.deriveParams, true, ['sign'])['catch'](nullFunc));
        if (a === null) {
          return null;
        }
        a = (await CS.exportKey('raw', a)['catch'](nullFunc));
        if (a === null) {
          return null;
        }
        b = (await CS.digest('SHA-512', a)['catch'](nullFunc));
        if (b === null) {
          return null;
        }
        a = new Uint8Array(a);
        b = new Uint8Array(b);
        return [a, b];
      },
      importKey: function(k){
        return CS.importKey('spki', k, this.keyParams, true, [])['catch'](nullFunc);
      },
      importEcdhKey: function(k){
        return CS.importKey('raw', k, {
          name: 'AES-GCM'
        }, false, ['encrypt', 'decrypt'])['catch'](nullFunc);
      },
      deriveKey: function(privateK, publicK){
        publicK = {
          name: 'ECDH',
          'public': publicK
        };
        return CS.deriveKey(publicK, privateK, this.deriveParams, true, ['sign'])['catch'](nullFunc);
      },
      bufToBase64: function(buf){
        var a;
        a = new Uint8Array(buf);
        return btoa(String.fromCharCode.apply(null, a));
      },
      base64ToBuf: function(str){
        var a, b, c, d;
        a = atob(str);
        b = a.length;
        c = new Uint8Array(b);
        d = -1;
        while (++d < b) {
          c[d] = a.charCodeAt(d);
        }
        return c;
      },
      newSecret: function(){
        var CipherParams, CryptoData, SecretStorage;
        CipherParams = function(iv){
          this.name = 'AES-GCM';
          this.iv = iv;
          this.tagLength = 128;
        };
        CryptoData = function(data, params){
          this.data = data;
          this.params = params;
        };
        SecretStorage = function(manager, secret, key, iv){
          this.manager = manager;
          this.secret = secret;
          this.key = key;
          this.params = new CipherParams(iv);
        };
        SecretStorage.prototype = {
          encrypt: function(data, extended){
            var p;
            if (typeof data === 'string') {
              data = textEncode(data);
            }
            p = new CipherParams(this.params.iv.slice());
            data = CS.encrypt(p, this.key, data)['catch'](nullFunc);
            if (extended) {
              data = new CryptoData(data, p);
              this.next();
            }
            return data;
          },
          decrypt: function(data, params){
            if (typeof data === 'string') {
              data = textEncode(data);
            }
            if (!params) {
              return CS.decrypt(this.params, this.key, data)['catch'](nullFunc);
            }
            params = new CipherParams(params.iv.slice());
            this.next(params.iv);
            data = CS.decrypt(params, this.key, data)['catch'](nullFunc);
            return new CryptoData(data, params);
          },
          next: function(counter){
            var a, b, c, d, e;
            a = counter
              ? counter
              : this.params.iv;
            b = new DataView(a.buffer, 10, 2);
            c = bufToBigInt(a.slice(0, 10));
            d = b.getUint16(0, false);
            if ((e = ++c - 1208925819614629174706176n) >= 0) {
              c = e;
            }
            if ((e = ++d - 65536) >= 0) {
              d = e;
            }
            a.set(bigIntToBuf(c, 10), 0);
            b.setUint16(0, d, false);
            if (!counter) {
              this.secret.set(a, 32);
            }
            return this;
          },
          tag: function(){
            return bufToHex(this.secret.slice(-2));
          },
          save: function(){
            return this.manager('set', apiCrypto.bufToBase64(this.secret)) ? this : null;
          },
          get: function(){
            return apiCrypto.bufToBase64(this.secret);
          }
        };
        return async function(secret, manager){
          var k, c;
          switch (toString$.call(secret).slice(8, -1)) {
          case 'String':
            secret = apiCrypto.base64ToBuf(secret);
            break;
          case 'CryptoKey':
            secret = (await apiCrypto.cs.exportKey('raw', secret));
            secret = new Uint8Array(secret);
            if (secret[0] === 0) {
              secret = secret.slice(1);
            }
            break;
          default:
            return null;
          }
          if (secret.length < 44) {
            return null;
          }
          secret = secret.slice(0, 44);
          k = secret.slice(0, 32);
          c = secret.slice(32, 32 + 12);
          if ((k = (await apiCrypto.importEcdhKey(k))) === null) {
            return null;
          }
          return new SecretStorage(manager, secret, k, c);
        };
      }()
    };
  }();
  parseArguments = function(a){
    if (!a.length) {
      return new FetchError(3, 'no arguments');
    }
    switch (toString$.call(a[0]).slice(8, -1)) {
    case 'String':
      switch (a.length) {
      case 3:
        a[0] = {
          url: a[0],
          data: a[1],
          method: 'POST'
        };
        a[1] = a[2];
        break;
      case 2:
        if (typeof a[1] === 'function') {
          a[0] = {
            url: a[0],
            method: 'GET'
          };
        } else {
          a[0] = {
            url: a[0],
            data: a[1],
            method: 'POST'
          };
          a[1] = false;
        }
        break;
      default:
        a[0] = {
          url: a[0],
          method: 'GET'
        };
        a[1] = false;
      }
      // fallthrough
    case 'Object':
      if (a[0].url && typeof a[0].url !== 'string') {
        return new FetchError(3, 'wrong url type');
      }
      if (a[1] && typeof a[1] !== 'function') {
        return new FetchError(3, 'wrong callback type');
      }
      break;
    default:
      return new FetchError(3, 'incorrect syntax');
    }
    return a;
  };
  isFormData = function(data){
    var a, b;
    switch (toString$.call(data).slice(8, -1)) {
    case 'Object':
      for (a in data) {
        if (isFormData(data[a])) {
          return true;
        }
      }
      break;
    case 'Array':
      b = data.length;
      a = -1;
      while (++a < b) {
        if (isFormData(data[a])) {
          return true;
        }
      }
      break;
    case 'HTMLInputElement':
    case 'FileList':
    case 'File':
    case 'Blob':
      return true;
    }
    return false;
  };
  FetchConfig = function(){
    this.baseUrl = '';
    this.mounted = false;
    this.mode = null;
    this.credentials = null;
    this.cache = null;
    this.redirect = null;
    this.referrer = null;
    this.referrerPolicy = null;
    this.integrity = null;
    this.keepalive = null;
    this.status200 = true;
    this.notNull = false;
    this.fullHouse = false;
    this.promiseReject = false;
    this.timeout = 20;
    this.redirectCount = 5;
    this.secret = null;
    this.headers = null;
    this.parseResponse = 'data';
  };
  FetchConfig.prototype = {
    fetchOptions: ['mode', 'credentials', 'cache', 'redirect', 'referrer', 'referrerPolicy', 'integrity', 'keepalive'],
    dataOptions: ['baseUrl', 'timeout', 'redirectCount', 'parseResponse'],
    flagOptions: ['status200', 'notNull', 'fullHouse', 'promiseReject'],
    setOptions: function(o){
      var i$, ref$, len$, a;
      if (o.hasOwnProperty('baseURL')) {
        this.baseUrl = o.baseURL;
      }
      if (o.hasOwnProperty('mounted')) {
        this.mounted = !!o.mounted;
      }
      for (i$ = 0, len$ = (ref$ = this.fetchOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = o[a];
        }
      }
      for (i$ = 0, len$ = (ref$ = this.dataOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = o[a];
        }
      }
      for (i$ = 0, len$ = (ref$ = this.flagOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = !!o[a];
        }
      }
      if (o.headers) {
        this.setHeaders(o.headers);
      }
    },
    setHeaders: function(s){
      var h, a, b;
      if (!(h = this.headers)) {
        this.headers = h = {};
      }
      for (a in s) {
        b = s[a];
        h[a.toLowerCase()] = b;
      }
    }
  };
  FetchOptions = function(){
    this.method = 'GET';
    this.headers = {
      'content-type': 'application/json'
    };
    this.body = null;
    this.mode = 'cors';
    this.credentials = 'same-origin';
    this.cache = 'default';
    this.redirect = 'follow';
    this.referrer = '';
    this.referrerPolicy = '';
    this.integrity = '';
    this.keepalive = false;
    this.signal = null;
  };
  FetchOptions.prototype = {
    setHeaders: function(s){
      var h, a, b;
      h = this.headers;
      for (a in s) {
        b = s[a];
        a = a.toLowerCase();
        if (!b) {
          if (h.hasOwnProperty(a)) {
            delete h[a];
          }
        } else {
          h[a] = b;
        }
      }
    }
  };
  FetchError = function(){
    var FetchError;
    if (Error.captureStackTrace) {
      FetchError = function(id, message){
        this.id = id;
        this.message = message;
        this.response = null;
        this.status = 0;
        Error.captureStackTrace(this, FetchError);
      };
    } else {
      FetchError = function(id, message){
        this.id = id;
        this.message = message;
        this.response = null;
        this.status = 0;
        this.stack = new Error(message).stack;
      };
    }
    FetchError.prototype = Error.prototype;
    return FetchError;
  }();
  FetchData = function(){
    var ResponseData, RetryData, FetchData;
    ResponseData = function(){
      var RequestData, ResponseData;
      RequestData = function(){
        this.url = '';
        this.headers = null;
        this.data = null;
        this.crypto = null;
        this.time = 0;
      };
      RequestData.prototype = {
        setUrl: function(base, url){
          if (url) {
            if (base && url.indexOf(':') === -1) {
              this.url = base[base.length - 1] === '/' || url[0] === '/'
                ? base + url
                : base + '/' + url;
            } else {
              this.url = url;
            }
          } else {
            this.url = base;
          }
        }
      };
      return ResponseData = function(){
        this.status = 0;
        this.type = '';
        this.headers = null;
        this.data = null;
        this.crypto = null;
        this.time = 0;
        this.request = new RequestData();
      };
    }();
    RetryData = function(count){
      this.count = count;
      this.current = 0;
    };
    return FetchData = function(config){
      var this$ = this;
      this.status200 = config.status200;
      this.fullHouse = config.fullHouse;
      this.notNull = config.notNull;
      this.promiseReject = config.promiseReject;
      this.timeout = 1000 * config.timeout;
      this.parseResponse = config.parseResponse;
      this.callback = null;
      this.promise = null;
      this.response = new ResponseData();
      this.redirect = new RetryData(config.redirectCount);
      this.aborter = null;
      this.timer = 0;
      this.timerFunc = function(force){
        if (force) {
          clearTimeout(this$.timer);
        } else {
          this$.aborter.abort();
        }
        this$.timer = 0;
      };
    };
  }();
  FetchStream = function(){
    var nullResolved, StreamChunk, newStreamBuffer, FetchStream;
    nullResolved = function(){
      return new Promise(function(resolve){
        resolve(null);
      });
    }();
    StreamChunk = function(size){
      this.dose = 0;
      this.data = size ? new Uint8Array(size) : null;
    };
    newStreamBuffer = function(buf, pos){
      var a;
      a = new StreamChunk(0);
      a.data = buf;
      a.dose = pos;
      return a;
    };
    FetchStream = function(stream, data, sec){
      var reader, res, pause, locked, chunk, buffer, time, size, readStart, readHandler, errorHandler, readComplete, readBufComplete, this$ = this;
      reader = stream.getReader();
      res = data.response;
      pause = false;
      locked = null;
      chunk = null;
      buffer = null;
      time = 0;
      size = res.headers['content-length'] ? parseInt(res.headers['content-length']) : 0;
      readStart = function(){
        this$.paused = pause = false;
        this$.error = null;
        if (!stream) {
          return nullResolved;
        }
        time = performance.now();
        return reader.read().then(readHandler, errorHandler)['catch'](errorHandler);
      };
      readHandler = function(c){
        this$.latency += performance.now() - time;
        this$.timing += this$.latency;
        if (!stream) {
          throw null;
        }
        c = c.done
          ? null
          : c.value;
        if (pause) {
          return pause.then(function(){
            this$.paused = pause = false;
            if (!stream) {
              throw null;
            }
            return readComplete(c);
          });
        }
        return readComplete(c);
      };
      errorHandler = function(e){
        this$.error = stream
          ? new FetchError(0, 'stream failed: ' + e.message)
          : new FetchError(4, 'stream canceled');
        return null;
      };
      readComplete = function(d){
        var a, b, c;
        if (chunk) {
          a = chunk.dose;
          b = chunk.data.byteLength - a;
          if (d) {
            if ((c = d.byteLength) <= b) {
              chunk.data.set(d, a);
              if ((chunk.dose = a + c) === b) {
                d = chunk.data;
                chunk = null;
              } else {
                return readStart();
              }
            } else {
              chunk.data.set(d.subarray(0, b), a);
              buffer = newStreamBuffer(d, b);
              d = chunk.data;
              chunk = null;
            }
          } else {
            if (a) {
              d = chunk.data.slice(0, a);
            }
            chunk = null;
            this$.cancel();
          }
        } else if (!d) {
          this$.cancel();
        }
        locked = null;
        if (size > 0) {
          if (d) {
            this$.offset += d.length;
            this$.progress = this$.offset / size;
          } else {
            this$.offset = size;
            this$.progress = 1;
          }
        }
        return d;
      };
      readBufComplete = function(){
        var d;
        if (!stream) {
          return null;
        }
        d = chunk.data;
        chunk = locked = pause = null;
        if (size > 0) {
          this$.offset += d.length;
          this$.progress = this$.offset / size;
        }
        return d;
      };
      this.offset = 0;
      this.progress = 0.00;
      this.latency = 0;
      this.timing = 0;
      this.error = null;
      this.paused = false;
      this.response = res = data.response;
      this.size = size = res.headers['content-length'] ? parseInt(res.headers['content-length']) : 0;
      this.read = function(chunkSize){
        var c, a, b;
        if (!stream) {
          return nullResolved;
        }
        if (locked) {
          return locked;
        }
        this$.latency = 0;
        if (!chunk && chunkSize && chunkSize > 0) {
          chunk = new StreamChunk(chunkSize);
        }
        if (buffer) {
          if (!(c = buffer.data.byteLength - buffer.dose)) {
            buffer = null;
          } else if (chunk) {
            a = chunk.dose;
            b = chunk.data.byteLength - chunk.dose;
            if (c >= b) {
              b = buffer.dose + b;
              c = buffer.data.subarray(buffer.dose, b);
              buffer.dose = b;
              chunk.data.set(c, a);
              return locked = pause
                ? pause.then(readBufComplete)
                : nullResolved.then(readBufComplete);
            } else {
              b = buffer.dose + c;
              c = buffer.data.subarray(buffer.dose, b);
              chunk.data.set(c, a);
              chunk.dose += c.byteLength;
              buffer = null;
              return locked = pause
                ? pause.then(readStart)
                : readStart();
            }
          } else {
            chunk = newStreamBuffer(buffer.data.slice(buffer.dose), 0);
            buffer = null;
            return locked = pause
              ? pause.then(readBufComplete)
              : nullResolved.then(readBufComplete);
          }
        }
        return locked = pause
          ? pause.then(readStart)
          : readStart();
      };
      this.pause = function(){
        var a;
        if (!stream || pause) {
          return false;
        }
        this$.paused = true;
        a = null;
        pause = new Promise(function(resolve){
          a = resolve;
        });
        pause.resolve = a;
        return true;
      };
      this.resume = function(){
        if (!pause) {
          return false;
        }
        pause.resolve();
        return true;
      };
      this.cancel = function(){
        if (!stream) {
          return false;
        }
        reader.cancel();
        reader.releaseLock();
        reader = stream = null;
        if (pause) {
          pause.resolve();
        }
        return true;
      };
      this.readInt = async function(){
        var a;
        if (!(a = (await this$.read(4)))) {
          return null;
        }
        if (a.byteLength !== 4) {
          return null;
        }
        return a[0] << 24 | a[1] << 16 | a[2] << 8 | a[3];
      };
      this.readString = async function(){
        var a;
        if ((a = (await this$.readInt())) === null) {
          return null;
        }
        if ((a = (await this$.read(a))) === null) {
          return null;
        }
        return textDecode(a);
      };
      this.readJSON = async function(){
        var a, e;
        if ((a = (await this$.readString())) === null) {
          return null;
        }
        try {
          a = JSON.parse(a);
        } catch (e$) {
          e = e$;
          a = null;
        }
        return a;
      };
    };
    return FetchStream;
  }();
  FetchHandler = function(config){
    var this$ = this;
    this.config = config;
    this.api = new Api(this);
    this.store = new Map();
    this.fetch = function(){
      var d, o, options, data, e, r, a, i$, ref$, len$, b, c;
      d = new FetchData(config);
      o = new FetchOptions();
      if (config.mounted) {
        options = {};
        d.promise = newPromise(d);
        if (arguments.length) {
          options.data = data = arguments[0];
        }
      } else if ((e = parseArguments(arguments)) instanceof Error) {
        options = {};
        d.promise = newPromise(d);
      } else {
        options = e[0];
        if (e[1]) {
          d.callback = e[1];
        } else {
          d.promise = newPromise(d);
        }
        if (options.hasOwnProperty('data')) {
          data = options.data;
        }
        e = false;
      }
      r = d.response.request;
      r.setUrl(config.baseUrl, options.url);
      if (options.hasOwnProperty('timeout') && (a = options.timeout) >= 0) {
        d.timeout = 1000 * a;
      }
      if (options.hasOwnProperty('redirectCount')) {
        d.redirect.count = options.redirectCount | 0;
      }
      if (options.hasOwnProperty('parseResponse')) {
        d.parseResponse = typeof options.parseResponse === 'string' ? options.parseResponse : '';
      }
      for (i$ = 0, len$ = (ref$ = config.flagOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (options.hasOwnProperty(a)) {
          d[a] = !!options[a];
        }
      }
      d.aborter = (a = options.aborter) && a instanceof AbortController
        ? a
        : new AbortController();
      o.signal = d.aborter.signal;
      for (i$ = 0, len$ = (ref$ = config.fetchOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (options.hasOwnProperty(a)) {
          o[a] = options[a];
        } else if (config[a] !== null) {
          o[a] = config[a];
        }
      }
      if (options.hasOwnProperty('method')) {
        o.method = options.method;
      } else if (options.hasOwnProperty('data')) {
        o.method = 'POST';
      }
      r.headers = o.headers;
      if (config.headers) {
        o.setHeaders(config.headers);
      }
      if (toString$.call(options.headers).slice(8, -1) === 'Object') {
        o.setHeaders(options.headers);
      }
      if (data !== undefined && !e) {
        a = o.headers['content-type'];
        b = toString$.call(data).slice(8, -1);
        if (c = config.secret) {
          o.headers['content-encoding'] = 'aes256gcm';
          o.headers['etag'] = c.next().tag();
          switch (0) {
          case a.indexOf('application/x-www-form-urlencoded'):
            o.headers['content-type'] = 'application/json';
            // fallthrough
          case a.indexOf('application/json'):
            if (b !== 'String' && !(data = jsonEncode(data))) {
              e = new FetchError(3, 'failed to encode request data to JSON');
            }
            break;
          case a.indexOf('multipart/form-data'):
            if (b === 'String' || b === 'FormData') {
              e = new FetchError(3, 'encryption of prepared FormData is not supported');
            }
            delete o.headers['content-type'];
            break;
          default:
            if (b !== 'String' && b !== 'ArrayBuffer') {
              e = new FetchError(3, 'incorrect request raw data type');
            }
          }
        } else {
          switch (0) {
          case a.indexOf('application/json'):
            if (b !== 'String' && !(data = jsonEncode(data))) {
              e = new FetchError(3, 'failed to encode request data to JSON');
            }
            break;
          case a.indexOf('application/x-www-form-urlencoded'):
            if ((b !== 'String' && b !== 'URLSearchParams') && !(data = newQueryString(data))) {
              e = new FetchError(3, 'failed to encode request data to URLSearchParams');
            }
            break;
          case a.indexOf('multipart/form-data'):
            if ((b !== 'String' && b !== 'FormData') && !(data = newFormData(data))) {
              e = new FetchError(3, 'failed to encode request data to FormData');
            }
            if (b !== 'String') {
              delete o.headers['content-type'];
            }
            break;
          default:
            if (b !== 'String' && b !== 'ArrayBuffer') {
              e = new FetchError(3, 'incorrect request raw data type');
            }
          }
        }
        o.body = r.data = data;
      } else {
        delete o.headers['content-type'];
      }
      if (e) {
        if (d.callback) {
          d.callback(false, e);
          return d.aborter;
        } else {
          d.promise.pending = false;
          if (d.promiseReject) {
            d.promise.reject(e);
          } else {
            d.promise.resolve(e);
          }
          return d.promise;
        }
      }
      if (config.secret) {
        e = config.secret.encrypt(o.body, true);
        e.data.then(function(buf){
          o.body = e.data = buf;
          r.crypto = data;
          if (o.signal.aborted) {
            throw new FetchError(4, 'aborted programmatically');
          }
          this$.handler(d, o);
        })['catch'](function(e){
          if (!e.hasOwnProperty('id')) {
            e = new FetchError(2, 'encryption failed: ' + e.message);
          }
          this$.fail(d, e);
        });
      } else {
        this$.handler(d, o);
      }
      return d.callback
        ? d.aborter
        : d.promise;
    };
    this.handler = function(data, options){
      var res, sec, responseHandler, decryptHandler, successHandler, errorHandler;
      res = data.response;
      if (data.parseResponse === 'data') {
        sec = config.secret;
      }
      if (data.timeout) {
        data.timer = setTimeout(data.timerFunc, data.timeout);
      }
      responseHandler = function(r){
        var h, a, b;
        res.time = performance.now();
        res.status = r.status;
        res.type = r.type;
        res.headers = h = {};
        if (data.timer) {
          data.timerFunc(true);
        }
        a = r.headers.entries();
        while (!(b = a.next()).done) {
          h[b.value[0].toLowerCase()] = b.value[1];
        }
        if (!r.ok) {
          if (r.type === 'opaqueredirect') {
            throw new FetchError(0, 'opaque redirect');
          }
          if (r.status >= 300 && r.status <= 399) {
            if (!h.hasOwnProperty('location')) {
              throw new FetchError(0, 'no redirect location');
            }
            if (!(a = data.redirect).count) {
              throw new FetchError(0, 'no more redirects allowed');
            }
            if (a.count > 0 && ++a.current > a.count) {
              throw new FetchError(0, 'too many redirects');
            }
            res.request.url = h.location;
            this$.handler(data, options);
            throw null;
          }
          throw new FetchError(0, 'unsuccessful response status');
        }
        if (r.status !== 200 && data.status200) {
          throw new FetchError(0, 'HTTP status 200 required');
        }
        if (r.type === 'opaque' && data.parseResponse) {
          throw new FetchError(1, 'unable to parse opaque response');
        }
        switch (data.parseResponse) {
        case 'stream':
          return new FetchStream(r.body, data, sec);
        case 'data':
          if (sec) {
            return r.arrayBuffer();
          }
          b = h['content-type'] || '';
          if (a = options.headers.accept) {
            if (b && b.indexOf(a) !== 0) {
              throw new FetchError(1, 'incorrect content-type header');
            }
          } else {
            a = b;
          }
          switch (0) {
          case a.indexOf('application/json'):
            return r.text().then(jsonDecode);
          case a.indexOf('application/octet-stream'):
            return r.arrayBuffer();
          case a.indexOf('text/'):
            return r.text();
          case a.indexOf('image/'):
          case a.indexOf('audio/'):
          case a.indexOf('video/'):
            return r.blob();
          case a.indexOf('multipart/form-data'):
            return r.formData();
          default:
            return r.arrayBuffer();
          }
        }
        return r;
      };
      sec && (decryptHandler = function(buf){
        var a;
        if (buf.byteLength === 0) {
          return null;
        }
        a = sec.decrypt(buf, res.request.crypto.params);
        return a.data.then(function(d){
          var c;
          if (d === null) {
            d = new FetchError(2, 'decryption failed');
            sec.manager('fail', d);
            throw d;
          }
          a.data = buf;
          res.crypto = a;
          sec.save();
          c = options.headers.accept || res.headers['content-type'] || '';
          switch (0) {
          case c.indexOf('application/json'):
            c = jsonDecode(d);
            break;
          case c.indexOf('text/'):
            c = textDecode(d);
            break;
          default:
            c = d;
          }
          return c;
        });
      });
      successHandler = function(result){
        this$.success(data, result);
      };
      errorHandler = function(error){
        this$.fail(data, error);
      };
      res.request.time = performance.now();
      if (decryptHandler) {
        fetch(res.request.url, options).then(responseHandler).then(decryptHandler).then(successHandler)['catch'](errorHandler);
      } else {
        fetch(res.request.url, options).then(responseHandler).then(successHandler)['catch'](errorHandler);
      }
      this$.store.set(data, options);
    };
  };
  FetchHandler.prototype = {
    success: function(data, result){
      var a, options, this$ = this;
      switch (toString$.call(result).slice(8, -1)) {
      case 'Blob':
        if (result.size === 0) {
          result = null;
        }
        break;
      case 'ArrayBuffer':
        if (result.byteLength === 0) {
          result = null;
        }
      }
      if (data.notNull && result === null) {
        throw new FetchError(1, 'response result is null');
      }
      data.response.data = result;
      if (data.fullHouse && data.parseResponse === 'data') {
        result = data.response;
      }
      if (data.callback) {
        a = data.callback(true, result);
        if (a instanceof Promise) {
          options = this.store.get(data);
          a.then(function(retry){
            if (retry) {
              this$.handler(data, options);
            }
          });
        }
      } else {
        data.promise.pending = false;
        data.promise.resolve(result);
      }
      this.store['delete'](data);
    },
    fail: function(data, error){
      var options, a, this$ = this;
      if (error === null) {
        return;
      }
      if ((options = this.store.get(data)) && options.signal.aborted && !error.hasOwnProperty('id')) {
        error = data.timeout && !data.timer
          ? new FetchError(0, 'connection timed out')
          : new FetchError(4, error.message);
      }
      if (data.timer) {
        data.timerFunc(true);
      }
      if (!error.hasOwnProperty('id')) {
        error = new FetchError(5, error.message);
      }
      error.response = data.response;
      error.status = data.response.status;
      if (data.callback) {
        a = data.callback(false, error);
        if (a instanceof Promise && options) {
          a.then(function(retry){
            if (retry) {
              this$.handler(data, options);
            }
          });
        }
      } else {
        data.promise.pending = false;
        if (data.promiseReject) {
          data.promise.reject(error);
        } else {
          data.promise.resolve(error);
        }
      }
      this.store['delete'](data);
    }
  };
  Api = function(handler){
    var handshakeLocked;
    this.create = newInstance(handler.config);
    this.cancel = function(){
      return true;
    };
    this.form = function(){
      var a, b, c;
      if ((a = parseArguments(arguments)) instanceof Error) {
        return handler.fetch(a);
      }
      b = a[0];
      c = b.headers
        ? b.headers
        : {};
      if (typeof b.data === 'object') {
        c['content-type'] = isFormData(b.data) ? 'multipart/form-data' : 'application/x-www-form-urlencoded';
      } else {
        c['content-type'] = 'text/plain';
      }
      a[0].headers = c;
      a.method = 'POST';
      return handler.fetch(a[0], a[1]);
    };
    if (!apiCrypto) {
      return;
    }
    handshakeLocked = false;
    this.handshake = async function(url, storeManager){
      var k, hash, x, c, b, a, i;
      if (handshakeLocked) {
        return false;
      }
      if (!storeManager) {
        if (k = handler.config.secret) {
          handler.config.secret = null;
          apiCrypto.secretManagersPool['delete'](k.manager);
          k.manager('destroy', '');
        }
        return true;
      }
      if (apiCrypto.secretManagersPool.has(storeManager)) {
        consoleError('secret manager must be unique');
        return false;
      }
      handshakeLocked = true;
      if (k = storeManager('get')) {
        k = handler.config.secret = (await apiCrypto.newSecret(k, storeManager));
        handshakeLocked = false;
        return !!k;
      }
      if (!(hash = (await apiCrypto.generateHashPair()))) {
        handshakeLocked = false;
        return false;
      }
      x = false;
      c = 4;
      while (--c) {
        if (!(k = (await apiCrypto.generateKeyPair()))) {
          break;
        }
        b = {
          url: url,
          method: 'POST',
          data: k[1],
          headers: {
            'content-type': 'application/octet-stream',
            'etag': 'exchange'
          },
          fullHouse: false,
          timeout: 0
        };
        a = (await handler.fetch(b));
        if (!a || a instanceof Error) {
          break;
        }
        if ((a = (await apiCrypto.importKey(a))) === null) {
          break;
        }
        if ((a = (await apiCrypto.deriveKey(k[0], a))) === null) {
          break;
        }
        if ((k = (await apiCrypto.newSecret(a, storeManager))) === null) {
          break;
        }
        b.headers.etag = 'verify';
        if ((b.data = (await k.encrypt(hash[0]))) === null) {
          break;
        }
        a = (await handler.fetch(b));
        if (!a || !(a instanceof ArrayBuffer)) {
          break;
        }
        if ((i = a.byteLength) !== 0) {
          a = new Uint8Array(a);
          if ((b = hash[1]).byteLength !== i) {
            break;
          }
          while (--i >= 0) {
            if (a[i] !== b[i]) {
              break;
            }
          }
          if (i === -1) {
            x = true;
            break;
          }
        }
      }
      if (x && (handler.config.secret = k.save())) {
        apiCrypto.secretManagersPool.set(k.manager);
      }
      handshakeLocked = false;
      return x;
    };
  };
  ApiHandler = function(handler){
    this.get = function(f, k, p){
      var a;
      switch (k) {
      case 'isGlobal':
        return p === httpFetch;
      case 'secret':
        return (a = handler.config.secret) ? a.get() : '';
      case 'prototype':
        return FetchHandler.prototype;
      default:
        if (handler.config.hasOwnProperty(k)) {
          return handler.config[k];
        }
      }
      if (handler.api[k]) {
        return handler.api[k];
      }
      return null;
    };
    this.set = function(f, k, v){
      var cfg;
      cfg = handler.config;
      if (cfg.hasOwnProperty(k)) {
        if (k === 'baseUrl') {
          if (typeof v === 'string') {
            cfg[k] = v;
          }
        } else if (cfg.flagOptions.indexOf(k) !== -1) {
          cfg[k] = !!v;
        } else if ('timeout') {
          if ((v = parseInt(v)) >= 0) {
            cfg[k] = v;
          }
        }
      }
      return true;
    };
  };
  ApiHandler.prototype = {
    setPrototypeOf: function(){
      return false;
    },
    getPrototypeOf: function(){
      return FetchHandler.prototype;
    }
  };
  newFormData = function(){
    var add;
    add = function(data, item, key){
      var b, i$, len$, a;
      switch (toString$.call(item).slice(8, -1)) {
      case 'Object':
        b = Object.getOwnPropertyNames(item);
        if (key) {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(data, item[a], key + '[' + a + ']');
          }
        } else {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(data, item[a], a);
          }
        }
        break;
      case 'Array':
        key = key ? key + '[]' : '';
        b = item.length;
        a = -1;
        while (++a < b) {
          add(data, item[a], key);
        }
        break;
      case 'HTMLInputElement':
        if (item.type === 'file' && item.files.length) {
          add(data, item.files, key);
        }
        break;
      case 'FileList':
        if ((b = item.length) === 1) {
          data.append(key, item[0]);
        } else {
          a = -1;
          while (++a < b) {
            data.append(key + '[]', item[a]);
          }
        }
        break;
      case 'Null':
        data.append(key, '');
        break;
      default:
        data.append(key, item);
      }
      return data;
    };
    return function(o){
      return add(new FormData(), o, '');
    };
  }();
  newQueryString = function(){
    var add;
    add = function(list, item, key){
      var b, i$, len$, a;
      switch (toString$.call(item).slice(8, -1)) {
      case 'Object':
        b = Object.getOwnPropertyNames(item);
        if (key) {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(list, item[a], key + '[' + a + ']');
          }
        } else {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(list, item[a], a);
          }
        }
        break;
      case 'Array':
        key = key ? key + '[]' : '';
        b = item.length;
        a = -1;
        while (++a < b) {
          add(list, item[a], key);
        }
        break;
      case 'Null':
        list[list.length] = encodeURIComponent(key) + '=';
        break;
      default:
        list[list.length] = encodeURIComponent(key) + '=' + encodeURIComponent(item);
      }
      return list;
    };
    return function(o){
      return add([], o, '').join('&');
    };
  }();
  newPromise = function(fetchData){
    var a, b, p;
    a = b = null;
    p = new Promise(function(resolve, reject){
      a = resolve;
      b = reject;
    });
    p.resolve = a;
    p.reject = b;
    p.pending = true;
    p.abort = p.cancel = function(){
      if (fetchData.aborter) {
        fetchData.aborter.abort();
      }
    };
    return p;
  };
  newInstance = function(baseConfig){
    if (baseConfig && baseConfig.mounted) {
      return null;
    }
    return function(userConfig){
      var config, a, b;
      config = new FetchConfig();
      if (baseConfig) {
        config.setOptions(baseConfig);
      }
      if (userConfig) {
        config.setOptions(userConfig);
      }
      a = new FetchHandler(config);
      b = new ApiHandler(a);
      return new Proxy(a.fetch, b);
    };
  };
  return httpFetch = newInstance(null)(null);
}();