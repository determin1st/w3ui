// Generated by LiveScript 1.6.0
"use strict";
var redsock, toString$ = {}.toString;
redsock = function(){
  /* TODO {{{
  *
  * CSS property group concept
  * FLIP tech: emulate DOM node position/size change with transforms
  * delay option
  * conditional jumps (onStart + reposition)
  * null tweens
  * standard eases: bounce, elastic, spring
  * custom eases: split, step, bezier, zoom
  * mutation/resize observer?
  *
  /* INSERTION sort {{{
  if (c = d.length) > 2
  	# start from the second position,
  	# splitting the array into left and right sections
  	i = 1
  	while i < c
  		# get first element
  		# from the right section
  		a = d[i]
  		# determine last position of the left section
  		j = i - 1
  		# shift all elements of the left section
  		# to the right until the insert position found
  		while j >= 0 and d[j] > a
  			d[j + 1] = d[j]
  			--j
  		# insert and advance
  		d[j + 1] = a
  		++i
  /* }}} */
  /* }}} */
  var TICKER, EASE, CSS, ANIMATION;
  TICKER = function(){
    var InitData, LerpData, initializer, interpolator;
    InitData = {
      id: 0,
      queue: [],
      temp: [],
      index: 0,
      size: 0,
      min: 100
    };
    LerpData = {
      id: 0,
      time: 0,
      step: 0,
      minStep: 17,
      maxStep: 0,
      pool: new WeakSet(),
      qLerp: [],
      qSync: [],
      qTmp: [],
      nLerp: 0,
      nSync: 0,
      iSync: 0
    };
    initializer = function(deadline){
      var d, ref$, queue, temp, index, size, j;
      ref$ = d = InitData, queue = ref$.queue, temp = ref$.temp, index = ref$.index, size = ref$.size;
      if (index < size) {
        while (index < size) {
          if ((j = index + d.min) < size) {
            --index;
            while (++index < j) {
              temp[index] = queue[index].init(-1);
            }
            if (deadline && deadline.timeRemaining() === 0) {
              break;
            }
          } else {
            --index;
            while (++index < size) {
              temp[index] = queue[index].init(-1);
            }
          }
        }
        if (deadline) {
          d.index = index;
          d.id = window.requestIdleCallback(initializer);
          return;
        }
      }
      while (--index >= 0) {
        queue[index].initTargets();
      }
      queue.length = temp.length = 0;
      d.id = d.size = d.index = 0;
    };
    interpolator = function(timestamp){
      var d, ref$, qLerp, qSync, qTmp, n, s, i, m, k, j;
      ref$ = d = LerpData, qLerp = ref$.qLerp, qSync = ref$.qSync, qTmp = ref$.qTmp, n = ref$.nLerp, s = ref$.step;
      i = -1;
      m = -1;
      while (++i < n) {
        qLerp[i].move(s);
        if (d.iSync) {
          d.iSync = 0;
          qTmp[++m] = qLerp[i];
        }
      }
      while (k = d.nSync) {
        i = j = k;
        while (--i >= 0) {
          qSync[i].syncFirst();
        }
        while (++i < j) {
          qSync[i].syncLast();
        }
        while (--i >= 0) {
          if (qSync[i].syncSteady()) {
            qSync[--k] = qSync[i];
          }
        }
        if (k < j) {
          i = j;
          k = k - 1;
          while (--i > k) {
            qSync[i].syncInvert();
          }
          while (++i < j) {
            qSync[i].syncFirst();
          }
          while (++k < j) {
            qSync[k].syncReady();
          }
        }
        d.nSync = 0;
        i = -1;
        j = -1;
        while (++i <= m) {
          qTmp[i].update();
          if (d.iSync) {
            d.iSync = 0;
            qTmp[++j] = qTmp[i];
          }
        }
        m = j;
      }
      i = -1;
      j = -1;
      while (++i < n) {
        if ((k = qLerp[i]).ready) {
          k.render();
        }
        if (k.active) {
          qLerp[++j] = k;
        } else {
          k.initTargets();
          d.pool['delete'](k);
        }
      }
      if ((d.nLerp = j + 1) !== 0) {
        if ((s = Math.round(timestamp - d.time)) < d.minStep) {
          s = d.minStep;
        } else if (d.maxStep && s > d.maxStep) {
          s = d.maxStep;
        }
        d.step = s;
        d.time = timestamp;
        d.id = window.requestAnimationFrame(interpolator);
      } else {
        d.step = d.id = 0;
      }
    };
    return {
      init: function(){
        var d;
        d = InitData;
        d.queue[d.size] = this;
        ++d.size;
        if (d.id === 0) {
          d.id = window.requestIdleCallback(initializer);
        }
      },
      start: function(){
        var d;
        d = LerpData;
        if (!d.pool.has(this)) {
          d.pool.add(this);
          d.qLerp[d.nLerp] = this;
          ++d.nLerp;
          if (d.id === 0) {
            d.time = window.performance.now();
            d.id = window.requestAnimationFrame(interpolator);
          }
        }
      },
      sync: function(){
        var d;
        d = LerpData;
        d.qSync[d.nSync] = this;
        ++d.nSync;
        ++d.iSync;
      },
      completeInit: function(){
        var i;
        if (i = InitData.id) {
          window.cancelIdleCallback(i);
        }
        initializer();
      },
      cleanup: function(){
        var d;
        if ((d = LerpData).id === 0) {
          d.qLerp.length = d.qSync.length = d.qTmp.length = 0;
        }
      },
      currentFPS: {
        configurable: false,
        get: function(){
          return LerpData.id === 0
            ? 0
            : 1000 / LerpData.step;
        }
      },
      minFPS: {
        configurable: false,
        get: function(){
          return LerpData.maxStep ? 1000 / LerpData.maxStep : 0;
        },
        set: function(v){
          if ((v = parseInt(v)) < 0 || v > 60) {
            console.error('redsock:ticker:minFPS: incorrect');
            return;
          }
          LerpData.maxStep = v === 0
            ? 0
            : Math.round(1000 / v);
        }
      }
    };
  }();
  EASE = function(){
    var variant, pool, gen, parser, customParser;
    variant = ['in', 'out', 'in-out', 'out-in'];
    pool = {
      linear: null
    };
    gen = {
      power: {
        variant: true,
        pool: [1.5, 2, 3, 4, 5, 6],
        'default': 2,
        func: function(variant, n){
          var f, c1, c2, c3;
          switch (variant) {
          case 'in':
            f = function(x){
              return Math.pow(x, n);
            };
            break;
          case 'out':
            f = function(x){
              return 1 - Math.pow(1 - x, n);
            };
            break;
          case 'in-out':
            f = function(x){
              return x < 0.5
                ? Math.pow(2 * x, n) / 2
                : 1 - Math.pow(2 * (1 - x), n) / 2;
            };
            break;
          case 'out-in':
            c1 = Math.pow(0.5, 1 / n);
            c2 = 2 * c1;
            c3 = 0.5 / Math.pow(0.5, n);
            f = function(x){
              return x < 0.5
                ? 0.5 - Math.pow(c1 - c2 * x, n)
                : 0.5 + c3 * Math.pow(x - 0.5, n);
            };
          }
          return f;
        }
      },
      exp: {
        variant: true,
        func: function(variant){
          var f, c1;
          switch (variant) {
          case 'in':
            f = function(p){
              return Math.exp(10 * (p - 1));
            };
            break;
          case 'out':
            f = function(p){
              return 1 - Math.exp(-10 * p);
            };
            break;
          case 'in-out':
            f = function(p){
              p = p * 2;
              return p < 1
                ? 0.5 * Math.exp(10 * (p - 1))
                : 1 - 0.5 * Math.exp(10 * (1 - p));
            };
            break;
          case 'out-in':
            c1 = 1 / (2 - 2 / Math.exp(10));
            f = function(p){
              if (p < 0.5) {
                return c1 - c1 * Math.exp(-10 * 2 * p);
              }
              return 1 - c1 + c1 * Math.exp(10 * (2 * p - 2));
            };
          }
          return f;
        }
      },
      circ: {
        variant: true,
        func: function(variant){
          var f;
          switch (variant) {
          case 'in':
            f = function(p){
              return 1 - Math.sqrt(1 - p * p);
            };
            break;
          case 'out':
            f = function(p){
              p = p - 1;
              return Math.sqrt(1 - p * p);
            };
            break;
          case 'in-out':
            f = function(p){
              if ((p = p * 2) < 1) {
                return 0.5 * (1 - Math.sqrt(1 - p * p));
              }
              p = p - 2;
              return 0.5 * (1 + Math.sqrt(1 - p * p));
            };
            break;
          case 'out-in':
            f = function(p){
              if (p < 0.5) {
                p = p - 0.5;
                return Math.sqrt(0.25 - p * p);
              }
              p = 2 * p - 1;
              return 1 - 0.5 * Math.sqrt(1 - p * p);
            };
          }
          return f;
        }
      },
      sine: {
        variant: true,
        func: function(variant){
          var c1, c2, f;
          c1 = Math.PI / 2;
          c2 = Math.PI * 2;
          switch (variant) {
          case 'in':
            f = function(p){
              return 1 - Math.cos(p * c1);
            };
            break;
          case 'out':
            f = function(p){
              return Math.sin(p * c1);
            };
            break;
          case 'in-out':
            f = function(p){
              return 0.5 - 0.5 * Math.cos(p * Math.PI);
            };
            break;
          case 'out-in':
            f = function(p){
              if (p < 0.5) {
                return 0.5 * Math.sin(p * Math.PI);
              }
              return 1 - 0.5 * Math.sin(p * Math.PI);
            };
          }
          return f;
        }
      },
      back: {
        variant: true,
        pool: [1, 1.4, 1.7, 2],
        'default': 1,
        func: function(variant, amp){
          var c1, f, c2;
          switch (variant) {
          case 'in':
            c1 = amp + 1;
            f = function(x){
              return x * x * (c1 * x - amp);
            };
            break;
          case 'out':
            c1 = amp + 1;
            f = function(x){
              x = x - 1;
              return x * x * (c1 * x + amp) + 1;
            };
            break;
          case 'in-out':
            c1 = amp * 1.525;
            c2 = c1 + 1;
            f = function(x){
              if ((x = x * 2) < 1) {
                return 0.5 * x * x * (c2 * x - c1);
              }
              x = x - 2;
              return 0.5 * x * x * (c2 * x + c1) + 1;
            };
            break;
          case 'out-in':
            c1 = amp * 1.525 / 2;
            c2 = c1 + 0.5;
            f = function(x){
              if (x <= 0.5) {
                x = 2 * x - 1;
                return x * x * (c2 * x + c1) + 0.5;
              }
              x = 2 * x - 1;
              return x * x * (c2 * x - c1) + 0.5;
            };
          }
          return f;
        }
      },
      bounce: {
        variant: true,
        pool: [0, 0, 0],
        'default': 1
        /***
        	_wrap("Bounce",
        		_create("BounceOut", function(p) {
        			if (p < 1 / 2.75) {
        				return 7.5625 * p * p;
        			} else if (p < 2 / 2.75) {
        				return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
        			} else if (p < 2.5 / 2.75) {
        				return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
        			}
        			return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
        		}),
        		_create("BounceIn", function(p) {
        		}),
        		_create("BounceInOut", function(p) {
        			var invert = (p < 0.5);
        			if (invert) {
        				p = 1 - (p * 2);
        			} else {
        				p = (p * 2) - 1;
        			}
        			if (p < 1 / 2.75) {
        				p = 7.5625 * p * p;
        			} else if (p < 2 / 2.75) {
        				p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
        			} else if (p < 2.5 / 2.75) {
        				p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
        			} else {
        				p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
        			}
        			return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
        		})
        	);
        /***/,
        func: function(variant, x){
          var f;
          switch (variant) {
          case 'in':
            f = function(p){
              p = 1 - p;
              if (p < 1 / 2.75) {
                return 1 - 7.5625 * p * p;
              } else if (p < 2 / 2.75) {
                p = p - 1.5 / 2.75;
                return 1 - (7.5625 * p * p + 0.75);
              } else if (p < 2.5 / 2.75) {
                p = p - 2.25 / 2.75;
                return 1 - (7.5625 * p * p + 0.9375);
              }
              p = p - 2.625 / 2.75;
              return 1 - (7.5625 * p * p + 0.984375);
            };
            break;
          case 'out':
            f = function(p){
              return p;
            };
            break;
          case 'in-out':
            f = function(p){
              return p;
            };
            break;
          case 'out-in':
            f = function(p){
              return p;
            };
          }
          return f;
        }
      },
      elastic: {
        variant: true,
        pool: []
        /***
        	_createElastic = function(n, f, def) {
        		var C = _class("easing." + n, function(amplitude, period) {
        				this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
        				this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
        				this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
        				this._p2 = _2PI / this._p2; //precalculate to optimize
        			}, true),
        			p = C.prototype = new Ease();
        		p.constructor = C;
        		p.getRatio = f;
        		p.config = function(amplitude, period) {
        			return new C(amplitude, period);
        		};
        		return C;
        	};
        	_wrap("Elastic",
        		_createElastic("ElasticOut", function(p) {
        			return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
        		}, 0.3),
        		_createElastic("ElasticIn", function(p) {
        			return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
        		}, 0.3),
        		_createElastic("ElasticInOut", function(p) {
        			return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
        		}, 0.45)
        	);
        /***/,
        func: function(variant, x){
          var f;
          switch (variant) {
          case 'in':
            f = function(p){
              return p;
            };
            break;
          case 'out':
            f = function(p){
              return p;
            };
            break;
          case 'in-out':
            f = function(p){
              return p;
            };
            break;
          case 'out-in':
            f = function(p){
              return p;
            };
          }
          return f;
        }
      },
      step: {
        func: function(p){
          return p;
        }
      }
    };
    parser = function(name){
      var n, v, ref$, i, f;
      if (!name) {
        return null;
      }
      if (pool.hasOwnProperty(name)) {
        return pool[name];
      }
      if (name.indexOf(' ') > 0) {
        return customParser(name);
      }
      if ((n = name.split('-')).length < 2) {
        console.log('redsock: ease variant is not specified "' + name + '"');
        return null;
      }
      v = n.slice(1).join('-');
      if (variant.indexOf(v) < 0) {
        console.log('redsock: incorrect ease variant "' + v + '"');
        return null;
      }
      if (!(n = n[0].match(/([a-z]+)(\d*)/))) {
        console.log('redsock: incorrect ease name "' + name + '"');
        return null;
      }
      ref$ = n.slice(1), n = ref$[0], i = ref$[1];
      if (!n || !(f = gen[n])) {
        if (n !== 'linear') {
          console.log('redsock: incorrect ease name "' + name + '"');
        }
        return null;
      }
      if (f.pool) {
        if (!i || !(i = parseInt(i))) {
          if (in$('default', f)) {
            console.log('redsock: ease parameter required "' + name + '"');
            return null;
          }
          i = f['default'];
        } else if (i > f.pool.length) {
          console.log('redsock: wrong ease parameter "' + name + '"');
          return null;
        }
        f = f.func(v, f.pool[i - 1]);
      } else {
        f = f.func(v);
      }
      f.keyword = name;
      pool[name] = f;
      return f;
    };
    customParser = function(name){
      var ref$, n, i, f;
      ref$ = name.split(' '), n = ref$[0], i = ref$[1];
      if (!(n = name.split('-')).length) {
        true;
      }
      if (!n || !gen.hasOwnProperty(n)) {
        console.log('redsock: incorrect ease name "' + name + '"');
        return null;
      }
      if (!(i = i.split(','))) {
        console.log('redsock: incorrect ease parameters "' + name + '"');
        return null;
      }
      if (!(f = gen[n](i))) {
        return null;
      }
      f.keyword = name;
      pool[name] = f;
      return f;
    };
    parser.pool = pool;
    parser.gen = gen;
    return parser;
  }();
  CSS = function(){
    var TargetMap, TweenMap, PropMap, RuleMap, PropSet, ClassTween, ClassOption, TweenData, AnimationStore, TargetTween;
    TargetMap = new WeakMap();
    TweenMap = new function(){
      var map, Tween, Descriptor, a;
      map = {
        pixel: {
          init: function(){
            this.v1 = parseFloat(this.first);
            this.v2 = parseFloat(this.last);
            this.delta = this.v2 - this.v1;
          },
          lerp: function(){
            return (this.v1 + this.delta * this.active.scale) + 'px';
          }
        },
        integer: {
          init: function(){
            this.v1 = parseInt(this.first);
            this.v2 = parseInt(this.last);
            this.delta = this.v2 - this.v1;
          },
          lerp: function(){
            return this.v1 + this.delta * this.active.scale | 0;
          }
        },
        float: {
          init: function(){
            this.v1 = parseFloat(this.first);
            this.v2 = parseFloat(this.last);
            this.delta = this.v2 - this.v1;
          },
          lerp: function(){
            return this.v1 + this.delta * this.active.scale;
          }
        },
        color: function(){
          var RGBAParse, init, lerp;
          RGBAParse = function(){
            var exp;
            exp = /(\d+),\s*(\d+),\s*(\d+)(,\s*(\d*(\.\d+)?))?/;
            return function(v){
              v = v.match(exp);
              return [parseInt(v[1]), parseInt(v[2]), parseInt(v[3]), v[5] ? parseFloat(v[5]) : 1];
            };
          }();
          init = [
            function(){
              var c1, c2, d;
              this.v1 = c1 = RGBAParse(this.first);
              this.v2 = c2 = RGBAParse(this.last);
              c1[0] = Math.pow(c1[0], 2);
              c1[1] = Math.pow(c1[1], 2);
              c1[2] = Math.pow(c1[2], 2);
              this.delta = d = [Math.pow(c2[0], 2) - c1[0], Math.pow(c2[1], 2) - c1[1], Math.pow(c2[2], 2) - c1[2], c2[3] - c1[3]];
              this.lerp = Math.abs(d[3]) < 0.001
                ? lerp[0]
                : c2[3] < 0.001
                  ? lerp[4]
                  : c1[3] < 0.001
                    ? lerp[5]
                    : lerp[1];
            }, function(){
              var c1, c2, d;
              this.v1 = c1 = RGBAParse(this.first);
              this.v2 = c2 = RGBAParse(this.last);
              this.delta = d = [c2[0] - c1[0], c2[1] - c1[1], c2[2] - c1[2], c2[3] - c1[3]];
              this.lerp = Math.abs(d[3]) < 0.001
                ? lerp[2]
                : c2[3] < 0.001
                  ? lerp[4]
                  : c1[3] < 0.001
                    ? lerp[5]
                    : lerp[3];
            }
          ];
          lerp = [
            function(){
              var a, b, c;
              a = this.v1;
              b = this.delta;
              c = this.active.scale;
              return 'rgba(' + (Math.sqrt(a[0] + b[0] * c) | 0) + ',' + (Math.sqrt(a[1] + b[1] * c) | 0) + ',' + (Math.sqrt(a[2] + b[2] * c) | 0) + ',' + a[3] + ')';
            }, function(){
              var a, b, c;
              a = this.v1;
              b = this.delta;
              c = this.active.scale;
              return 'rgba(' + (Math.sqrt(a[0] + b[0] * c) | 0) + ',' + (Math.sqrt(a[1] + b[1] * c) | 0) + ',' + (Math.sqrt(a[2] + b[2] * c) | 0) + ',' + (a[3] + b[3] * c).toFixed(2) + ')';
            }, function(){
              var a, b, c;
              a = this.v1;
              b = this.delta;
              c = this.active.scale;
              return 'rgba(' + (a[0] + b[0] * c | 0) + ',' + (a[1] + b[1] * c | 0) + ',' + (a[2] + b[2] * c | 0) + ',' + a[3] + ')';
            }, function(){
              var a, b, c;
              a = this.v1;
              b = this.delta;
              c = this.active.scale;
              return 'rgba(' + (a[0] + b[0] * c | 0) + ',' + (a[1] + b[1] * c | 0) + ',' + (a[2] + b[2] * c | 0) + ',' + (a[3] + b[3] * c).toFixed(2) + ')';
            }, function(){
              var a;
              a = this.v1;
              return 'rgba(' + a[0] + ',' + a[1] + ',' + a[2] + ',' + (a[3] + this.delta[3] * this.active.scale).toFixed(2) + ')';
            }, function(){
              var a;
              a = this.v2;
              return 'rgba(' + a[0] + ',' + a[1] + ',' + a[2] + ',' + (this.v1[3] + this.delta[3] * this.active.scale).toFixed(2) + ')';
            }
          ];
          return {
            init: init[0],
            lerp: lerp[0],
            config: function(enableRGB2){
              if (arguments.length === 0) {
                return this.init === init[0];
              }
              this.init = enableRGB2
                ? init[0]
                : init[1];
              return true;
            }
          };
        }(),
        transforms: {
          group: function(){
            var Group;
            Group = function(me){
              this.left = null;
              this.right = null;
              this.top = null;
              this.bottom = null;
              this.width = null;
              this.height = null;
              me.v1 = [0, 0, 0, 0, 0, 0, new DOMMatrix()];
              me.v2 = [0, 0, 0, 0, 0, 0, new DOMMatrix(), false];
            };
            return Group;
          }(),
          init: function(t){
            var a, b, m, c, d;
            a = this.v1;
            b = this.v2;
            if (this.steady === 2) {
              true;
            }
            m = b[6];
            c = a[0] * (b[4] - b[2]) + a[2] * (b[0] - b[4]) + a[4] * (b[2] - b[0]);
            d = b[0] * (b[3] - b[5]) + b[2] * (b[5] - b[1]) + b[4] * (b[1] - b[3]);
            m.c = c / d;
            m.a = (a[2] - a[0] - m.c * (b[3] - b[1])) / (b[2] - b[0]);
            m.e = a[0] - m.a * b[0] - m.c * b[3];
            c = a[1] * (b[4] - b[2]) + a[3] * (b[0] - b[4]) + a[5] * (b[2] - b[0]);
            d = b[1] * (b[4] - b[2]) + b[3] * (b[0] - b[4]) + b[5] * (b[2] - b[0]);
            m.d = c / d;
            m.b = (a[3] - a[1] - m.d * (b[3] - b[1])) / (b[2] - b[0]);
            m.f = a[1] - m.b * b[0] - m.d * b[3];
            d = a[6];
            d.a = m.a - d.a;
            d.b = m.b - d.b;
            d.c = m.c - d.c;
            d.d = m.d - d.d;
            d.e = m.e - d.e;
            d.f = m.f - d.f;
            b[7] = true;
          },
          lerp: function(s){
            var a, b, c;
            a = this.v1[6];
            b = this.v2;
            c = this.active.scale;
            if (b[7]) {
              b[7] = false;
              s.transformOrigin = (-b[0]) + 'px ' + (-b[1]) + 'px';
            }
            b = b[6];
            s.transform = 'matrix(' + (b.a - c * a.a) + ',' + (b.b - c * a.b) + ',' + (b.c - c * a.c) + ',' + (b.d - c * a.d) + ',' + (b.e - c * a.e) + ',' + (b.f - c * a.f) + ')';
          }
        }
      };
      Tween = function(){
        this.active = null;
        this.steady = 0;
        this.group = false;
        this.name = '';
        this.first = false;
        this.last = null;
        this.v1 = null;
        this.v2 = null;
        this.delta = null;
        this.init = null;
        this.lerp = null;
      };
      Descriptor = function(name, type){
        this.name = name;
        this.init = type.init, this.lerp = type.lerp, this.config = type.config, this.group = type.group, this.apply = type.apply;
        this.construct = function(prop){
          var a, b;
          a = new Tween();
          a.init = this.init;
          a.lerp = this.lerp;
          if (this.group) {
            a.group = true;
            a.name = this.name;
            for (b in a.last = new this.group(a)) {
              prop[b] = a;
            }
          } else {
            a.name = prop;
          }
          return a;
        };
      };
      for (a in map) {
        this[a] = new Descriptor(a, map[a]);
      }
      a = map = Descriptor = null;
    };
    PropMap = new function(){
      var map, create, Descriptor, a, b, i$, ref$, len$, c, d;
      map = {
        pixel: {
          isDynamic: function(v){
            return !v.endsWith('px');
          },
          filter: function(v){
            return typeof v === 'number' ? v + 'px' : v;
          },
          list: ['left', 'right', 'top', 'bottom', 'width', 'height', 'maxWidth', 'minWidth', 'maxHeight', 'minHeight', 'perspective', 'flexBasis', 'gridRowGap', 'gridColumnGap', 'columnGap', 'columnRuleWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderBottomRightRadius', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'outlineOffset', 'outlineWidth', 'fontSize', 'lineHeight', 'wordSpacing', 'textIndent']
        },
        integer: {
          isDynamic: function(v){
            return false;
          },
          filter: function(v){
            return isNaN(v = parseInt(v))
              ? ''
              : v.toString();
          },
          list: ['zIndex', 'order', 'columnCount', 'fontWeight']
        },
        float: {
          isDynamic: function(v){
            return false;
          },
          filter: function(v){
            return isNaN(v = parseFloat(v)) ? '' : v;
          },
          list: ['flexGrow', 'flexShrink', 'opacity', 'fontSizeAdjust']
        },
        color: {
          isDynamic: function(v){
            return false;
          },
          filter: function(v){
            return v;
          },
          list: ['color', 'backgroundColor', 'borderTopColor', 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'outlineColor', 'columnRuleColor', 'caretColor']
        }
      };
      create = function(){
        return this.type.construct(this.camel);
      };
      Descriptor = function(tween, prop, camel, hyphen){
        this.camel = camel;
        this.hyphen = hyphen;
        this.type = tween;
        this.create = create;
        this.isDynamic = prop.isDynamic, this.filter = prop.filter;
      };
      for (a in map) {
        b = map[a];
        for (i$ = 0, len$ = (ref$ = b.list).length; i$ < len$; ++i$) {
          c = ref$[i$];
          d = {};
          d[c.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()] = true;
          d = Object.keys(d)[0];
          this[c] = new Descriptor(TweenMap[a], b, c, d);
          if (c !== d) {
            this[d] = this[c];
          }
        }
      }
    };
    RuleMap = new function(){
      var RuleValue, RuleSet, Descriptor;
      RuleValue = function(value, flag){
        this.value = value;
        this.dynamic = flag;
      };
      RuleSet = function(){
        this.list = [];
        this.prop = new PropSet();
      };
      Descriptor = function(cssRule){
        var list, prop, i$, ref$, b, len$, a, c, d;
        list = [];
        prop = new PropSet();
        for (i$ = 0, len$ = (ref$ = b = cssRule.style).length; i$ < len$; ++i$) {
          a = ref$[i$];
          if (c = PropMap[a]) {
            a = c.camel;
            d = b[a];
            list[list.length] = a;
            prop[a] = new RuleValue(d, c.isDynamic(d));
          }
        }
        if (list.length) {
          a = cssRule.selectorText;
          b = 100 * (a.split('#').length - 1) + 10 * (a.split('.').length - 1);
          this.list = list;
          this.prop = prop;
          this.selector = a;
          this.weight = b;
        }
      };
      this.list = [];
      this.data = {};
      this.size = 0;
      this.init = function(sheetFilter, selectFilter){
        var b, i$, ref$, len$, a, c, i, j$, len1$, e;
        this.list.length = 0;
        this.data = {};
        if (sheetFilter) {
          b = [];
          for (i$ = 0, len$ = (ref$ = document.styleSheets).length; i$ < len$; ++i$) {
            a = ref$[i$];
            if (sheetFilter.includes(a.title)) {
              b[b.length] = a;
            }
          }
        } else {
          b = document.styleSheets;
        }
        c = [];
        i = -1;
        for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
          a = b[i$];
          if (!a.disabled) {
            try {
              for (j$ = 0, len1$ = (ref$ = a.cssRules).length; j$ < len1$; ++j$) {
                a = ref$[j$];
                if (a.type === 1) {
                  c[++i] = a;
                }
              }
            } catch (e$) {
              e = e$;
              console.warn('redsock:css: failed to get stylesheet rules');
            }
          }
        }
        if (selectFilter) {
          b = [];
          i = -1;
          for (i$ = 0, len$ = c.length; i$ < len$; ++i$) {
            a = c[i$];
            if (a.selector.indexOf(selectFilter) !== -1) {
              b[++i] = a;
            }
          }
          c = b;
        }
        b = this.list;
        i = -1;
        for (i$ = 0, len$ = c.length; i$ < len$; ++i$) {
          a = c[i$];
          if ((a = new Descriptor(a)).list) {
            b[++i] = a;
          }
        }
        b.sort(function(a, b){
          a = a.weight;
          b = b.weight;
          return a === b
            ? 0
            : a < b ? -1 : 1;
        });
        this.size = 1 + (b.length >>> 4);
      };
      this.match = function(node){
        var k, s, ref$, list, prop, i$, len$, i, a, b, j$, ref1$, len1$;
        k = new Uint16Array(this.size);
        ref$ = s = new RuleSet(), list = ref$.list, prop = ref$.prop;
        for (i$ = 0, len$ = (ref$ = this.list).length; i$ < len$; ++i$) {
          i = i$;
          a = ref$[i$];
          if (node.matches(a.selector)) {
            b = i >>> 4;
            i = 1 << i - (b << 4);
            k[b] = k[b] | i;
            b = a.prop;
            for (j$ = 0, len1$ = (ref1$ = a.list).length; j$ < len1$; ++j$) {
              i = ref1$[j$];
              if (!prop[i]) {
                list[list.length] = i;
              }
              prop[i] = b[i];
            }
          }
        }
        k = String.fromCharCode.apply(null, k);
        this.data[k] = s;
        return k;
      };
      this.diff = function(v1, v2){
        var o, ref$, list, prop, l1, l2, i$, len$, a;
        ref$ = o = new RuleSet(), list = ref$.list, prop = ref$.prop;
        v1 = this.data[v1];
        v2 = this.data[v2];
        l1 = v1.list;
        l2 = v2.list;
        v1 = v1.prop;
        v2 = v2.prop;
        for (i$ = 0, len$ = l2.length; i$ < len$; ++i$) {
          a = l2[i$];
          if (!v1[a] || v1[a] !== v2[a]) {
            list[list.length] = a;
            prop[a] = v2[a];
          }
        }
        for (i$ = 0, len$ = l1.length; i$ < len$; ++i$) {
          a = l1[i$];
          if (!v2[a]) {
            list[list.length] = a;
            prop[a] = new RuleValue('', true);
          }
        }
        return o;
      };
      this.option = function(o){
        var option, ref$, list, prop, a, b, c;
        ref$ = option = new RuleSet(), list = ref$.list, prop = ref$.prop;
        for (a in o) {
          b = o[a];
          if (c = PropMap[a]) {
            a = c.camel;
            b = c.filter(b);
            list[list.length] = a;
            prop[a] = new RuleValue(b, c.isDynamic(b));
          }
        }
        return list.length === 0 ? null : option;
      };
    };
    PropSet = function(){
      var m, a, f;
      m = {};
      for (a in PropMap) {
        m[PropMap[a].camel] = true;
      }
      f = '(function() {';
      for (a in m) {
        f += 'this.' + a + ' = null;';
      }
      m = a = null;
      return f = eval(f + '})');
    }();
    ClassTween = function(){
      this.active = null;
      this.list = null;
      this.name = null;
    };
    ClassOption = function(){
      this.add = null;
      this.remove = null;
      this.toggle = null;
    };
    ClassOption.prototype = {
      resolve: function(list){
        var a, i$, ref$, len$, b, c;
        a = list.slice();
        if (this.add) {
          for (i$ = 0, len$ = (ref$ = this.add).length; i$ < len$; ++i$) {
            b = ref$[i$];
            if (!a.includes(b)) {
              a[a.length] = b;
            }
          }
        }
        if (this.remove) {
          for (i$ = 0, len$ = (ref$ = this.remove).length; i$ < len$; ++i$) {
            b = ref$[i$];
            if ((c = a.indexOf(b)) !== -1) {
              a[c] = false;
            }
          }
        }
        if (this.toggle) {
          for (i$ = 0, len$ = (ref$ = this.toggle).length; i$ < len$; ++i$) {
            b = ref$[i$];
            if ((c = a.indexOf(b)) === -1) {
              a[a.length] = b;
            } else {
              a[c] = false;
            }
          }
        }
        return a.filter(Boolean).sort();
      }
    };
    TweenData = function(){
      this.captive = null;
      this.first = null;
      this.last = null;
      this.dynamic = false;
    };
    AnimationStore = function(animation){
      var o, a, c, i$, ref$, len$, b;
      this.ref = animation;
      this.scale = 0;
      o = animation.options;
      if (o.className) {
        this.clas = a = new TweenData();
        a.dynamic = o.className;
      } else {
        this.clas = null;
      }
      this.prop = new PropSet();
      if (o.css) {
        this.list = o.css.list;
        c = o.css.prop;
        for (i$ = 0, len$ = (ref$ = this.list).length; i$ < len$; ++i$) {
          a = ref$[i$];
          this.prop[a] = b = new TweenData();
          b.last = c[a].value;
          b.dynamic = c[a].dynamic;
        }
      } else {
        this.list = null;
      }
    };
    TargetTween = function(target){
      this.target = target;
      this.style = null;
      this.tween = [];
      this.complete = [];
      this.name = new ClassTween();
      this.id = {};
      this.rule = {};
      this.active = [];
      this.list = [];
      this.prop = new PropSet();
      this.ready = false;
      this.steady = false;
      this.go = false;
    };
    TargetTween.prototype = {
      apply: function(aTween){
        var active, list, prop, style, c, d, a, b, i$, ref$, len$, e;
        active = this.active, list = this.list, prop = this.prop;
        style = this.target.style;
        if (c = aTween.clas) {
          c.first = (d = this.name).list;
          a = d.name;
          if (d.active) {
            b = c.last = c.dynamic.resolve(d.list);
          } else {
            b = c.last;
          }
          c.captive = d.active;
          d.active = aTween;
          d.list = b;
          d.name = b = b.join(' ');
          this.target.setAttribute('class', b);
          if (!(c = this.id)[b]) {
            c[b] = RuleMap.match(this.target);
          }
          a = c[a];
          b = c[b];
          c = this.rule;
          if (!(d = c[a])) {
            c[a] = {};
            d = c[a][b] = RuleMap.diff(a, b);
          } else if (!(d = c[a][b])) {
            d = c[a][b] = RuleMap.diff(a, b);
          }
          b = aTween.prop;
          c = d.prop;
          for (i$ = 0, len$ = (ref$ = d.list).length; i$ < len$; ++i$) {
            a = ref$[i$];
            if (e = b[a]) {
              if (e.last) {
                continue;
              }
            } else {
              e = b[a] = new TweenData();
            }
            if (!(d = prop[a])) {
              this.ready = false;
              list[list.length] = prop[a] = d = PropMap[a].create();
            }
            e.first = style[a];
            if (d.group) {
              if (d.active !== aTween) {
                if (d.active) {
                  true;
                } else {
                  active[active.length] = d;
                }
                d.active = aTween;
                d.steady = 2;
              }
              if ((d.last[a] = c[a]).dynamic) {
                if (e.first) {
                  style[a] = c[a].value;
                }
                this.steady = false;
                d.steady = 0;
              }
            } else {
              if (d.active) {
                if (d.active.ref.complete) {
                  d.first = d.last.value;
                } else {
                  e.captive = d.active;
                  d.first = e.first;
                }
              } else {
                active[active.length] = d;
              }
              d.active = aTween;
              if (c[a].dynamic) {
                if (e.first) {
                  style[a] = c[a].value;
                }
                this.steady = false;
              } else {
                d.last = c[a].value;
                d.steady = 1;
              }
            }
          }
        }
        if (aTween.list) {
          b = aTween.prop;
          for (i$ = 0, len$ = (ref$ = aTween.list).length; i$ < len$; ++i$) {
            a = ref$[i$];
            d = prop[a];
            e = b[a];
            if (d.active !== aTween) {
              if (d.active) {
                e.first = d.first;
                if (d.active.ref.complete) {
                  d.first = d.last;
                } else {
                  e.captive = d.active;
                  d.first = d.lerp();
                }
              } else {
                e.first = style[a];
                active[active.length] = d;
              }
              d.active = aTween;
              d.delta = null;
              if (e.dynamic) {
                d.last = null;
                style[a] = e.last;
                this.steady = false;
              } else {
                d.last = e.last;
              }
            }
          }
        }
      }
    };
    return {
      init: function(){
        RuleMap.init();
      },
      cleanup: function(){
        TargetMap = new WeakMap();
      },
      enableRGB2: {
        configurable: false,
        get: function(){
          return TweenMap.color.config();
        },
        set: TweenMap.color.config
      },
      newOptionProp: RuleMap.option,
      newOptionClass: function(o){
        var o1, o2, o3, i$, ref$, len$, a;
        if (!o) {
          return null;
        }
        o1 = [];
        o2 = [];
        o3 = [];
        for (i$ = 0, len$ = (ref$ = o.split(' ')).length; i$ < len$; ++i$) {
          a = ref$[i$];
          switch (a[0]) {
          case '+':
            o1[o1.length] = a.substring(1);
            break;
          case '-':
            o2[o2.length] = a.substring(1);
            break;
          case '!':
            o3[o3.length] = a.substring(1);
          }
        }
        if (!o1.length && !o2.length && !o3.length) {
          return null;
        }
        a = new ClassOption();
        if (o1.length) {
          a.add = o1;
        }
        if (o2.length) {
          a.remove = o2;
        }
        if (o3.length) {
          a.toggle = o3;
        }
        return a;
      },
      createTargets: function(){
        var ta, tw, i$, ref$, len$, t, a, ref1$, b;
        this.target = ta = [];
        this.tween = tw = [];
        for (i$ = 0, len$ = (ref$ = this.options.target).length; i$ < len$; ++i$) {
          t = ref$[i$];
          if (!(a = TargetMap.get(t))) {
            TargetMap.set(t, a = new TargetTween(t));
          }
          (ref1$ = a.tween)[ref1$.length] = b = new AnimationStore(this);
          a.style = null;
          ta[ta.length] = a;
          tw[tw.length] = b;
        }
      },
      initTargets: function(){
        var i$, ref$, len$, t, target, name, list, prop, j$, ref1$, len1$, a, k$, ref2$, len2$, b;
        for (i$ = 0, len$ = (ref$ = this.target).length; i$ < len$; ++i$) {
          t = ref$[i$];
          if (!t.active.length) {
            target = t.target, name = t.name, list = t.list, prop = t.prop;
            if (!t.style) {
              t.style = window.getComputedStyle(target);
              list.length = 0;
              for (j$ = 0, len1$ = (ref1$ = t.tween).length; j$ < len1$; ++j$) {
                a = ref1$[j$];
                if (true) {
                  list[list.length] = TweenMap.transforms.construct(prop);
                }
                if (a.list) {
                  for (k$ = 0, len2$ = (ref2$ = a.list).length; k$ < len2$; ++k$) {
                    b = ref2$[k$];
                    if (!prop[b]) {
                      list[list.length] = prop[b] = PropMap[b].create();
                    }
                  }
                }
              }
              name.list = target.className.split(' ').sort();
              name.name = b = name.list.join(' ');
              a = t.id[name.name] = RuleMap.match(target);
              for (j$ = 0, len1$ = (ref1$ = RuleMap.data[a].list).length; j$ < len1$; ++j$) {
                a = ref1$[j$];
                if (!prop[a]) {
                  list[list.length] = prop[a] = PropMap[a].create();
                }
              }
              for (j$ = 0, len1$ = (ref1$ = target.style).length; j$ < len1$; ++j$) {
                a = ref1$[j$];
                if (b = PropMap[a]) {
                  if (!prop[b.camel]) {
                    list[list.length] = prop[b.camel] = b.create(prop);
                  }
                }
              }
            }
            for (j$ = 0, len1$ = (ref1$ = t.tween).length; j$ < len1$; ++j$) {
              a = ref1$[j$];
              a.scale = 0;
              if (b = a.clas) {
                b.last = b.dynamic.resolve(name.list);
              }
            }
            a = target.style;
            b = RuleMap.data[t.id[t.name.name]].prop;
            for (j$ = 0, len1$ = list.length; j$ < len1$; ++j$) {
              prop = list[j$];
              prop.steady = 0;
              prop.first = false;
              name = prop.name;
              if (prop.group) {
                true;
              } else {
                if (a[name]) {
                  if (!PropMap[name].isDynamic(a[name])) {
                    prop.first = a[name];
                  }
                } else if (b[name]) {
                  if (!b[name].dynamic) {
                    prop.first = b[name].value;
                  }
                }
              }
            }
            t.ready = false;
            t.steady = false;
          }
        }
        this.started = false;
        this.complete = false;
        this.position = 0;
      }
    };
  }();
  ANIMATION = function(){
    var Animation, Api, apiProxy;
    Animation = function(options, parent, index){
      this.options = options;
      this.queue = false;
      this.duration = 0;
      this.delay = 0;
      this.position = 0;
      this.ease = false;
      this.target = false;
      this.tween = false;
      this.callback = false;
      this.api = false;
      this.started = false;
      this.active = false;
      this.complete = false;
      this.ready = false;
      if (this.parent = parent) {
        this.proxy = parent.parent ? parent.proxy : parent;
        this.init(index);
      } else {
        this.proxy = new Proxy(this, apiProxy);
        this.deferInit();
      }
    };
    Animation.prototype = {
      init: function(){
        var optionType, Option, optionList, optionInherit, optionCloneable, Queue;
        optionType = new function(){
          var map, Type, a, b, c;
          map = {
            clone: {
              Object: function(v){
                return (v = v.redsock) ? v : null;
              }
            },
            target: {
              Array: true,
              loose: function(v){
                return !v instanceof Element
                  ? null
                  : [v];
              }
            },
            duration: {
              String: function(v){
                if (isNaN(v = parseFloat(v))) {
                  return null;
                }
                if ((v = 1000 * v | 0) < 1) {
                  return null;
                }
                return v;
              },
              Number: function(v){
                if ((v = 1000 * v | 0) < 1) {
                  return null;
                }
                return v;
              }
            },
            delay: {
              Number: function(v){
                if ((v = 1000 * v | 0) < 1) {
                  return null;
                }
                return v;
              }
            },
            position: {
              String: true,
              Number: function(v){
                return v < 0
                  ? null
                  : 1000 * v | 0;
              }
            },
            label: {
              String: true
            },
            ease: {
              Function: true,
              String: EASE
            },
            className: {
              String: CSS.newOptionClass
            },
            css: {
              Object: CSS.newOptionProp
            },
            queue: {
              Array: function(v){
                var x, i$, len$, a, c;
                if (v.length === 0) {
                  return null;
                }
                x = [];
                for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
                  a = v[i$];
                  if ((c = typeof a) === 'function') {
                    x[x.length] = {
                      onUpdate: a
                    };
                  } else if (c !== 'object' || !a) {
                    return null;
                  } else if (a.redsock) {
                    x[x.length] = {
                      clone: a
                    };
                  } else {
                    x[x.length] = a;
                  }
                }
                return x;
              }
            },
            positions: {
              Array: true,
              Number: function(v){
                if (v < 0 || v > 100) {
                  return null;
                }
                return '^' + v;
              }
            },
            onStart: {
              Function: true
            },
            onUpdate: {
              Function: true
            },
            onComplete: {
              Function: true
            }
          };
          Type = function(){
            this.Boolean = false;
            this.Number = false;
            this.String = false;
            this.Function = false;
            this.Object = false;
            this.Array = false;
            this.loose = false;
          };
          for (a in map) {
            this[a] = b = new Type();
            for (c in map[a]) {
              b[c] = map[a][c];
            }
          }
          map = Type = a = b = c = null;
        };
        Option = function(){
          var f, a;
          f = '(function() {';
          for (a in optionType) {
            f += 'this.' + a + ' = null;';
          }
          return f = eval(f + '})');
        }();
        Option.prototype = {
          createMap: function(){
            return true;
          }
        };
        optionList = ['clone', 'target', 'duration', 'delay', 'position', 'label', 'ease', 'className', 'css', 'queue', 'positions', 'onStart', 'onUpdate', 'onComplete'];
        optionInherit = {
          position: function(parent, index){
            var a;
            if (a = parent.options.positions) {
              switch (typeof a) {
              case 'string':
                return a;
              case 'object':
                if (a[index] !== null) {
                  return a[index];
                }
              }
            }
            return null;
          },
          ease: function(parent, index){
            return (parent = parent.options.ease) ? parent : false;
          }
        };
        optionCloneable = function(){
          var m, o, a;
          m = ['target', 'duration', 'label', 'ease', 'className', 'css', 'queue', 'positions', 'onStart', 'onUpdate', 'onComplete'];
          o = new Option();
          for (a in o) {
            o[a] = m.includes(a);
          }
          return o;
        }();
        Queue = function(parent, list){
          var q, duration, i$, len$, i, a, b, c, d;
          q = [];
          duration = 0;
          for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
            i = i$;
            a = list[i$];
            q[i] = a = new Animation(a, parent, i);
            if (a.options.position === null) {
              a.position = duration;
              duration = duration + a.delay + a.duration;
            } else {
              if (typeof (b = a.position) === 'string') {
                switch (b[0]) {
                case '^':
                  if (i === 0) {
                    b = 0;
                  } else {
                    c = q[i - 1];
                    b = parseInt(b.substring(1)) / 100;
                    b = c.position + b * (c.delay + c.duration) | 0;
                  }
                  break;
                case '+':
                  b = duration + 1000 * parseFloat(b) | 0;
                  break;
                case '-':
                  b = duration + 1000 * parseFloat(b) | 0;
                  if (b < 0) {
                    b = 0;
                  }
                  break;
                default:
                  b = 0;
                }
              }
              a.position = b;
              if ((b = b + a.delay + a.duration) > duration) {
                duration = b;
              }
            }
          }
          this.list = q;
          this.duration = duration;
          this.start = b = [];
          this.stop = c = [];
          this.delta = d = [];
          if (parent.options.duration !== null) {
            this.scaleDuration((parent.duration - duration) / duration);
          } else {
            for (i$ = 0, len$ = q.length; i$ < len$; ++i$) {
              i = i$;
              a = q[i$];
              b[i] = a.position;
              c[i] = b[i] + a.delay + a.duration;
              d[i] = c[i] - b[i];
            }
          }
        };
        Queue.prototype = {
          scaleDuration: function(s){
            var b, c, d, i$, ref$, len$, i, a;
            b = this.start;
            c = this.stop;
            d = this.delta;
            this.duration = this.duration + (this.duration * s | 0);
            for (i$ = 0, len$ = (ref$ = this.list).length; i$ < len$; ++i$) {
              i = i$;
              a = ref$[i$];
              a.position = a.position + (a.position * s | 0);
              a.duration = a.duration + (a.duration * s | 0);
              a.delay = a.delay + (a.delay * s | 0);
              b[i] = a.position;
              c[i] = b[i] + a.delay + a.duration;
              d[i] = c[i] - b[i];
              if (a.queue) {
                a.queue.scaleDuration(s);
              }
            }
          }
        };
        return function(index){
          var x, o, i$, ref$, len$, a, b, c, d, q, j$, ref1$, len1$;
          x = this.options;
          this.options = o = new Option();
          for (i$ = 0, len$ = (ref$ = optionList).length; i$ < len$; ++i$) {
            a = ref$[i$];
            if (x.hasOwnProperty(a)) {
              b = x[a];
              c = toString$.call(b).slice(8, -1);
              d = optionType[a];
              if (c = d[c]) {
                if (c !== true) {
                  b = c(b);
                }
              } else if (b && (c = d.loose)) {
                b = c(b);
              } else {
                b = null;
              }
              if ((o[a] = b) === null) {
                console.error('redsock:option:' + a + ': incorrect');
              }
            } else {
              if (optionCloneable[a] && o.clone && (b = o.clone.options[a])) {
                o[a] = b;
              }
            }
          }
          if (index === -1) {
            this.api = new Api(this, this.proxy);
          } else {
            for (a in optionInherit) {
              if (!o[a]) {
                o[a] = optionInherit[a](this.parent, index);
              }
            }
          }
          if (o.duration !== null) {
            this.duration = o.duration;
          }
          if (o.delay !== null) {
            this.delay = o.delay;
          }
          if (o.position !== null) {
            this.position = o.position;
          }
          if (o.ease !== null) {
            this.ease = o.ease;
          }
          if (o.onStart || o.onUpdate || o.onComplete) {
            this.callback = a = clone$(this);
            a.onStart = o.onStart;
            a.onUpdate = o.onUpdate;
            a.onComplete = o.onComplete;
          }
          if (o.target) {
            this.createTargets();
          }
          if (o.queue) {
            this.queue = q = new Queue(this, o.queue);
            if (o.duration === null) {
              this.duration = q.duration;
            }
            if (!(c = this.target)) {
              c = this.target = [];
            }
            for (i$ = 0, len$ = (ref$ = q.list).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (a.target) {
                for (j$ = 0, len1$ = (ref1$ = a.target).length; j$ < len1$; ++j$) {
                  b = ref1$[j$];
                  if (!c.includes(b)) {
                    c[c.length] = b;
                  }
                }
              }
            }
          }
          return x;
        };
      }(),
      move: function(s){
        if ((this.position += s) > this.duration) {
          this.active = false;
          this.complete = true;
          this.position = this.duration;
        }
        this.update();
      },
      update: function(){
        var q, p, a, b, c, i, d, i$, ref$, len$;
        q = this.queue;
        p = this.position;
        if (this.started) {
          if (this.tween) {
            a = this.target;
            b = this.tween;
            c = b.length;
            i = -1;
            if (this.complete) {
              while (++i < c) {
                d = a[i];
                d.go = true;
                d.complete[d.complete.length] = b[i];
              }
            } else {
              d = p / this.duration;
              if (this.ease) {
                d = this.ease(d);
              }
              while (++i < c) {
                a[i].go = true;
                b[i].scale = d;
              }
            }
            if (this.parent) {
              this.proxy.ready = true;
            } else {
              this.ready = true;
            }
          }
          if (c = this.callback) {
            c.onUpdate && c.onUpdate();
            this.complete && c.onComplete && c.onComplete();
          }
        } else {
          if ((c = this.callback) && c.onStart && !c.onStart()) {
            return;
          }
          this.started = true;
          if (this.tween) {
            this.deferSync();
          }
          if (q) {
            for (i$ = 0, len$ = (ref$ = q.list).length; i$ < len$; ++i$) {
              a = ref$[i$];
              a.active = true;
              a.started = false;
              a.complete = false;
              a.position = 0;
            }
          }
        }
        if (q) {
          b = q.start, c = q.stop, d = q.delta;
          for (i$ = 0, len$ = (ref$ = q.list).length; i$ < len$; ++i$) {
            i = i$;
            a = ref$[i$];
            if (a.active) {
              if (a.started) {
                if (b[i] > p) {
                  if (!a.complete) {
                    a.complete = true;
                    a.started = false;
                    a.position = 0;
                    a.update();
                  }
                } else if (c[i] <= p) {
                  if (!a.complete) {
                    a.complete = true;
                    a.position = a.duration;
                    a.update();
                  }
                } else {
                  a.complete = false;
                  a.position = p - b[i];
                  a.update();
                }
              } else if (b[i] <= p) {
                a.update();
                if (!a.started) {
                  a.active = false;
                }
              }
            }
          }
        }
      },
      render: function(){
        var i$, ref$, len$, t, active, complete, style, k, i, c, j, j$, len1$, a, e, b, d;
        for (i$ = 0, len$ = (ref$ = this.target).length; i$ < len$; ++i$) {
          t = ref$[i$];
          if (t.go) {
            active = t.active;
            complete = t.complete;
            style = t.target.style;
            if (k = complete.length) {
              i = -1;
              while (++i < k) {
                c = complete[i];
                j = -1;
                for (j$ = 0, len1$ = active.length; j$ < len1$; ++j$) {
                  a = active[j$];
                  if (a.active === c) {
                    e = c.prop;
                    if (a.group) {
                      for (b in d = a.group) {
                        if (d[b]) {
                          style[b] = e[b].last;
                        }
                      }
                      d = null;
                      if (!d) {
                        if (a.name === 'transforms') {
                          style.transform = null;
                          style.transformOrigin = null;
                        }
                      }
                    } else {
                      b = e[a.name];
                      style[a.name] = b.last;
                      while (d = b.captive) {
                        b.captive = null;
                        if (!d.ref.complete) {
                          break;
                        }
                        b = d.prop[a.name];
                      }
                    }
                    if (a.active = d) {
                      active[++j] = a;
                    }
                  } else {
                    active[++j] = a;
                  }
                }
                active.length = j + 1;
              }
              complete.length = 0;
            }
            for (j$ = 0, len1$ = active.length; j$ < len1$; ++j$) {
              a = active[j$];
              if (a.group) {
                a.lerp(style);
              } else {
                style[a.name] = a.lerp();
              }
            }
            t.go = false;
          }
        }
        this.ready = false;
      },
      syncFirst: function(){
        var target, j, i, t, i$, ref$, len$, a, b, c;
        target = this.target;
        j = this.tween.length;
        i = -1;
        while (++i < j) {
          if (!(t = target[i]).ready) {
            for (i$ = 0, len$ = (ref$ = t.list).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (!a.first) {
                if (a.group) {
                  if (a.name === 'transforms') {
                    b = a.v1;
                    c = t.target.getBoundingClientRect();
                    b[0] = c.left;
                    b[1] = c.top;
                    b[2] = b[0] + c.width;
                    b[3] = b[1];
                    b[4] = b[2];
                    b[5] = b[1] + c.height;
                    b[6].setMatrixValue(t.style.transform);
                  }
                  a.first = true;
                } else {
                  a.first = t.style[a.name];
                }
              }
            }
            t.ready = true;
            t.steady = true;
          }
        }
      },
      syncLast: function(){
        var target, tween, j, i;
        target = this.target, tween = this.tween;
        j = tween.length;
        i = -1;
        while (++i < j) {
          target[i].apply(tween[i]);
        }
      },
      syncSteady: function(){
        var invert, target, j, i, t, i$, ref$, len$, a, b, c;
        invert = false;
        target = this.target;
        j = this.tween.length;
        i = -1;
        while (++i < j) {
          if (!(t = target[i]).steady) {
            for (i$ = 0, len$ = (ref$ = t.active).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (!a.steady) {
                if (a.group) {
                  if (a.name === 'transforms') {
                    b = a.v2;
                    c = t.target.getBoundingClientRect();
                    b[0] = c.left;
                    b[1] = c.top;
                    b[2] = b[0] + c.width;
                    b[3] = b[1];
                    b[4] = b[2];
                    b[5] = b[1] + c.height;
                  }
                } else {
                  a.last = t.style[a.name];
                }
                a.steady = 1;
              }
            }
            t.steady = true;
          }
          if (t.ready) {
            for (i$ = 0, len$ = (ref$ = t.active).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (a.steady) {
                if (a.group) {
                  a.init(t);
                } else {
                  a.init();
                }
                a.steady = 0;
              }
            }
          } else {
            invert = true;
          }
        }
        return invert;
      },
      syncInvert: function(){
        var target, j, i, t, a, b, i$, ref$, len$;
        target = this.target;
        j = this.tween.length;
        i = -1;
        while (++i < j) {
          t = target[i];
          if (!t.ready && t.steady) {
            a = t.name.active;
            while (b = a.clas.captive) {
              a = b;
            }
            t.target.setAttribute('class', a.clas.first.join(' '));
            b = t.target.style;
            for (i$ = 0, len$ = (ref$ = t.active).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (!a.first) {
                b[a.name] = null;
                a.delta = null;
              }
            }
            t.steady = false;
            t.go = true;
          }
        }
      },
      syncReady: function(){
        var target, j, i, t, i$, ref$, len$, a;
        target = this.target;
        j = this.tween.length;
        i = -1;
        while (++i < j) {
          t = target[i];
          if (t.go) {
            t.target.setAttribute('class', t.name.name);
            for (i$ = 0, len$ = (ref$ = t.active).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (!a.delta) {
                a.init();
              }
            }
            t.go = false;
          }
        }
      },
      createTargets: CSS.createTargets,
      initTargets: CSS.initTargets,
      deferInit: TICKER.init,
      deferStart: TICKER.start,
      deferSync: TICKER.sync
    };
    Api = function(){
      var method, f, a;
      method = {
        start: function(me, proxy){
          return function(){
            if (!me.active) {
              me.active = true;
              me.deferStart();
            }
            return proxy;
          };
        },
        stop: function(me, proxy){
          return function(){
            me.active = false;
            return proxy;
          };
        },
        cancel: function(me, proxy){
          return function(){
            return proxy;
          };
        },
        complete: function(me, proxy){
          return function(noCallback){
            return proxy;
          };
        },
        set: function(me, proxy){
          return function(scale){
            return proxy;
          };
        }
      };
      f = '(function(a,b) {';
      for (a in method) {
        f += 'this.' + a + ' = method.' + a + '(a,b);';
      }
      return f = eval(f + '})');
    }();
    apiProxy = function(){
      var alias;
      alias = {
        play: 'start',
        pause: 'stop',
        revert: 'cancel',
        finish: 'complete',
        progress: 'set'
      };
      return {
        get: function(me, k){
          if (!me.api) {
            TICKER.completeInit();
            console.log('redsock: forced initialization');
          }
          switch (k) {
          case 'active':
            return me[k];
          case 'target':
            return me.options.target;
          case 'duration':
            return me.duration / 1000;
          case 'scale':
          case 'progress':
            return me.position / me.duration;
          case 'ease':
            return me.ease ? me.ease.keyword : 'linear';
          case 'redsock':
            return me;
          }
          if (me.api[k]) {
            return me.api[k];
          }
          if (alias[k]) {
            return me.api[alias[k]];
          }
          return me[k];
        },
        set: function(me, k, v){
          var c;
          switch (k) {
          case 'onStart':
          case 'onUpdate':
          case 'onComplete':
            if (!(c = me.callback)) {
              c = me.callback = clone$(me);
              c.onStart = false;
              c.onUpdate = false;
              c.onComplete = false;
            }
            c[k] = v;
          }
          return true;
        }
      };
    }();
    return Animation;
  }();
  return function(){
    var me;
    me = function(options){
      if (toString$.call(options).slice(8, -1) !== 'Object') {
        console.error('redsock:options: incorrect type');
        return null;
      }
      return new ANIMATION(options).proxy;
    };
    me.init = function(){
      CSS.init();
    };
    me.cleanup = function(){
      TICKER.cleanup();
      CSS.cleanup();
    };
    Object.defineProperty(me, 'FPS', TICKER.currentFPS);
    Object.defineProperty(me, 'minFPS', TICKER.minFPS);
    Object.defineProperty(me, 'enableRGB2', CSS.enableRGB2);
    me.minFPS = 10;
    me.ease = EASE;
    return Object.seal(me);
  }();
}();
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}