// Generated by LiveScript 1.5.0
"use strict";
false && (w3ui.slider = {
  /* {{{
  * rev90, TODO:
  * task #10: slider constructor
  * negative values
  * large values
  * multiple handles >2
  * multiple ranges, minmax, array
  * <-(arrow capture keys)-> with acceleration
  * GSAP animation
  * better sync for handle/range animation
  * new standard with slash(/) syntax in border-radius
  * revise relative option
  * optimize range refresh routine
  * image slider
  */
  options: {
    ORDER: ['minmax', 'count', 'step', 'margin', 'value'],
    minmax: [0, 100],
    count: 1,
    step: 1,
    margin: [],
    value: [0],
    range: [0, 0],
    orientation: true,
    strict: false,
    inner: false,
    round: 0,
    tabindex: -1,
    toggle: false,
    k_pages: 5,
    k_range: ['ctrlKey', 'HOME', 'END'],
    k_value: ['ctrlKey', 'LEFT', 'RIGHT']
  },
  data: {
    handles: null,
    handleIndex: -1,
    maxCount: 10,
    min: 0,
    max: 100,
    shift: 0,
    size: 100,
    margin: 0,
    val: null,
    scale: null
  },
  create: function(){
    var data, opts, a, b, c, i$, to$, d, len$;
    data = this.data;
    opts = this.options;
    a = this.node.query('');
    b = a.length;
    c = opts.count;
    if (b !== c) {
      if (b > c) {
        for (i$ = b - 1, to$ = c - 1; i$ <= to$; ++i$) {
          d = i$;
          this.node.child.remove(a[d].node);
        }
      } else {
        for (i$ = 0, to$ = c - b; i$ <= to$; ++i$) {
          d = i$;
          a = document.createElement('div');
          this.node.child.add(a);
        }
      }
      a = this.node.query('');
    }
    a['class'].add('ui-' + this.name + '-handle');
    a.prop.tabindex = opts.tabindex;
    for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
      c = i$;
      b = a[i$];
      b.prop.dataIndex = c + 1;
    }
    a.size = this.getHandleSize();
    a.pos = d.handleSize.map(function(){
      return {
        left: 0,
        top: 0
      };
    });
    d.handles = a;
    if (d.range) {
      if (!d.range$) {
        b = [];
        for (i$ = 0, to$ = d.range.length; i$ <= to$; ++i$) {
          a = i$;
          if (d.range[a] >= 0) {
            a = document.createElement('div');
            b.push(a);
            this.element.append(a);
          }
        }
        b = $(b);
        b.addClass(this.name + "-range");
        b.each(function(index){
          return b.eq(index).addClass('n' + (index + 1));
        });
        d.range$ = $(b);
      }
      d.range$.css({
        left: "",
        top: ""
      });
      a = ['min', 'max'];
      b = d.range.length - 1;
      o.direction && a.reverse();
      d.range[0] < 0 && d.range.element.eq(0).addClass(a[0]);
      d.range[b] < 0 && d.range.element.eq(b).addClass(a[1]);
    } else if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    this.refresh(true);
    return true;
  },
  setup: function(key, val){
    var dat, opt, msg, a, i$, ref$, to$, b, c, v, len$, m, this$ = this;
    dat = this.data;
    opt = this.options;
    msg = function(msg){
      return this$.log('incorrect option «' + key + '», ' + msg);
    };
    switch (key) {
    case 'minmax':
      if (!('length' in val)) {
        msg('wrong type');
        return;
      }
      if (val.length !== 2) {
        msg('incorrect length');
        return;
      }
      val = [Math.round(val[0]), Math.round(val[1])];
      if (val[0] === val[1]) {
        msg('values cant be equal');
        return;
      }
      a = val.slice();
      dat.reversed = a[0] < a[1];
      if (dat.reversed) {
        a.reverse();
      }
      dat.shift = a[0] < 0 ? -a[0] : 0;
      if (dat.shift) {
        a[0] = 0;
        a[1] = a[1] + dat.shift;
      }
      dat.min = a[0];
      dat.max = a[1];
      dat.size = a[1] - a[0];
      break;
    case 'count':
      val = Math.round(val);
      if (val <= 0) {
        msg('must be greater than zero');
        val = 1;
      }
      if (val > dat.maxCount) {
        msg('must be less than ' + dat.maxCount);
        val = dat.maxCount;
      }
      if (val > opt.count) {
        for (i$ = opt.count; i$ <= val; ++i$) {
          a = i$;
          opt.margin.push(0);
          opt.value.push((ref$ = opt.value)[ref$.length - 1]);
          opt.range.push(0);
        }
      } else if (val < opt.count) {
        for (i$ = val, to$ = opt.count; i$ <= to$; ++i$) {
          a = i$;
          opt.margin.pop();
          opt.value.pop();
          opt.range.pop();
        }
      }
      break;
    case 'step':
      val = Math.round(val);
      if (val <= 0) {
        msg('should be positive');
        val = 1;
      }
      a = Math.round((dat.max - dat.min) / opt.count);
      if (val > a) {
        msg('must be less than ' + a);
        val = a;
      }
      break;
    case 'margin':
      val = val.map(function(val){
        var a;
        val = Math.round(val);
        if (val < 0) {
          msg('should be positive');
          val = 0;
        }
        if ((a = val % opt.step) !== 0) {
          msg('should be aligned with the step ' + opt.step);
          val -= a;
        }
        return val;
      });
      a = val.reduce(function(a, b){
        return a + b;
      }, 0);
      b = dat.max - dat.min - a;
      c = Math.round(a / opt.step);
      if (b <= 0 || c < opt.count) {
        msg('the total margin ' + a + ' is too big');
        return;
      }
      dat.margin = a;
      break;
    case 'value':
      if (val.length < opt.count) {
        msg('minimum ' + opt.count + ' items required');
        return;
      }
      if (val.length > opt.count) {
        msg('limited by ' + opt.count);
        val = val.slice(0, opt.count);
      }
      v = val.map(function(v){
        return Math.round(v);
      }).sort(function(a, b){
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      });
      dat.shift && (v = v.map(function(v){
        return v + dat.shift;
      }));
      for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
        b = i$;
        a = v[i$];
        if (a < dat.min) {
          v[b] = dat.min;
        }
        if (a > dat.max) {
          v[b] = dat.max;
        }
      }
      if (dat.margin) {
        m = opt.margin;
        for (i$ = 0, len$ = m.length; i$ < len$; ++i$) {
          b = i$;
          a = m[i$];
          if (a > 0) {
            if ((c = v[b + 1] - v[b]) >= a) {
              continue;
            }
            c = a - c;
            a = v[b] - c;
            if ((b === 0 && a >= dat.min) || v[b - 1] + m[b - 1] >= a) {
              v[b] = a;
              continue;
            }
            a = v[++b] + c;
            if ((b >= m.length && a <= dat.max) || v[b + 1] - a >= m[b]) {
              v[b] = a;
              continue;
            }
            msg('failed to apply margins');
            return;
          }
        }
      }
      dat.val = v;
      break;
    case 'range':
      val = val.map(function(val){
        return !!val;
      });
      a = opt.count + 1;
      while (val.length < a) {
        val.push(false);
      }
      if (val.length > a) {
        val.slice(0, a);
      }
      break;
    case 'toggle':
      val = !!val;
      if (opt.count === 1 && val) {
        msg('supported only for a single handle');
        val = false;
      }
      break;
    case 'orientation':
      a = val ? 'horizontal' : 'vertical';
      this.node['class'].add('ui-' + this.name + '-' + a);
      break;
    case 'tabindex':
      if (val !== null) {
        val = isNaN(a = parseInt(val)) ? null : a;
      }
      this.node.prop.tabindex = null;
      break;
    default:
      msg('not implemented');
      return;
    }
    return val;
  },
  refresh: function(init){
    var d, o, a, b, c;
    d = this.data;
    o = this.options;
    a = this.element[0];
    a = {
      left: a.offsetLeft,
      top: a.offsetTop,
      height: a.offsetHeight,
      width: a.offsetWidth,
      h: a.clientHeight,
      w: a.clientWidth,
      margin: 0,
      handle: 0
    };
    this.element.parents().each(function(index, el){
      a.left += el.scrollLeft;
      a.top += el.scrollTop;
    });
    b = o.orientation
      ? [a.w(a.h)]
      : [a.h(a.w)];
    if (d.margin) {
      c = d.margin / d.size;
      a.margin = b[0] * c;
    }
    a.handle = o.inner
      ? b[1]
      : 1.5 * b[1];
    c = o.round ? this.cssValue(b[1] / 2) : "";
    this.element.css("border-radius", c);
    d.scale = a;
    a = [];
    d.handles.each(function(index, node){
      var b;
      b = {
        w: node.clientWidth,
        h: node.clientHeight,
        width: node.offsetWidth,
        height: node.offsetHeight,
        w_gap: 0,
        h_gap: 0
      };
    });
    /***
    # определим классификаторы фиксированной оси и шкалы
    a = ["h", "height", "innerHeight", "outerHeight", "h_gap"];
    b = ["w", "width",  "innerWidth",  "outerWidth",  "w_gap"];
    @orientation && (d = a, a = b, b = d);
        # ..
        # prepare
        #node = d.handles.eq index
        # добавляем индекс
        #node.data "ui-slider-handle-index", index
        # определяем зазор
        d[a[4]] = el[a[3]](true) - d[a[0]];
        d[b[4]] = el[b[3]](true) - d[b[0]];
        # определяем полный размер ползунка
        # фиксированная ось
        c = @elementSize.handle;# авто-размер
        # в случае, если текущий стиль не конфликтует с опциями,
        # оставляем его, иначе назначаем авто-размер.
        d[a[1]] = (d[a[0]] > 1 && (!@options.inner || d[a[0]] < c)) ?
                (d[a[0]] + d[a[4]]) : c;
        # шкала
        d[b[1]] = (d[b[0]] > 1) ?
                (d[b[0]] + d[b[4]]) : c;
        # определяем внутренний размер
        d[a[0]] = Math.abs(d[a[1]] - d[a[4]]);
        d[b[0]] = Math.abs(d[b[1]] - d[b[4]]);
        # кривизна границ
        c = @options.round;
        if (c > 1)
        {
            # закругленные границы
            # в зависимости от внутреннего размера ползунка на фиксированной оси
            d["border-radius"] = @_cssValue(d[a[0]] / 2);
            # круглый ползунок
            if (c > 2)
            {
                # размеры симметричны (длина == ширина)
                # за основу берем размер на фиксированной оси
                d[b[0]] = d[a[0]];
                d[b[1]] = d[b[0]] + d[b[4]];
                d["border-radius"] = "50%";
            }
        }
        # определим соотношение внутренних размеров
        d.scale = d[b[0]] / d[a[0]]; # плавающая / фиксированная
        # сохраняем
        e[index] = d;
        true
    
    # определяем размер
    
    
    
    e = [];
    
    
    @handles.toArray!forEach(function(el, index) {
    }, this);
    
    
    
    
    # align on fixed axis
    d.handles.each (index, node) !->
        # determine offset (center)
        d = @handleSize[index];
        e = @elementSize[b[0]];
        e = [
            d[b[0]],
            e / 2.0 - d[b[1]] / 2.0,
            e,
            "border-radius"
        ]
        # проверка необходимости
        if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
            Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
        {
            # выполняем позиционирование
            # без анимации
            a = {};
            a[b[1]] = @_cssValue(e[0], e[2]);
            a[b[2]] = @_cssValue(e[1], e[2]);
            if (d[e[3]]) {
                a[e[3]] = d[e[3]];
            }
            node.css(a);
        }
    # ..
    
    
    
    
    
    
    
    
    
    
    
    # ..
    a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
    b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"]
    @orientation && (c = a, a = b, b = c);
    # collect handles
    for (c = [], d = 0; d < @val.length; d++) {
        c[d] = @handles.eq(d);
    }
    # 1. позиционируем на шкале
    # {{{
    # вычисляем полный размер
    d = @handleSize;
    d.full = 0;
    c.forEach(function(node, index) {
        # подготовка
        e = d[index];
        # размер на шкале пропорционален размеру на фиксированной оси
        # внутренний размер
        e[a[0]] = e.scale * e[b[0]];
        # полный размер
        e[a[1]] = e[a[0]] + e[a[5]];
        d.full += e[a[1]];
    });
    # позиционирование
    c.forEach(function(node, index) {
        # обновляем размер
        # без анимации
        d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
        e = {}, e[a[1]] = d;
        node.css(e);
        # обновляем смещение
        # с условной анимацией
        @_refreshHandle(index, !fixedAxis);
    }, this);
    # }}}
    /***/
    this.refreshRange();
    return true;
  },
  addEvents: function(){},
  event: function(){
    return true;
  },
  delEvents: function(){
    this._mouseDestroy();
    this._off(this.handles);
    return $(window).off("resize." + this.eventNamespace);
  },
  destroy: function(){
    var d;
    this.delEvents();
    d = this.data;
    d.handle.remove();
    delete d.handle;
    delete d.handleSize;
    delete d.handleOffset;
    if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    return true;
  },
  api: {
    alias: {
      value: ['val', 'value', 'values'],
      range: ['range', 'ranges']
    }
    /***
    value: function(val, index) { # {{{
        var a, b;
        ##
        a = arguments.length;
        if (!a) {
            return @values(0);
        }
        b = typeof val;
        if (b !== "number" && b !== "string") {
            return false;
        }
        if (a === 1) {
            return @values(0, val);
        }
        if (index < 0 || index >= @val.length) {
            return false;
        }
        return @values(index, val);
    },
    # }}}
    values: function(index, val) { # {{{
        var a, b, c;
        ##
        # подготовка
        a = arguments.length;
        b = arguments[0];
        # возвращаем все значения
        if (a === 0) {
            return @_valueRefined(@val, true);
        }
        # сохраняем массив значений
        if (a === 1 && jQuery.isArray(b))
        {
            if (!@_event("change", null, -1, @_valueRefined(b))) {
                return b;
            }
            return @_valueRefined(b, true);
        }
        # сохраняем единственное значение
        if (a === 2)
        {
            b = @_valueRefined(val);
            c = @val.slice!
            c[index] = b;
            return @_event("change", null, index, c) ? b : false;
        }
        # возвращаем единственное значение
        return @_valueRefined(@val[index]);
    },
    # }}}
    range: function(index) { # {{{
        index = arguments.length ? 0 + index : 0;
        return @ranges(index);
    },
    # }}}
    ranges: function() { # {{{
        var a, b, c, d;
        ##
        if (!@_rangeMap) {
            return false;
        }
        # подготовка
        a = arguments.length;
        b = [];
        for (c = 0; c < @_rangeMap.length; c += 2)
        {
            d = [
                @_rangeMap[c],
                @_rangeMap[c + 1]
            ];
            @options.direction && d.reverse!
            d[0] = d[0] < 0 ? @min : @val[d[0]];
            d[1] = d[1] < 0 ? @max : @val[d[1]];
            b.push(Math.abs(d[1] - d[0]));
        }
        # возврат
        if (a === 0) {
            return b;
        }
        a = index < 0 || index >= b.length ? 0 : index;
        return b[a];
    },
    # }}}
    /***/
  },
  cssValue: function(val, scale){
    var a;
    if (scale) {
      a = (100.0 * val / scale).toFixed(5) + "%";
    } else {
      a = Math.round(val) + "px";
    }
    return a;
  }
  /** {{{ **
      # MOUSE
      _mouseEventCoords: function(e) { # {{{
          var a, b, c;
          ##
          # определим относительную позицию указателя
          # вычисляем scroll
          a = {x: e.pageX, y: e.pageY};
          b = @element.parents!
          for (c = 0; c < b.length; c++)
          {
              a.x = a.x + b.eq(c).scrollLeft!
              a.y = a.y + b.eq(c).scrollTop!
          }
          return a;
      },
      # }}}
      _mouseValue: function(coords, capture) { # {{{
          var a, b, c, d, e;
          ##
          # определяем значение шкалы в месте клика
          # в зависимости от ориентации слайдера
          a = @orientation ?
              [coords.y - @elementOffset.top,  "height", "top"] :
              [coords.x - @elementOffset.left, "width", "left"];
          # определяем ближайший ползунок
          d = @_getClosestHandle(coords);
          # определяем длину шкалы
          b = @_getScaleSize(d, true);
          # определяем смещение (относительная позиция)
          c = (a[0] - b[0]) / b[1];
          # инвертируем в случае вертикального слайдера
          @orientation && (c = 1 - c);
          # проверка выхода за границы
          c > 1 && (c = 1);
          c < 0 && (c = 0);
          # вычисляем абсолютное значение
          a = [
              @_valueMin(d),
              @_valueMax(d)
          ];
          b = a[0] + c * (a[1] - a[0]);
          # определяем текущее значение
          c = @options.toggle ?
              @val[d] : @_valueTrim(b, d);
          # определяем шаг
          e = @step ? (@max - @min) / @step : 1;
          # корректировка
          if (Math.abs(@val[d] - c) < 0.0001 &&
              Math.abs(b - c) >= 1 && # минимальный инкремент
              (capture || @options.toggle))
          {
              # значение не может остатся неизменным в случае,
              # когда указатель выбирает точку на шкале
              c = c > b ? c - e : c + e;
          }
          # проверяем выход за границы
          c > a[1] && (c = a[1]);
          c < a[0] && (c = a[0]);
          # возврат
          return c;
      },
      # }}}
      _mouseCapture: function(e) { # {{{
          var a, b;
          ##
          # проверка
          if (@options.disabled) {
              return false;
          }
          # определяем координаты
          a = @_mouseEventCoords(e);
          b = @_mouseValue(a, true);
          # инициируем событие
          return @_event("start", e, @_getClosestHandle(a), b);
      },
      # }}}
      _mouseDrag: function(e) { # {{{
          ##
          if (@options.toggle) {
              return false;
          }
          @_event("slide", e, @_handleIndex, @_mouseValue(@_mouseEventCoords(e)));
          return true;
      },
      # }}}
      _mouseStop: function(event) { # {{{
          @_event("stop", event);
      },
      # }}}
      # POSITIONING
      refreshScale: !-> # {{{
          # prepare
          d = @data
          o = @options
          # determine element size and position
          a = @element.0
          a =
              left:   a.offsetLeft
              top:    a.offsetTop
              height: a.offsetHeight
              width:  a.offsetWidth
              h:      a.clientHeight
              w:      a.clientWidth
              margin: 0
              handle: 0
          # apply scroll offset
          @element.parents!each (index, el) !->
              a.left += el.scrollLeft
              a.top  += el.scrollTop
          # determine scale and fixed axis size
          b = if o.orientation
              then [a.w a.h]
              else [a.h a.w]
          # determine margin size
          if d.margin
              # determine relative value
              c = d.margin / d.size
              # determine absolute value
              a.margin = b.0 * c
          # determine default handle size
          a.handle = if o.inner
              then b.1
              else 1.5 * b.1
          # determine border curvature
          c = if o.round
              then @cssValue b.1 / 2
              else ""
          # apply it
          @element.css "border-radius", c
          # save results
          d.scale = a
      # }}}
      refreshHandles: (fixedAxis) !-> # {{{
          # prepare
          d = @data
          o = @options
          # ..
          a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
          b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"];
          @orientation && (c = a, a = b, b = c);
          # определяем массив ползунков
          for (c = [], d = 0; d < @val.length; d++) {
              c[d] = @handles.eq(d);
          }
          # 1. позиционируем на шкале
          # {{{
          # вычисляем полный размер
          d = @handleSize;
          d.full = 0;
          c.forEach(function(node, index) {
              # подготовка
              e = d[index];
              # размер на шкале пропорционален размеру на фиксированной оси
              # внутренний размер
              e[a[0]] = e.scale * e[b[0]];
              # полный размер
              e[a[1]] = e[a[0]] + e[a[5]];
              d.full += e[a[1]];
          });
          # позиционирование
          c.forEach(function(node, index) {
              # обновляем размер
              # без анимации
              d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
              e = {}, e[a[1]] = d;
              node.css(e);
              # обновляем смещение
              # с условной анимацией
              @_refreshHandle(index, !fixedAxis);
          }, this);
          # }}}
          # 2. позиционируем на фиксированной оси
          # {{{
          if (fixedAxis) {
              c.forEach(function(node, index) {
                  # подготовка
                  # определяем смещение (центровка)
                  d = @handleSize[index];
                  e = @elementSize[b[0]];
                  e = [
                      d[b[0]],
                      e / 2.0 - d[b[1]] / 2.0,
                      e,
                      "border-radius"
                  ]
                  # проверка необходимости
                  if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
                      Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
                  {
                      # выполняем позиционирование
                      # без анимации
                      a = {};
                      a[b[1]] = @_cssValue(e[0], e[2]);
                      a[b[2]] = @_cssValue(e[1], e[2]);
                      if (d[e[3]]) {
                          a[e[3]] = d[e[3]];
                      }
                      node.css(a);
                  }
              }, this);
          }
          # }}}
          # complete
      # }}}
      refreshHandle: function(index, animate) { # {{{
          var a, b, c, d, e;
          ##
          # подготовка
          # в зависимости от ориентации слайдера
          a = @orientation ?
              ["h", "height", "top"] :
              ["w", "width", "left"];
          # определяем ползунок
          b = @handles.eq(index);
          # определяем виртуальное смещение
          c = @_getHandleOffset(index);
          @handleOffset[index][a[2]] = c;
          # определяем флаг анимации
          d = (animate && @options.animate) ?
              @options.animate : 0;
          # определяем время анимации
          if (d)
          {
              # определяем текущую позицию
              e = b.position!
              # определяем дистанцию
              if ((e = Math.abs(c - e[a[2]])) < 0.0001) {
                  # позиционирование не требуется
                  return true;
              }
              # вычисляем относительное время анимации 1..0
              e = e / (@elementSize[a[0]] - @handleSize.full);
              # вычислем абсолютное время
              # отсекаем минимальные значения
              e = d * e / 2;
              d = e <= 50 ? 0 : (e < d ? d : e);
          }
          # определяем параметр
          e = {};
          e[a[2]] = @_cssValue(c, @elementSize[a[0]]);
          # позиционируем
          if (d)
          {
              # с анимацией
              # останавливаем текущую
              b.stop(@eventNamespace, true, @_capture);
              # запуск
              a = this;
              b.animate(e, {
                  duration: d,
                  queue: @eventNamespace,
                  step: function(now, fx) {
                      # на каждом шаге анимации
                      # обновляем диапозон с текущим значением ползунка
                      a._refreshRange(a.handleOffset.map(function(val, idx) {
                          return idx === index ? b.position() : val;
                      }));
                  },
                  complete: function() {
                      # после завершения
                      a._refreshRange!
                  }
              }).dequeue(@eventNamespace);
          }
          else
          {
              # без анимации
              # останавливаем текущую анимацию
              if (@options.animate) {
                  b.stop(@eventNamespace, true, false);
              }
              # обновляем
              b.css(e);
              @_refreshRange!
          }
          return true;
      },
      # }}}
      refreshRange: function(queryPosition) { # {{{
          var a, b, c, d, e;
          ##
          # проверка
          if (!@_rangeMap) {
              return true;
          }
          # подготовка
          a = ["left", "width",  "w", "w_gap",    "h_gap", "h", "height","top"];
          @orientation && a.reverse!
          ##
          # 1. на шкале
          # определяем начальную/конечную точки
          b = @_rangeMap.slice!
          # инвертируем при необходимости
          c = [
              @orientation,
              @options.direction,
              @options.range === true
          ];
          if ((c[0] && (!c[1] || c[2])) ||    # вертикаль
              (!c[0] && (c[1] && !c[2])))     # горизонталь
          {
              b.reverse!
          }
          # диапазон
          # определяем позиции точек
          c = 0;
          d = 0;
          b = b.map(function(val, idx) {
              ##
              if (val < 0)
              {
                  # граница
                  # определим параметры связанного ползунка
                  val = idx ? b[idx - 1] : b[idx + 1];
                  val = @handleSize[val];
                  d = val[a[3]];
                  c = val[a[1]] - d;
                  d = d / 2;
                  # определим позицию
                  e = idx ? @elementSize[a[2]] : 0;
                  # добавляем зазор ползунка,
                  # в случае, если его внутренний размер меньше
                  # размера слайдера на фиксированной оси
                  if (val[a[5]] <= @elementSize[a[5]]) {
                      e += (idx ? -1 : 1) * d;
                  }
                  else
                  {
                      # ползунок больше слайдера,
                      # отступ не нужен
                      d = 0;
                  }
              }
              else
              {
                  # ползунок
                  # определим позицию
                  e = queryPosition ?
                      @handles.eq(val).position() : @handleOffset[val];
                  e = e[a[0]];
                  # корректируем
                  # небольшой отступ в зависимости от позиции ползунка
                  val = @handleSize[val];
                  e += (idx & 1) ?
                      (val[a[1]] - val[a[3]] / 2) : val[a[3]] / 2;
              }
              return e;
          }, this);
          # определяем размер
          b[1] = Math.abs(b[1] - b[0]);
          e = @elementSize[a[2]];
          if (c && b[1] < c - 2 * d)
          {
              # если диапазон меньше чем один из ползунков,
              # убираем его.. (граничные случаи)
              b[1] = 0;
          }
          else if (b[1] > e - 2 * d)
          {
              # диапазон не должен выходить за пределы шкалы
              b[0] = d;
              b[1] = e - 2 * d;
          }
          b[2] = d;
          d = {};
          d[a[0]] = @_cssValue(b[0], e);
          d[a[1]] = @_cssValue(b[1], e);
          ##
          # 2. на фиксированной оси
          # определяем наименьший внутренний размер
          a.reverse!
          e = @elementSize[a[2]];
          c = @_rangeMap.map(function(val, index) {
              # шкала || ползунок
              return (val < 0) ? e : @handleSize[val][a[2]];
          }, this);
          c[1] = Math.min(c[0], c[1], e);
          # определяем смещение (центровка)
          c[0] = c[1] < e ?  (e / 2 - c[1] / 2) : 0;
          # сохраняем
          d[a[0]] = @_cssValue(c[0], e);
          d[a[1]] = @_cssValue(c[1], e);
          ##
          # кривизна границ
          c[2] = "";
          if (@options.round) {
              if (@options.round > 1)
              {
                  # полное скругление
                  c[2] = @_cssValue(c[1] / 2);
              }
              else if (b[2] < e)
              {
                  # скругление в случае когда прямоугольный ползунок
                  # входит в зону скругления шкалы
                  # вычислим радиус
                  e = e / 2;
                  e = (e - b[2]) / e;# относительное значение
                  e = (c[1] / 2) * e;# абсолютное
                  c[2] = @_cssValue(e);
                  # дополнительный радиус,
                  # когда радиус на шкале становится меньше радиуса
                  # на фиксированной оси (NEW syntax, future support?)
                  if (b[1] / 2 < e) {
                      c[2] = c[2] + " / " + @_cssValue(b[1] / 2);
                  }
              }
          }
          d["border-radius"] = c[2];
          # позиционируем
          @_range.css(d);
          return true;
      },
      # }}}
      # UTILITY
      _getHandleOffset: function(index) { # {{{
          var a, b, c, d;
          ##
          # подготовка
          if (index === 0)
          {
              a = @min;
              b = @max;
          }
          else
          {
              a = @_valueMin(index);
              b = @_valueMax(index);
          }
          # определяем значение
          c = @val[index];
          # +margin
          # корректируем
          if ((d = @options.margin) && !(index & 1))
          {
              c = c + d;
              a = a + d;
          }
          # определяем относительное значение
          c = a === b ? 1 : (c - a) / (b - a);
          # определим размер виртуальной шкалы
          b = @_getScaleSize(index);
          # определим позицию на виртуальной шкале
          # инвертируем значение в случае вертикального слайдера
          c = c * b[1];
          @orientation && (c = b[1] - c);
          # центрируем ползунок относительно позиции
          a = @handleSize[index];
          c = c - (@orientation ? a.height : a.width) / 2;
          # возврат
          return c + b[0];
      },
      # }}}
      _getScaleSize: function(index, virtual) { # scale size and offset {{{
          var a, b, c, d, e;
          ##
          # виртуальная шкала привязана к конкретному ползунку
          # в зависимости от ориентации слайдера
          a = @orientation ?
              ["height", "top", "h"] :
              ["width", "left", "w"];
          # определим размер шкалы
          e = @elementSize[a[2]];
          if (index > 0 || virtual)
          {
              # виртуальная шкала (шкала отдельного ползунка)
              # #1
              # предыдущий элемент, начальное смещение
              c = index - 1;
              if (c < 0)
              {
                  b = @orientation ? e : 0;
              }
              else
              {
                  # соседний ползунок
                  b = @handleOffset[c][a[1]];
                  # корректируем
                  if (!@orientation) {
                      if (@options.strict) {
                          b = b + @handleSize[c][a[0]];
                      }
                      else {
                          b = b + @handleSize[c][a[0]] / 2;
                      }
                  }
                  else if (!@options.strict) {
                      b = b + @handleSize[c][a[0]] / 2;
                  }
              }
              # #2
              # определим конечное смещение
              c = index + 1;
              if (c >= @val.length) {
                  d = @orientation ? 0 : e;
              }
              else
              {
                  # соседний ползунок
                  d = @handleOffset[c][a[1]];
                  # корректируем
                  if (@orientation)
                  {
                      if (@options.strict) {
                          d = d + @handleSize[c][a[0]];
                      }
                      else {
                          d = d + @handleSize[c][a[0]] / 2;
                      }
                  }
                  else if (!@options.strict) {
                      d = d + @handleSize[c][a[0]] / 2;
                  }
              }
              # инвертируем значения для вертикального слайдера
              if (@orientation) {
                  a[3] = d, d = b, b = a[3];
              }
          }
          else
          {
              # вся шкала
              # только для первого элемента
              b = 0;
              d = e;
              if (@options.strict)
              {
                  # определяем размер остальных ползунков
                  # не учитываем их на шкале
                  for (c = 1; c < @val.length; c++) {
                      b += @handleSize[c][a[0]];
                  }
                  !@orientation && (d = d - b, b = 0);
              }
          }
          if (@options.strict)
          {
              # точный слайдер сдвигает ползунки внутрь шкалы
              a = @handleSize[index][a[0]] / 2.0;
              b = b + a;
              d = d - a;
          }
          # возврат [начало, размер шкалы, конец]
          return [b, d - b, d];
      },
      # }}}
      _getClosestHandle: function(coords) { # {{{
          var a, b, c, d;
          ##
          # определяем ближайший ползунок
          # при слайдинге, выбираем перетаскиваемый
          if (@_capture) {
              return @_handleIndex;
          }
          # возвращаем индекс единственного ползунка
          if (@val.length < 2) {
              return 0;
          }
          # подготовка
          # в зависимости от ориентации слайдера
          a = @orientation ?
              [coords.y - @elementOffset.top,  "height", "top", @elementSize.h, 0] :
              [coords.x - @elementOffset.left, "width", "left", @elementSize.w, 0];
          # для каждого ползунка
          for (b = 0; b < @val.length; b++)
          {
              # определяем его центр
              c = @handleOffset[b][a[2]] + @handleSize[b][a[1]] / 2.0;
              # определяем расстояние до центра
              if ((d = Math.abs(c - a[0])) < a[3])
              {
                  # найден ближайший ползунок
                  a[3] = d;
                  a[4] = b;
              }
              else if (Math.abs(d - a[3]) < 0.0001)
              {
                  # ползунки находятся в одной позиции,
                  # определяем положение относительно этой позиции
                  if (!@orientation && a[0] - c >= 0)
                  {
                      # выбираем ползунок справа
                      a[3] = d;
                      a[4] = b;
                  }
                  else if (@orientation && a[0] - c < 0)
                  {
                      # выбираем ползунок сверху
                      a[3] = d;
                      a[4] = b;
                  }
              }
          }
          return a[4];
      },
      # }}}
      _valueMin: function(index) { # {{{
          if (@val.length < 2 || !index) {
              return @min;
          }
          return @val[index - 1] + @options.margin;
      },
      # }}}
      _valueMax: function(index) { # {{{
          if (@val.length < 2 ||
              index === undefined ||
              index + 1 >= @val.length)
          {
              return @max;
          }
          return @val[index + 1] - @options.margin;
      },
      # }}}
  valRefine: (val, outside) -> # {{{
      # prepare
      d = @data
      o = @options
      # single value
      if typeof! val != "Array"
          # apply reversed
          val = d.max - val + d.min if d.reversed
          # apply shift
          val = val + d.shift if d.shift and outside
          # trim
          return @valTrim val
      # multiple values
      # sync length
      while val.length < d.val.length
          val.push @valRefine d.max, outside
      # fix
      if outside
          # value is from outside world
          # apply shift and reversed
          val = val + d.shift if d.shift and outside
          d.reversed and val = val.map (val) ->
              d.max - val + d.min;
      else
          # на вход
          val = val.map(function(val, index) {
              # только целые числа в ограниченном диапазоне
              val = @_valueTrim(val, index, true, true);
              # инвертируем значение
              return a ? (@max - val + @min) : val;
          }, this).sort(function(e1, e2) {
              # сортировка по возрастанию
              return e1 < e2 ? -1 : 1;
          });
          (a = @options.margin) && (val = val.map(function(val, index, arr) {
              # корректируем значение в соответствии с отступом
              # определяем диапазон
              b = jQuery.inArray(index, @_rangeMap);
              # отступ привязан к начальному ползунку диапазонa
              if (b >= 0 && !(b & 1) && (c = @_rangeMap[b + 1]) > 0 &&
                  arr[c] - a < val) # отступ нарушен
              {
                  # корректировка
                  # отталкиваемся от верхней границы
                  val = arr[c] - a;
                  if (val <= @min)
                  {
                      # на дне, поднимаем верхнюю границу
                      val = @min;
                      d = val + a;
                      arr[c] = d > @max ? @max : d;
                  }
              }
              return val;
          }, this));
      }
      return val;
      # ..
      true
  # }}}
  valTrim: (val, index, noMargin, forceStep) -> # {{{
      # returns the closest +step+margin-aligned value
      ##
      # подготовка
      forceStep = (forceStep && index !== undefined);
      # определим минимум и максимум
      a = [@min, @max, @min, @max];
      b = @val.length;
      c = 0;
      if (arguments.length > 1 && (b = @val.length) > 1)
      {
          # для нескольких ползунков,
          # границами являются соседние, но если задан флаг форсирования шага,
          # значение должно быть выравнено - упользуются границы min/max.
          if (!forceStep)
          {
              if (index > 0) {
                  a[0] = @val[index - 1];
              }
              if (index < b - 1) {
                  a[1] = @val[index + 1];
              }
          }
          # учитываем +margin
          if ((c = @options.margin) && (d = jQuery.inArray(index, @_rangeMap)) >= 0)
          {
              # в зависимости от четности/нечетности,
              # добавляем ограничение
              if (d & 1) {
                  a[2] = a[0] + c;
              }
              else {
                  a[3] = a[1] - c;
              }
          }
      }
      # проверка выхода за границы
      if (val < a[2]) {
          return a[2];
      }
      if (val > a[3]) {
          return a[3];
      }
      # корректируем значение
      if (@step)
      {
          # определим размер шага
          d = (@max - @min) / @step;
          d <= 1 && (d = 1);
          # приближаемся к значению
          for (b = @min; b + d <= val; b += d);
          b = [b, b + d];
          # определим ближайшее
          d = [Math.abs(val - b[0]), Math.abs(val - b[1])];
          if (d[0] !== d[1])
          {
              # найдено
              val = d[0] < d[1] ? b[0] : b[1];
          }
          else
          {
              # оба приближения равноудалены,
              # выбираем ближаешее к границе
              d = [b[0] - a[0], a[1] - b[1]];
              if (d[0] !== d[1])
              {
                  # найдено
                  val = d[0] < d[1] ? b[0] : b[1];
              }
              else if (forceStep)
              {
                  # по центру,
                  # определим ближайшее к текущему
                  return @val[index] <= b[0] ? b[0] : b[1];
              }
              else
              {
                  # по центру,
                  # возвращаем как есть
                  return val;
              }
          }
          # проверим выход за границы
          if (noMargin)
          {
              val > a[1] && (val = a[1]);
              val < a[0] && (val = a[0]);
          }
          else
          {
              val > a[3] && (val = a[3]);
              val < a[2] && (val = a[2]);
          }
      }
      return Math.round(val);
  },
  # }}}
  /** }}} **/
  /**** }}} */
});
false && (w3ui.sensor = {
  /* {{{
  * TODO:
  */
  options: {
    empty: true
  },
  data: {
    target: [],
    sensor: [],
    event: [],
    state: null
  },
  create: function(){
    var me, d, i$, ref$, len$, b, a;
    me = this;
    d = this.data;
    this.refresh();
    this.scan().forEach(function(node){
      return me.add(node);
    });
    for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
      b = i$;
      a = ref$[i$];
      a[0].addEventListener("scroll", d.event[b]);
      a[2].addEventListener("scroll", d.event[b]);
      this.recharge(b);
    }
    return true;
  },
  destroy: function(){
    var d, i$, ref$, len$, b, a, c;
    d = this.data;
    for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
      b = i$;
      a = ref$[i$];
      a[0].removeEventListener("scroll", d.event[b]);
      a[2].removeEventListener("scroll", d.event[b]);
      c = a.data(d['class']);
      if (!c || c === 1) {
        a.remove();
      } else {
        a.data(d['class'], c - 1);
      }
    }
    d.target.length = 0;
    d.sensor.length = 0;
    d.event.length = 0;
  },
  attach: function(){
    return true;
  },
  detach: function(){
    return true;
  },
  event: function(handler, event){
    var a;
    if (this.options.disabled || this.core.options.disabled) {
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    if (a = this[handler](event)) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }
    return a;
  }
  /*
  refresh: !-> # {{{
      # prepare
      a = @element.0
      a =
          [a.offsetLeft, a.offsetTop]
          [a.offsetWidth, a.offsetHeight]
          [a.scrollLeft, a.scrollTop]
      # fix
      a.0.map (val) ->
          if val == null then 0 else val
      # store
      @data.state = a
  # }}}
  scan: -> # {{{
      # prepare
      me = @
      d  = @data
      # collect parents
      a = @element.parents!get!
      # add self
      a.push @element
      return a if a.length == 1
      # limit parents to document's body
      if (b = a.indexOf document.body) > 0
          a = a.slice 0, b - 1
      # prepare filter
      b =
          display:  [\block \flex]
          position: [\static \relative]
      # collect children of each parent container
      # take only those which may affect
      # size and offset (declared first)
      c = @element # first stop element
      for parent in a.slice!
          for node,index in parent.children
              # cancel at stop element
              break if node == c
              # check node
              # get styles in array
              d = $ node .css b.keys! .entries!
              # it must be a realative block container
              d = d.every (node) ->
                  b[node.0] and b[node.0].includes node.1
              # store
              a.push node if d
          # set next stop
          c = parent
      # result
      a
  # }}}
  add: (node) !-> # {{{
      # prepare
      me = @
      d  = @data
      # check if already added
      return if d.target.includes node
      # search sensor
      c = $ node
      if (a = c.children "." + d.class).length == 0
          # sensor not found
          # create DOM node
          a = document.createElement "div"
          a.className = d.class
          b = "position:absolute;left:0;top:0;"
          a.style.cssText = b +
              "right:0;bottom:0;" +
              "overflow:hidden;z-index:-1;visibility:hidden;opacity:0;"
          a.innerHTML =
              "<div style='" + a.style.cssText + "'><div style='" + b + "'></div></div>" +
              "<div style='" + b + "width:200%;height:200%;'></div>"
          # store in target container
          c.append a
          # switch container position to relative
          b = \position
          c.css b, \relative if c.css b == \static
          # define sensor nodes
          a = $ a
          b = a.0
          a.add [
              # shrink
              b.children.1
              # expand
              b.children.0
              b.children.0.children.0
          ]
      # sensor found
      # increment listener count
      b = 0 if not b = a.data d.class
      a.data d.class, b + 1
      # save
      b = d.sensor.length
      d.target[b] = node
      d.sensor[b] = a
      d.event[b]  = @event.bind @, b
      true
  # }}}
  event: (index, event) -> # target scroll {{{
      # prepare
      d = @data
      s = d.state
      # event handled
      event.stopPropagation!
      event.preventDefault!
      # update state
      @refresh!
      @recharge index
      # dont call api if disabled
      return true if @options.disabled
      # check for change
      a = s.map (lst, a) ->
          lst.some (val, b) ->
              (Math.abs val - s[a][b]) > 0.00001
      # no changes, quit
      return true if a.every (val) -> val == false
      # callback
      @api.offset.apply @core, a[0] if a[0]
      @api.resize.apply @core, a[1] if a[1]
      @api.scroll.apply @core, a[2] if a[2]
      true
  # }}}
  recharge: (index) !-> # {{{
      # prepare
      return if not a = @data.sensor[index]
      # reset
      b = 10000
      a[0].scrollLeft   = b
      a[0].scrollTop    = b
      a[2].scrollLeft   = b
      a[2].scrollTop    = b
      a[3].style.width  = b + "px"
      a[3].style.height = b + "px"
  # }}}
  */,
  api: {
    offset: function(x, y){},
    resize: function(x, y){},
    scroll: function(x, y){}
  }
  /**** }}} */
});