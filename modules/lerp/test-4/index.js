// Generated by LiveScript 1.5.0
"use strict";
var slice$ = [].slice;
(function(){
  var duration, playState, CIE, nodeMap, playRed, playGreen, playAll, charts, selectColors;
  duration = 4;
  playState = -3;
  CIE = function(){
    var CIE2000_G, CIE_e, CIE_k, CIE_ek, oneThird, toRadian, toDegree, Xr, Yr, Zr, RGBtoHSL, RGBtoLUV, LUVtoRGB, RGBtoLAB, LABtoRGB, deltaE, deltaE_CMC, approxLABRange, approxLABPoint, approxLAB, checkHSL, testDeltaE;
    CIE2000_G = Math.pow(25, 7);
    CIE_e = 216 / 24389;
    CIE_k = 24389 / 27;
    CIE_ek = CIE_e * CIE_k;
    oneThird = 1 / 3;
    toRadian = Math.PI / 180;
    toDegree = 180 / Math.PI;
    Xr = 0.95047;
    Yr = 1.00000;
    Zr = 1.08883;
    RGBtoHSL = function(arg$){
      var R, G, B, max, min, dif, sum, L, S, H;
      R = arg$[0], G = arg$[1], B = arg$[2];
      R = R / 255.0;
      G = G / 255.0;
      B = B / 255.0;
      max = Math.max(R, G, B);
      min = Math.min(R, G, B);
      dif = max - min;
      sum = max + min;
      L = sum / 2;
      S = L > 0.5
        ? dif / (2 - sum)
        : dif / sum;
      if (dif < 0.000001) {
        H = S = 0;
      } else if (max - R < 0.000001) {
        if ((H = (G - B) / dif) < 0) {
          H = H + 6;
        }
      } else if (max - G < 0.000001) {
        H = (B - R) / dif + 2;
      } else if (max - B < 0.000001) {
        H = (R - G) / dif + 4;
      }
      return [H * 60, S * 100, L * 100];
    };
    RGBtoLUV = function(arg$){
      var R, G, B, X, Y, Z, a, b, c, L, U, V;
      R = arg$[0], G = arg$[1], B = arg$[2];
      if (R === G && G === B && B === 0) {
        return [0, 0, 0];
      }
      R = R / 255.0;
      G = G / 255.0;
      B = B / 255.0;
      X = R * 0.4124564 + G * 0.3575761 + B * 0.1804375;
      Y = R * 0.2126729 + G * 0.7151522 + B * 0.0721750;
      Z = R * 0.0193339 + G * 0.1191920 + B * 0.9503041;
      a = Y / Yr;
      b = X + 15 * Y + 3 * Z;
      c = Xr + 15 * Yr + 3 * Zr;
      L = a > CIE_e
        ? 116 * Math.pow(a, oneThird) - 16
        : CIE_k * a;
      U = 4 * X / b - 4 * Xr / c;
      U = 13 * L * U;
      V = 9 * Y / b - 9 * Yr / c;
      V = 13 * L * V;
      return [L, U, V];
    };
    LUVtoRGB = function(L, U, V){
      var Y, u0, v0, a, b, c, X, Z, R, G, B;
      Y = L > CIE_ek
        ? Math.pow((L + 16) / 116, 3)
        : L / CIE_k;
      u0 = 4 * Xr / (Xr + 15 * Yr + 3 * Zr);
      v0 = 9 * Yr / (Xr + 15 * Yr + 3 * Zr);
      a = oneThird * (52 * L / (U + 13 * L * u0) - 1);
      b = -5 * Y;
      c = Y * (39 * L / (V + 13 * L * v0) - 5);
      X = (c - b) / (a + oneThird);
      Z = X * a + b;
      R = 0 + X * 3.2404542 - Y * 1.5371385 - Z * 0.4985314;
      G = 0 - X * 0.9692660 + Y * 1.8760108 + Z * 0.0415560;
      B = 0 + X * 0.0556434 - Y * 0.2040259 + Z * 1.0572252;
      if (R < 0) {
        R = 0;
      }
      if (G < 0) {
        G = 0;
      }
      if (B < 0) {
        B = 0;
      }
      return [R * 255 | 0, G * 255 | 0, B * 255 | 0];
    };
    RGBtoLAB = function(arg$){
      var R, G, B, X, Y, Z;
      R = arg$[0], G = arg$[1], B = arg$[2];
      R = R / 255.0;
      G = G / 255.0;
      B = B / 255.0;
      X = R * 0.4124564 + G * 0.3575761 + B * 0.1804375;
      Y = R * 0.2126729 + G * 0.7151522 + B * 0.0721750;
      Z = R * 0.0193339 + G * 0.1191920 + B * 0.9503041;
      X = X / 0.95047;
      Y = Y / 1.00000;
      Z = Z / 1.08883;
      X = X > CIE_e
        ? Math.pow(X, oneThird)
        : (CIE_k * X + 16) / 116;
      Y = Y > CIE_e
        ? Math.pow(Y, oneThird)
        : (CIE_k * Y + 16) / 116;
      Z = Z > CIE_e
        ? Math.pow(Z, oneThird)
        : (CIE_k * Z + 16) / 116;
      return [116 * Y - 16, 500 * (X - Y), 200 * (Y - Z)];
    };
    LABtoRGB = function(L, A, B){
      var Y, Z, X, z3, x3, R, G;
      Y = (L + 16) / 116;
      Z = Y - B / 200;
      X = A / 500 + Y;
      Y = L > CIE_ek
        ? Math.pow((L + 16) / 116, 3)
        : L / CIE_k;
      z3 = Math.pow(Z, 3);
      Z = z3 > CIE_e
        ? z3
        : (116 * Z - 16) / CIE_k;
      x3 = Math.pow(X, 3);
      X = x3 > CIE_e
        ? x3
        : (116 * X - 16) / CIE_k;
      X = X * 0.95047;
      Y = Y * 1.00000;
      Z = Z * 1.08883;
      R = 0 + X * 3.2404542 - Y * 1.5371385 - Z * 0.4985314;
      G = 0 - X * 0.9692660 + Y * 1.8760108 + Z * 0.0415560;
      B = 0 + X * 0.0556434 - Y * 0.2040259 + Z * 1.0572252;
      if (R < 0) {
        R = 0;
      }
      if (G < 0) {
        G = 0;
      }
      if (B < 0) {
        B = 0;
      }
      return [R * 255 | 0, G * 255 | 0, B * 255 | 0];
    };
    deltaE = function(c1, c2){
      var L, dL, C1, C2, C, G, a1, a2, C1a, C2a, C12, Ca, dC, h1, h2, dH, H, T, sL, sC, sH, R;
      L = (c1[0] + c2[0]) / 2;
      dL = c2[0] - c1[0];
      C1 = Math.sqrt(Math.pow(c1[1], 2) + Math.pow(c1[2], 2));
      C2 = Math.sqrt(Math.pow(c2[1], 2) + Math.pow(c2[2], 2));
      C = (C1 + C2) / 2;
      G = Math.pow(C, 7);
      G = Math.sqrt(G / (G + CIE2000_G));
      G = 0.5 * (1 - G);
      a1 = c1[1] * (1 + G);
      a2 = c2[1] * (1 + G);
      C1a = Math.sqrt(Math.pow(a1, 2) + Math.pow(c1[2], 2));
      C2a = Math.sqrt(Math.pow(a2, 2) + Math.pow(c2[2], 2));
      C12 = Math.abs(C1a * C2a);
      Ca = (C1a + C2a) / 2;
      dC = C2a - C1a;
      if ((h1 = Math.atan2(c1[2], a1) * toDegree) < 0) {
        h1 = h1 + 360;
      }
      if ((h2 = Math.atan2(c2[2], a2) * toDegree) < 0) {
        h2 = h2 + 360;
      }
      if (C12 > 0.000001) {
        dH = h2 - h1;
        H = Math.abs(dH);
        if (H > 180) {
          H = (h1 + h2 + 360) / 2;
          dH = h2 > h1
            ? dH - 360
            : dH + 360;
        } else {
          H = (h1 + h2) / 2;
        }
        dH = dH * toRadian / 2;
        dH = 2 * Math.sqrt(C12) * Math.sin(dH);
      } else {
        H = h1 + h2;
        dH = 0;
      }
      h1 = (H - 30) * toRadian;
      h2 = (2 * H) * toRadian;
      T = 1 - 0.17 * Math.cos(h1) + 0.24 * Math.cos(h2);
      h1 = (3 * H + 6) * toRadian;
      h2 = (4 * H - 63) * toRadian;
      T = T + 0.32 * Math.cos(h1) - 0.20 * Math.cos(h2);
      sL = Math.pow(L - 50, 2);
      sL = 1 + 0.015 * sL / Math.sqrt(20 + sL);
      sC = 1 + 0.045 * C;
      sH = 1 + 0.015 * C * T;
      H = Math.pow((H - 275) / 25, 2);
      H = 60 * Math.exp(-H);
      if (H > 0.0001 && H < 359.9999) {
        G = Math.pow(Ca, 7);
        G = 2 * Math.sqrt(G / (G + CIE2000_G));
        R = -G * Math.sin(H * toRadian);
      } else {
        R = 0;
      }
      L = dL / sL;
      C = dC / sC;
      H = dH / sH;
      return L * L + C * C + H * H + R * C * H;
    };
    deltaE_CMC = function(LAB1, LAB2, lc){
      var dL, C1, C2, dC, dA, dB, dH, sL, sC, H, F, sH;
      lc == null && (lc = [1, 1]);
      dL = LAB1[0] - LAB2[0];
      C1 = Math.sqrt(Math.pow(LAB1[1], 2) + Math.pow(LAB1[2], 2));
      C2 = Math.sqrt(Math.pow(LAB2[1], 2) + Math.pow(LAB2[2], 2));
      dC = C1 - C2;
      dA = Math.pow(LAB1[1] - LAB2[1], 2);
      dB = Math.pow(LAB1[2] - LAB2[2], 2);
      dH = dA + dB - Math.pow(dC, 2);
      sL = LAB1[0] < 16
        ? 0.511
        : 0.040975 * LAB1[0] / (1 + 0.01765 * LAB1[0]);
      sC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
      H = Math.atan2(LAB1[2], LAB1[1]) * toDegree;
      if (H < 0) {
        H = H + 360;
      }
      if (H < 164 || H > 345) {
        H = (H + 35) * toRadian;
        H = 0.36 + 0.4 * Math.abs(Math.cos(H));
      } else {
        H = (H + 168) * toRadian;
        H = 0.56 + 0.2 * Math.abs(Math.cos(H));
      }
      F = Math.pow(C1, 4);
      F = Math.sqrt(F / (F + 1900));
      sH = sC * (F * H + 1 - F);
      sH = Math.pow(sH, 2);
      dL = dL / sL * lc[0];
      dC = dC / sC * lc[1];
      dH = dH / Math.pow(sH, 2);
      return Math.pow(dL, 2) + Math.pow(dC, 2) + dH;
    };
    approxLABRange = function(c1, c2, deep){
      var D, d1, d2, c, a, b;
      deep == null && (deep = 0);
      if ((D = deltaE(c1, c2)) < 4) {
        return null;
      }
      c1.pos = 'pos' in c1 ? c1.pos : 0;
      c2.pos = 'pos' in c2 ? c2.pos : 1;
      d1 = D * 0.5;
      d2 = D - d1;
      c = approxLABPoint(c1, c2, d1, d2);
      c.pos = c1.pos + (c2.pos - c1.pos) * 0.5;
      if (deep) {
        a = approxLABRange(c1, c, deep - 1);
        b = approxLABRange(c, c2, deep - 1);
        if (a && b) {
          a.splice(-1, 1, c);
          a = a.concat(b.slice(1));
        } else if (a) {
          a.push(c2);
        } else if (b) {
          b.unshift(c1);
          a = b;
        } else {
          a = [c1, c, c2];
        }
        c = a[a.length - 2];
      } else {
        a = [c1, c, c2];
      }
      c2.delta = [c2[0] - c[0], c2[1] - c[1], c2[2] - c[2]];
      a.distance = D;
      return a;
    };
    approxLABPoint = function(c1, c2, D1, D2){
      var x, found, temp, approx, i1, i2, i3, limit1, limit2, limit3, range1, direction1, delta1, found1, a, range2, direction2, delta2, found2, b, range3, direction3, delta3, found3, c, d1, d2, d0, shift;
      x = [c2[0] - c1[0], c2[1] - c1[1], c2[2] - c1[2]];
      found = [c1[0] + x[0] * 0.5, c1[1] + x[1] * 0.5, c1[2] + x[2] * 0.5];
      temp = found.slice();
      approx = found.slice();
      x = [[128, 100], [0, 256], [0, 256]];
      i1 = 0;
      i2 = 1;
      i3 = 2;
      limit1 = 0.01;
      limit2 = 0.01;
      limit3 = 0.01;
      range1 = [0, 1];
      direction1 = true;
      delta1 = [D1 + D2, D1, D2];
      found1 = 0;
      while ((a = range1[1] - range1[0]) > limit1) {
        temp[i1] = x[i1][0] + x[i1][1] * (range1[0] + a * 0.5) - 128;
        range2 = [0, 1];
        direction2 = true;
        delta2 = delta1.slice();
        found2 = 0;
        while ((b = range2[1] - range2[0]) > limit2) {
          temp[i2] = x[i2][0] + x[i2][1] * (range2[0] + b * 0.5) - 128;
          range3 = [0, 1];
          direction3 = true;
          delta3 = delta2.slice();
          found3 = 0;
          while ((c = range3[1] - range3[0]) > limit3) {
            temp[i3] = x[i3][0] + x[i3][1] * (range3[0] + c * 0.5) - 128;
            d1 = Math.abs(D1 - deltaE(c1, temp));
            d2 = Math.abs(D2 - deltaE(temp, c2));
            d0 = d1 + d2;
            if (d0 <= delta3[0]) {
              ++found3;
              approx[i3] = temp[i3];
              delta3[0] = d0;
              delta3[1] = d1;
              delta3[2] = d2;
              shift = c * 0.25;
            } else {
              direction3 = !direction3;
              shift = c * 0.5;
            }
            if (direction3) {
              range3[0] = range3[0] + shift;
            } else {
              range3[1] = range3[1] - shift;
            }
          }
          if (found3) {
            ++found2;
            approx[i2] = temp[i2];
            import$(delta2, delta3);
            shift = b * 0.25;
          } else {
            direction2 = !direction2;
            shift = b * 0.5;
          }
          if (direction2) {
            range2[0] = range2[0] + shift;
          } else {
            range2[1] = range2[1] - shift;
          }
        }
        if (found2 && delta2[1] < delta1[1] && delta2[2] < delta1[2]) {
          ++found1;
          approx[i1] = temp[i1];
          found = approx.slice();
          import$(delta1, delta2);
          shift = a * 0.25;
        } else {
          direction1 = !direction1;
          shift = a * 0.5;
        }
        if (direction2) {
          range1[0] = range1[0] + shift;
        } else {
          range1[1] = range1[1] - shift;
        }
      }
      found.delta = [found[0] - c1[0], found[1] - c1[1], found[2] - c1[2]];
      return found;
    };
    approxLAB = function(range, scale){
      var c1, c2, i$, ref$, len$, b, c, d, R, G, B;
      if (scale <= 0) {
        c1 = range[0];
        c2 = range[1];
      } else if (scale >= 1) {
        c1 = range[range.length - 2];
        c2 = range[range.length - 1];
      } else {
        for (i$ = 0, len$ = (ref$ = a).length; i$ < len$; ++i$) {
          b = i$;
          c = ref$[i$];
          if (scale <= c.pos) {
            c1 = range[b - 1];
            c2 = c;
            break;
          }
        }
      }
      scale = (scale - c1.pos) / (c2.pos - c1.pos);
      d = c2.delta;
      R = c1[0] + d[0] * scale;
      G = c1[1] + d[1] * scale;
      B = c1[2] + d[2] * scale;
      ref$ = LABtoRGB(R, G, B), R = ref$[0], G = ref$[1], B = ref$[2];
      return 'rgb(' + R + ',' + G + ',' + B + ')';
    };
    checkHSL = function(c1, c2){
      var HSL, a, b, c, d1, d2;
      c1 = RGBtoHSL(c1);
      c2 = RGBtoHSL(c2);
      HSL = [c1, c2];
      a = c1[0];
      b = c2[0];
      if ((a <= 180 && b <= 180) || (a > 180 && b > 180) || (a <= 270 && b <= 270 && a > 90 && b > 90)) {
        c = b - a;
      } else if ((a <= 90 && b > 270) || (a > 270 && b <= 90)) {
        if (b > a) {
          c = b - 360 - a;
        } else {
          c = b + 360 - a;
        }
      } else {
        d1 = b - a;
        d2 = b > a
          ? b - 360 - a
          : b + 360 - a;
        c = Math.abs(d1) < Math.abs(d2) ? d1 : d2;
      }
      HSL.delta = [c, c2[1] - c1[1], c2[2] - c1[2]];
      return HSL;
    };
    testDeltaE = function(){
      var s1, s2, s3, n, i$, len$, index, x1, x2, dX1, dX2;
      s1 = [[50.0000, 2.6772, -79.7751], [50.0000, 3.1571, -77.2803], [50.0000, 2.8361, -74.0200], [50.0000, -1.3802, -84.2814], [50.0000, -1.1848, -84.8006], [50.0000, -0.9009, -85.5211], [50.0000, 0.0000, 0.0000], [50.0000, -1.0000, 2.0000], [50.0000, 2.4900, -0.0010], [50.0000, 2.4900, -0.0010], [50.0000, 2.4900, -0.0010], [50.0000, 2.4900, -0.0010], [50.0000, -0.0010, 2.4900], [50.0000, -0.0010, 2.4900], [50.0000, -0.0010, 2.4900], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [50.0000, 2.5000, 0.0000], [60.2574, -34.0099, 36.2677], [63.0109, -31.0961, -5.8663], [61.2901, 3.7196, -5.3901], [35.0831, -44.1164, 3.7933], [22.7233, 20.0904, -46.6940], [36.4612, 47.8580, 18.3852], [90.8027, -2.0831, 1.4410], [90.9257, -0.5406, -0.9208], [6.7747, -0.2908, -2.4247], [2.0776, 0.0795, -1.1350]];
      s2 = [[50.0000, 0.0000, -82.7485], [50.0000, 0.0000, -82.7485], [50.0000, 0.0000, -82.7485], [50.0000, 0.0000, -82.7485], [50.0000, 0.0000, -82.7485], [50.0000, 0.0000, -82.7485], [50.0000, -1.0000, 2.0000], [50.0000, 0.0000, 0.0000], [50.0000, -2.4900, 0.0009], [50.0000, -2.4900, 0.0010], [50.0000, -2.4900, 0.0011], [50.0000, -2.4900, 0.0012], [50.0000, 0.0009, -2.4900], [50.0000, 0.0010, -2.4900], [50.0000, 0.0011, -2.4900], [50.0000, 0.0000, -2.5000], [73.0000, 25.0000, -18.0000], [61.0000, -5.0000, 29.0000], [56.0000, -27.0000, -3.0000], [58.0000, 24.0000, 15.0000], [50.0000, 3.1736, 0.5854], [50.0000, 3.2972, 0.0000], [50.0000, 1.8634, 0.5757], [50.0000, 3.2592, 0.3350], [60.4626, -34.1751, 39.4387], [62.8187, -29.7946, -4.0864], [61.4292, 2.2480, -4.9620], [35.0232, -40.0716, 1.5901], [23.0331, 14.9730, -42.5619], [36.2715, 50.5065, 21.2231], [91.1528, -1.6435, 0.0447], [88.6381, -0.8985, -0.7239], [5.8714, -0.0985, -2.2286], [0.9033, -0.0636, -0.5514]];
      s3 = [2.0425, 2.8615, 3.4412, 1.0000, 1.0000, 1.0000, 2.3669, 2.3669, 7.1792, 7.1792, 7.2195, 7.2195, 4.8045, 4.8045, 4.7461, 4.3065, 27.1492, 22.8977, 31.9030, 19.4535, 1.0000, 1.0000, 1.0000, 1.0000, 1.2644, 1.2630, 1.8731, 1.8645, 2.0373, 1.4146, 1.4441, 1.5381, 0.6377, 0.9082];
      n = 0;
      for (i$ = 0, len$ = s1.length; i$ < len$; ++i$) {
        index = i$;
        x1 = s1[i$];
        x2 = s2[index];
        dX1 = Math.sqrt(deltaE(x1, x2));
        dX2 = Math.sqrt(deltaE(x2, x1));
        if (Math.abs(dX1 - dX2) > 0.0001 || Math.abs(dX1 - s3[index]) > 0.0001) {
          n++;
          console.log('deltaE #' + (index + 1) + ': ' + dX1 + ' = ' + dX2 + ' = ' + s3[index] + ' (c1->c2, c2->c1, result)');
        }
      }
      console.log('Test complete. (' + n + ' possible problems)');
    };
    return {
      RGBtoHSL: RGBtoHSL,
      RGBtoLUV: RGBtoLUV,
      LUVtoRGB: LUVtoRGB,
      RGBtoLAB: RGBtoLAB,
      LABtoRGB: LABtoRGB,
      deltaE: deltaE,
      approxLAB: approxLAB,
      testDeltaE: testDeltaE
    };
  }();
  nodeMap = {
    ui: document.querySelectorAll('#ui')[0],
    input: document.querySelectorAll('.ctl input'),
    progress: document.querySelectorAll('.ctl .progress')[0],
    forward: document.querySelectorAll('.box .start')[0],
    backward: document.querySelectorAll('.box .end')[0],
    red: document.querySelectorAll('.current .red')[0],
    green: document.querySelectorAll('.current .green')[0],
    presetBack: document.querySelectorAll('.preset .back div'),
    presetFront: document.querySelectorAll('.preset .front .item'),
    presetColor1: document.querySelectorAll('.preset .front .item .start'),
    presetColor2: document.querySelectorAll('.preset .front .item .end'),
    graph: slice$.call(document.querySelectorAll('.graph')),
    opt: document.querySelectorAll('.rgb2option')[0]
  };
  playRed = function(){
    var parseRGBA, onUpdate, play, a1, a0;
    parseRGBA = function(){
      var expRGBA;
      expRGBA = /(\d+),\s*(\d+),\s*(\d+)(,\s*(\d*(\.\d+)?))?/;
      return function(v){
        if (!(v = v.match(expRGBA))) {
          return null;
        }
        v[1] = parseFloat(v[1]);
        v[2] = parseFloat(v[2]);
        v[3] = parseFloat(v[3]);
        v[4] = v[5] ? parseFloat(v[5]) : 1;
        return v.slice(1, 5);
      };
    }();
    onUpdate = function(forward){
      return function(){
        var scale, a, b, RGBx, c, ref$, d, i$, ref1$, len$, c1, c2, RGB1, RGB2;
        scale = 100 * this.scale;
        a = nodeMap.progress;
        b = Math.round(scale);
        if (!forward) {
          b = 100 - b;
        }
        a.innerHTML = b + '%';
        RGBx = this.tween[0].css.backgroundColor;
        if (this.scale === 0) {
          for (c in ref$ = charts) {
            d = ref$[c];
            for (i$ = 0, len$ = (ref1$ = d.data).length; i$ < len$; ++i$) {
              d = ref1$[i$];
              d.x.length = 0;
              d.y.length = 0;
            }
          }
          a = charts.distance.data[2];
          a.x.push(0);
          a.y.push(0);
        } else if (this.scale === 1) {
          d = charts.distance.data[3];
          d.x.push(0);
          d.y.push(0);
          d.x.push(100);
          c1 = CIE.RGBtoLAB(RGBx[0]);
          c2 = CIE.RGBtoLAB(RGBx[1]);
          d.y.push(CIE.deltaE(c1, c2));
          Plotly.newPlot(nodeMap.graph[0], charts.distance);
          Plotly.newPlot(nodeMap.graph[1], charts.R);
          Plotly.newPlot(nodeMap.graph[2], charts.G);
          Plotly.newPlot(nodeMap.graph[3], charts.B);
          playState = playState < 0 ? -3 : 3;
        } else {
          b = charts.R.data[0].x;
          b = b.length ? b[b.length - 1] : 0;
          if (scale - b > 0.99) {
            RGB1 = parseRGBA(nodeMap.red._redsock.cStyle.backgroundColor);
            RGB2 = parseRGBA(nodeMap.green._style.backgroundColor);
            a = RGB1;
            b = RGB2;
            d = charts.R.data;
            d[0].y.push(a[0]);
            d[1].y.push(b[0]);
            d[0].x.push(scale);
            d[1].x.push(scale);
            d = charts.G.data;
            d[0].y.push(a[1]);
            d[1].y.push(b[1]);
            d[0].x.push(scale);
            d[1].x.push(scale);
            d = charts.B.data;
            d[0].y.push(a[2]);
            d[1].y.push(b[2]);
            d[0].x.push(scale);
            d[1].x.push(scale);
            a = CIE.RGBtoLAB(RGB1);
            b = CIE.RGBtoLAB(RGB2);
            c = CIE.RGBtoLAB(RGBx[0]);
            d = CIE.RGBtoLAB(RGBx[1]);
            a = CIE.deltaE(a, c);
            b = CIE.deltaE(b, c);
            c = CIE.deltaE(c, d);
            c = c * this.scale;
            d = charts.distance.data;
            d[0].y.push(a);
            d[1].y.push(b);
            d[2].y.push(c);
            d[0].x.push(scale);
            d[1].x.push(scale);
            d[2].x.push(scale);
          }
        }
      };
    };
    play = function(){
      switch (playState) {
      case -2:
        return a0.pause();
      case -1:
        return a0.play();
      case 1:
        return a1.play();
      case 2:
        return a1.pause();
      }
    };
    a1 = {
      target: [nodeMap.red, nodeMap.forward, nodeMap.backward],
      duration: duration,
      className: '+tested',
      onUpdate: onUpdate(true)
    };
    a0 = {
      target: [nodeMap.red, nodeMap.forward, nodeMap.backward],
      duration: duration,
      className: '-tested',
      onUpdate: onUpdate(false)
    };
    a0 = redsock(a0);
    a1 = redsock(a1);
    return play;
  }();
  playGreen = function(){
    var onUpdate, play, a1, a0, node;
    onUpdate = function(){};
    play = function(oldState){
      switch (playState) {
      case -2:
        a0.pause();
        break;
      case -1:
        if (oldState === -2) {
          a0.play();
        } else {
          a0.invalidate().play(0);
        }
        break;
      case 1:
        if (oldState === 2) {
          a1.play();
        } else {
          a1.invalidate().play(0);
        }
        break;
      case 2:
        a1.pause();
      }
    };
    a1 = {
      className: '+=tested',
      ease: Power0.easeIn,
      onUpdate: onUpdate,
      paused: true
    };
    a0 = {
      className: '-=tested',
      ease: Power0.easeIn,
      onUpdate: onUpdate,
      paused: true
    };
    node = nodeMap.green;
    a0 = new TweenLite(node, duration, a0);
    a1 = new TweenLite(node, duration, a1);
    if (!node._style) {
      node._style = window.getComputedStyle(node);
    }
    return play;
  }();
  playAll = function(){
    var a;
    a = playState;
    switch (playState) {
    case -3:
      playState = 1;
      break;
    case -2:
      playState = -1;
      break;
    case -1:
      playState = -2;
      break;
    case 1:
      playState = 2;
      break;
    case 2:
      playState = 1;
      break;
    case 3:
      playState = -1;
    }
    playRed();
    playGreen(a);
  };
  charts = {
    R: {
      data: [
        {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'red'
          }
        }, {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'green'
          }
        }
      ]
    },
    G: {
      data: [
        {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'red'
          }
        }, {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'green'
          }
        }
      ]
    },
    B: {
      data: [
        {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'red'
          }
        }, {
          x: [],
          y: [],
          type: 'lines',
          showlegend: false,
          line: {
            color: 'green'
          }
        }
      ]
    },
    distance: {
      xaxis: {
        range: [0, 100]
      },
      yaxis: {
        range: [0, 0]
      },
      data: [
        {
          x: [],
          y: [],
          mode: 'lines',
          type: 'scatter',
          name: 'redsock',
          line: {
            color: 'red'
          }
        }, {
          x: [],
          y: [],
          mode: 'lines',
          type: 'scatter',
          name: 'greensock',
          line: {
            color: 'green'
          }
        }, {
          x: [],
          y: [],
          mode: 'lines',
          type: 'scatter',
          name: 'ideal(?)',
          line: {
            color: 'gray',
            width: 0.5
          }
        }, {
          x: [],
          y: [],
          mode: 'markers',
          type: 'scatter',
          name: 'start/end',
          showlegend: false,
          marker: {
            color: 'gray',
            width: 6
          }
        }
      ]
    }
  };
  selectColors = function(index){
    var n1, n2, c1, c2, exp;
    n1 = nodeMap.presetColor1[index];
    n2 = nodeMap.presetColor2[index];
    c1 = n1.style.getPropertyValue('--start-color');
    c2 = n2.style.getPropertyValue('--end-color');
    nodeMap.ui.style.setProperty('--start-color', c1);
    nodeMap.ui.style.setProperty('--end-color', c2);
    exp = /(\d+),\s*(\d+)%,\s(\d+)%(,\s*([0-9.]+))?/;
    c1 = c1.match(exp);
    c1[4] = c1[5] === undefined
      ? 1
      : c1[5];
    c2 = c2.match(exp);
    c2[4] = c2[5] === undefined
      ? 1
      : c2[5];
    c1 = c1.slice(1, 5);
    c2 = c2.slice(1, 5);
    nodeMap.input[0].value = c1[0] + ', ' + c1[1] + '%, ' + c1[2] + '%, ' + c1[3];
    nodeMap.input[1].value = c2[0] + ', ' + c2[1] + '%, ' + c2[2] + '%, ' + c2[3];
    nodeMap.red.innerHTML = '';
    nodeMap.green.innerHTML = '';
  };
  (function(){
    var i$, ref$, len$, a, b;
    nodeMap.forward.addEventListener('click', playAll);
    nodeMap.backward.addEventListener('click', playAll);
    for (i$ = 0, len$ = (ref$ = nodeMap.presetBack).length; i$ < len$; ++i$) {
      a = ref$[i$];
      a.addEventListener('click', fn$);
    }
    selectColors(0);
    for (i$ = 0, len$ = (ref$ = nodeMap.presetFront).length; i$ < len$; ++i$) {
      b = i$;
      a = ref$[i$];
      a.addEventListener('click', selectColors.bind(this, b));
    }
    nodeMap.opt.addEventListener('click', function(){
      redsock.enableRGB2 = nodeMap.opt.checked;
    });
    function fn$(){
      nodeMap.ui.style.setProperty('--back-color', this.className);
    }
  })();
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}