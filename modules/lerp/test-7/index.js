// Generated by LiveScript 1.5.0
"use strict";
var slice$ = [].slice;
(function(){
  var queue, state, nodeMap, setup, init, start, checkFinished, finish, reset;
  queue = null;
  state = {
    engine: '',
    count: 0,
    stagger: 0,
    time: 4,
    distance: 0,
    started: 0
  };
  nodeMap = {
    engine: document.querySelectorAll('.ctl .engine')[0],
    boxCount: document.querySelectorAll('.ctl .boxes')[0],
    stagger: document.querySelectorAll('.ctl .stagger')[0],
    box: document.querySelectorAll('.renderBox')[0],
    projectile: [],
    greensock: document.querySelectorAll('.ctl .opts .greensock')[0],
    redsock: document.querySelectorAll('.ctl .opts .redsock')[0],
    opts: {
      greensock: slice$.call(document.querySelectorAll('.ctl .opts .greensock .opt')),
      redsock: document.querySelectorAll('.ctl .opts .redsock .opt')[0]
    },
    bInit: document.querySelectorAll('.ctl .btn.n1')[0],
    bRun: document.querySelectorAll('.ctl .btn.n2')[0],
    bReset: document.querySelectorAll('.ctl .btn.n3')[0]
  };
  setup = function(){
    var a, i$, b, c, o;
    if (state.started) {
      return;
    }
    a = nodeMap.engine.selectedIndex;
    a = nodeMap.engine.options[a].value;
    if (a !== state.engine) {
      if (nodeMap.opts[state.engine]) {
        nodeMap[state.engine].classList.remove('active');
      }
      state.engine = a;
      if (nodeMap.opts[a]) {
        nodeMap[a].classList.add('active');
      }
    }
    a = nodeMap.boxCount.selectedIndex;
    a = parseInt(nodeMap.boxCount.options[a].value);
    if (a !== state.count) {
      state.count = a;
      nodeMap.box.innerHTML = '';
      nodeMap.projectile.length = 0;
      for (i$ = 1; i$ <= a; ++i$) {
        b = i$;
        c = document.createElement('div');
        c.setAttribute('class', 'projectile n' + (b - 1));
        nodeMap.box.appendChild(c);
        nodeMap.projectile.push(c);
      }
      nodeMap.projectile.reverse();
    }
    a = nodeMap.stagger.selectedIndex;
    a = parseFloat(nodeMap.stagger.options[a].value);
    if (a !== state.stagger) {
      state.stagger = a;
    }
    if (o = nodeMap.opts[state.engine]) {
      switch (state.engine) {
      case 'greensock':
        a = o[1].selectedIndex;
        a = parseInt(o[1].options[a].value);
        b = o[2].selectedIndex;
        b = parseInt(o[2].options[b].value);
        if (o[0].checked) {
          TweenLite.lagSmoothing(a, b);
        } else {
          TweenLite.lagSmoothing(0);
        }
        break;
      case 'redsock':
        a = o.selectedIndex;
        a = parseInt(o.options[a].value);
        redsock.minFPS = a;
        redsock.cleanup();
      }
    }
    nodeMap.bInit.classList.remove('active');
    nodeMap.bInit.innerHTML = 'Construct';
    nodeMap.bRun.classList.remove('active', 'ready');
    nodeMap.bRun.innerHTML = 'Run';
    nodeMap.bReset.classList.remove('ready');
    nodeMap.box.classList.remove('ready');
    nodeMap.projectile.map(function(node){
      node.style.transform = null;
      return node.style.top = null;
    });
    queue = null;
  };
  init = function(){
    var a, time, x;
    nodeMap.projectile.map(function(node){
      node.style.transform = 'translateY(0px)';
      return node.style.top = '0px';
    });
    a = nodeMap.box.clientWidth / (nodeMap.projectile[0].clientWidth + 2);
    a = 1 + (state.count / a | 0);
    a = a * (nodeMap.projectile[0].clientHeight + 2);
    state.distance = nodeMap.box.clientHeight - a;
    time = window.performance.now();
    x = null;
    /* INIT */
    switch (state.engine) {
    case 'velocity':
      x = nodeMap.projectile.map(function(node, index){
        return $(node).velocity({
          top: 0
        }, {
          duration: 0
        });
      });
      break;
    case 'jquery':
    case 'transit':
      x = nodeMap.projectile.map(function(node, index){
        return $(node);
      });
      break;
    case 'popmotion':
      x = nodeMap.projectile.map(function(node, index){
        var o, a;
        o = popmotion.styler(node);
        a = popmotion.tween({
          from: 0,
          to: state.distance,
          duration: 1000 * state.time,
          ease: popmotion.easing.linear
        });
        return a.pipe(function(v){
          o.set({
            top: v + 'px'
          });
        });
      });
      break;
    case 'greensock':
      x = nodeMap.projectile.map(function(node, index){
        return new TweenLite(node, state.time, {
          top: state.distance,
          overwrite: true,
          delay: (index + 1) * state.stagger,
          ease: Linear.easeNone,
          paused: true
        });
      });
      break;
    case 'anime':
      x = nodeMap.projectile.map(function(node, index){
        return anime({
          targets: node,
          top: state.distance,
          duration: 1000 * state.time,
          delay: 1000 * (index + 1) * state.stagger,
          easing: 'linear',
          autoplay: false
        });
      });
      break;
    case 'redsock':
      x = nodeMap.projectile.map(function(node, index){
        return redsock({
          queue: [
            {
              duration: (index + 1) * state.stagger
            }, {
              duration: state.time,
              target: node,
              css: {
                top: state.distance
              }
            }
          ]
        });
      });
    }
    /**/
    if (!x) {
      console.log('failed to initialize "' + state.engine + '" engine');
      return;
    }
    time = Math.abs(window.performance.now() - time).toFixed(1);
    a = (state.stagger * state.count + state.time).toFixed(1);
    nodeMap.bRun.innerHTML = 'Run for ' + a + ' sec';
    nodeMap.bInit.classList.add('active');
    nodeMap.bInit.innerHTML = 'Constructed in ' + time + ' ms';
    nodeMap.bRun.classList.add('ready');
    nodeMap.box.classList.add('ready');
    queue = x;
  };
  start = function(){
    var a;
    if (!queue || state.started) {
      return;
    }
    nodeMap.bRun.classList.add('active');
    nodeMap.bRun.innerHTML = 'Running...';
    state.started = window.performance.now();
    /* RUN */
    switch (state.engine) {
    case 'popmotion':
      /**
      queue.forEach (tween) !-> tween.start!
      /**/
      popmotion.stagger(queue, state.stagger).start();
      break;
    case 'jquery':
      if (state.stagger) {
        queue.forEach(function(node, index){
          var a;
          a = 1000 * (index + 1) * state.stagger;
          node.delay(a).animate({
            top: state.distance
          }, {
            duration: 1000 * state.time,
            easing: 'linear'
          });
        });
      } else {
        queue.forEach(function(node, index){
          node.animate({
            top: state.distance
          }, {
            duration: 1000 * state.time,
            easing: 'linear'
          });
        });
      }
      break;
    case 'velocity':
      queue.forEach(function(node, index){
        node.velocity({
          top: state.distance
        }, {
          delay: 1000 * (index + 1) * state.stagger,
          duration: 1000 * state.time,
          easing: 'linear'
        });
      });
      break;
    case 'transit':
      queue.forEach(function(node, index){
        node.transition({
          top: state.distance,
          delay: 1000 * (index + 1) * state.stagger
        }, 1000 * state.time, 'linear');
      });
      break;
    case 'anime':
    case 'greensock':
    case 'redsock':
      queue.forEach(function(tween){
        tween.play();
      });
    }
    /***/
    nodeMap.bReset.classList.add('ready');
    nodeMap.bReset.innerHTML = 'Lag';
    switch (state.engine) {
    case 'greensock':
      queue[queue.length - 1].eventCallback('onComplete', finish);
      break;
    case 'redsock':
      queue[queue.length - 1].onComplete = finish;
      break;
    default:
      a = 1000 * state.stagger * state.count + 1000 * state.time + 1000;
      window.setTimeout(checkFinished, a);
    }
  };
  checkFinished = function(){
    var a;
    a = state.count - 1;
    a = parseInt(nodeMap.projectile[a].style.top);
    if (a < state.distance) {
      window.setTimeout(checkFinished, state.time);
      return;
    }
    finish();
  };
  finish = function(){
    var a;
    a = window.performance.now() - state.started;
    a = (a / 1000).toFixed(2);
    nodeMap.bRun.innerHTML = 'Finished in ' + a + ' sec';
    nodeMap.bReset.innerHTML = 'Reset';
    state.started = 0;
    queue = null;
  };
  reset = function(){
    var a;
    if (queue) {
      a = window.performance.now();
      while (window.performance.now() - a < 1000 * state.time / 2) {
        true;
      }
    } else {
      state.started = 0;
      setup();
    }
  };
  nodeMap.engine.addEventListener('change', setup);
  nodeMap.boxCount.addEventListener('change', setup);
  nodeMap.stagger.addEventListener('change', setup);
  nodeMap.opts.greensock[0].addEventListener('change', setup);
  nodeMap.opts.greensock[1].addEventListener('change', setup);
  nodeMap.opts.greensock[2].addEventListener('change', setup);
  nodeMap.opts.redsock.addEventListener('change', setup);
  window.addEventListener('resize', setup);
  nodeMap.bInit.addEventListener('click', init);
  nodeMap.bRun.addEventListener('click', start);
  nodeMap.bReset.addEventListener('click', reset);
  setup();
})();