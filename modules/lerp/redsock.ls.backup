redsock = do ->
	"use strict"
	/* TODO {{{
	*
	* v8 optimizations
	* sequence problem
	* reverting
	* callbacks
	* delay option
	* dynamic tween (FLS tech)
	* conditional tween (onStart + reposition)
	* null tweens
	* FLIP tech: simulate DOM node position/size changes with transforms
	* standard eases: bounce, elastic, spring
	* mutation/resize observer?
	* custom eases: step, bezier, zoom
	*
	* }}} */
	TICKER = do -> # {{{
		# {{{
		# factory
		BuildId    = 0
		BuildQueue = []
		BuildCount = 0
		BuildIndex = 0
		BuildMin   = 100
		DeadlineUnlimited = {timeRemaining: -> 100}
		# interpolator
		Id          = 0
		LerpHeap    = new WeakSet!
		LerpQueue   = []
		TempQueue   = []
		LerpCount   = 0
		SyncQueue   = []
		SyncCount   = 0
		Timestamp   = 0
		MinStep     = 1000 / 60
		MaxStep     = 1000
		Step        = 0
		# temporary
		i = j = k = 0
		# }}}
		factory = (deadline) !-> # {{{
			if BuildCount != 0
				# do lazy construction
				while BuildIndex < BuildCount
					# construct chunk
					if (i := BuildIndex + BuildMin) < BuildCount
						while BuildIndex < i
							ANIMATION.construct.call BuildQueue[BuildIndex]
							#BuildQueue[BuildIndex].construct!
							++BuildIndex
					else
						while BuildIndex < BuildCount
							ANIMATION.construct.call BuildQueue[BuildIndex]
							#BuildQueue[BuildIndex].construct!
							++BuildIndex
					# check deadline
					if deadline.timeRemaining! == 0
						BuildId := window.requestIdleCallback factory
						return
				# synchronize all
				while --BuildIndex >= 0
					if BuildQueue[BuildIndex].constructed
						CSS.syncFirst BuildQueue[BuildIndex].target
				# cleanup
				BuildQueue.length = 0
				BuildId := BuildCount := BuildIndex := 0
		# }}}
		interpolator = (timestamp) !-> # {{{
			if LerpCount != 0
				# interpolate
				# First {{{
				# synchronize
				if SyncCount != 0
					# estimate final state
					i := -1
					while ++i < SyncCount
						CSS.syncLast SyncQueue[i]
					# determine final state
					i := -1
					while ++i < SyncCount
						CSS.syncSteady SyncQueue[i].target
					# complete
					SyncCount := 0
				# interpolate active master-animations
				i := -1
				j := -1
				while ++i < LerpCount
					if LerpQueue[i].move Step
						# collect animations that require
						# one more, last synchronization
						TempQueue[++j] = LerpQueue[i]
				# }}}
				# Last {{{
				# synchronize
				if SyncCount != 0
					# estimate final state
					i := -1
					while ++i < SyncCount
						CSS.syncLast SyncQueue[i]
					# determine final state
					i := -1
					while ++i < SyncCount
						CSS.syncSteady SyncQueue[i].target
					# update master-animations at current position
					i := -1
					while ++i <= j
						TempQueue[i].update!
					# cleanup
					SyncCount := 0
				# }}}
				# Steady {{{
				# render frame and filter active
				i := -1
				j := -1
				while ++i < LerpCount
					if (k := LerpQueue[i]).render!
						LerpQueue[++j] = k
					else
						LerpHeap.delete k
				# complete
				LerpCount := j + 1
				# determine next step size
				if (Step := timestamp - Timestamp) < MinStep
					# throttle
					Step := MinStep
				else if Step > MaxStep
					# choke
					Step := MaxStep
				# }}}
				# continue
				Timestamp := timestamp
				Id := window.requestAnimationFrame interpolator
			else
				# cleanup
				# {{{
				i := -1
				j := LerpQueue.length
				k := SyncQueue.length
				j := if j > k
					then j
					else k
				while ++i < j
					LerpQueue[i] = 0
					SyncQueue[i] = 0
					TempQueue[i] = 0
				# }}}
				# terminate
				Id := Step := 0
		# }}}
		return
			factory: (animation) !-> # {{{
				# clone animation and add it to the queue
				BuildQueue[BuildCount] = animation
				++BuildCount
				# start worker
				if BuildId == 0
					BuildId := window.requestIdleCallback factory
			# }}}
			complete: !-> # {{{
				# abort callback request
				window.cancelIdleCallback BuildId if BuildId != 0
				# produce all
				factory DeadlineUnlimited
			# }}}
			start: (animation) -> # {{{
				# check
				if LerpHeap.has animation
					return false
				# complete any deffered constructions
				if BuildId != 0
					# do it
					window.cancelIdleCallback BuildId
					factory DeadlineUnlimited
					# report this behaviour
					console.log 'redsock:ticker: forced construction'
				# initialize master-animation
				if not animation.started and not animation.init!
					return false
				# add to the queue
				LerpHeap.add animation
				LerpQueue[LerpCount] = animation
				++LerpCount
				# deffer interpolation
				if Id == 0
					Timestamp := window.performance.now!
					Id := window.requestAnimationFrame interpolator
				# done
				return true
			# }}}
			init: (animation) !-> # {{{
				# add animation to the sync sequence
				SyncQueue[SyncCount] = animation
				++SyncCount
			# }}}
			minFPS: # {{{
				configurable: false
				get: ->
					return if MaxStep < 1000
						then 1000 / MaxStep
						else 0
				set: (v) !->
					# check
					if (v = parseInt v) < 0 or v > 60
						console.error 'redsock:ticker:minFPS: incorrect'
						return
					# set
					MaxStep := if v == 0
						then 1000
						else 1000 / v
			# }}}
			FPS: # {{{
				configurable: false
				get: ->
					return if Id == 0
						then 0
						else 1000 / Step
			# }}}
	# }}}
	EASE = do -> # {{{
		# prepare
		variant = ['in' 'out' 'in-out' 'out-in']
		pool = {linear: null}
		# define ease generator
		gen =
			power: # {{{
				variant: true
				pool: [1.5, 2, 3, 4, 5, 6]
				default: 2
				func: (variant, n) ->
					switch variant
					| 'in' =>
						f = (x) ->
							return x**n
					| 'out' =>
						f = (x) ->
							return 1 - (1 - x)**n
					| 'in-out' =>
						f = (x) ->
							return if x < 0.5
								then ((2 * x)**n) / 2
								else 1 - ((2 * (1 - x))**n) / 2
					| 'out-in' =>
						c1 = Math.pow 0.5, 1/n
						c2 = 2 * c1
						c3 = 0.5 / Math.pow 0.5, n
						f = (x) ->
							return if x < 0.5
								then 0.5 - (c1 - c2*x)**n
								else 0.5 + c3*(x - 0.5)**n
					return f
			# }}}
			exp: # {{{
				variant: true
				func: (variant) ->
					switch variant
					| 'in' =>
						f = (p) ->
							return Math.exp 10*(p - 1)
					| 'out' =>
						f = (p) ->
							return 1 - Math.exp (-10 * p)
					| 'in-out' =>
						f = (p) ->
							p = p * 2
							return if p < 1
								then 0.5 * (Math.exp 10*(p - 1))
								else 1 - 0.5 * (Math.exp 10*(1 - p))
					| 'out-in' =>
						c1 = 1 / (2 - 2 / Math.exp 10)
						f = (p) ->
							if p < 0.5
								return c1 - c1*(Math.exp (-10 * 2*p))
							return 1 - c1 + c1*(Math.exp 10*(2*p - 2))
					return f
			# }}}
			circ: # {{{
				variant: true
				func: (variant) ->
					switch variant
					| 'in' =>
						f = (p) ->
							return 1 - Math.sqrt (1 - p * p)
					| 'out' =>
						f = (p) ->
							p = p - 1
							return Math.sqrt (1 - p * p)
					| 'in-out' =>
						f = (p) ->
							if (p = p * 2) < 1
								return 0.5 * (1 - Math.sqrt (1 - p * p))
							p = p - 2
							return 0.5 * (1 + Math.sqrt (1 - p * p))
					| 'out-in' =>
						f = (p) ->
							if p < 0.5
								p = p - 0.5
								return Math.sqrt (0.25 - p * p)
							p = 2*p - 1
							return 1 - 0.5*Math.sqrt (1 - p * p)
					return f
			# }}}
			sine: # {{{
				variant: true
				func: (variant) ->
					c1 = Math.PI / 2
					c2 = Math.PI * 2
					switch variant
					| 'in' =>
						f = (p) ->
							return 1 - Math.cos (p * c1)
					| 'out' =>
						f = (p) ->
							return Math.sin (p * c1)
					| 'in-out' =>
						f = (p) ->
							return 0.5 - 0.5 * Math.cos (p * Math.PI)
					| 'out-in' =>
						f = (p) ->
							if p < 0.5
								return 0.5 * Math.sin (p * Math.PI)
							return 1 - 0.5 * Math.sin (p * Math.PI)
					return f
			# }}}
			back: # {{{
				variant: true
				pool: [1, 1.4, 1.7, 2]
				default: 1
				func: (variant, amp) ->
					switch variant
					| 'in' =>
						c1 = amp + 1
						f = (x) ->
							return x * x * (c1*x - amp)
					| 'out' =>
						c1 = amp + 1
						f = (x) ->
							x = x - 1
							return x * x * (c1*x + amp) + 1
					| 'in-out' =>
						c1 = amp * 1.525
						c2 = c1 + 1
						f = (x) ->
							if (x = x * 2) < 1
								return 0.5 * x * x * (c2*x - c1)
							x = x - 2
							return 0.5 * x * x * (c2*x + c1) + 1
					| 'out-in' =>
						c1 = amp * 1.525 / 2
						c2 = c1 + 0.5
						f = (x) ->
							if x <= 0.5
								x = 2*x - 1
								return x * x * (c2*x + c1) + 0.5
							x = 2*x - 1
							return x * x * (c2*x - c1) + 0.5
					return f
			# }}}
			bounce: # {{{
				variant: true
				pool: [0, 0, 0]
				default: 1
				/***
					_wrap("Bounce",
						_create("BounceOut", function(p) {
							if (p < 1 / 2.75) {
								return 7.5625 * p * p;
							} else if (p < 2 / 2.75) {
								return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
							} else if (p < 2.5 / 2.75) {
								return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
							}
							return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
						}),
						_create("BounceIn", function(p) {
						}),
						_create("BounceInOut", function(p) {
							var invert = (p < 0.5);
							if (invert) {
								p = 1 - (p * 2);
							} else {
								p = (p * 2) - 1;
							}
							if (p < 1 / 2.75) {
								p = 7.5625 * p * p;
							} else if (p < 2 / 2.75) {
								p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
							} else if (p < 2.5 / 2.75) {
								p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
							} else {
								p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
							}
							return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
						})
					);
				/***/
				func: (variant, x) ->
					switch variant
					| 'in' =>
						f = (p) ->
							p = 1 - p
							if p < 1 / 2.75
								return 1 - (7.5625 * p * p)
							else if p < 2 / 2.75
								p = p - 1.5 / 2.75
								return 1 - (7.5625 * p * p + 0.75)
							else if p < 2.5 / 2.75
								p = p - 2.25 / 2.75
								return 1 - (7.5625 * p * p + 0.9375)
							p = p - 2.625 / 2.75
							return 1 - (7.5625 * p * p + 0.984375)
					| 'out' =>
						f = (p) ->
							return p
					| 'in-out' =>
						f = (p) ->
							return p
					| 'out-in' =>
						f = (p) ->
							return p
					return f
			# }}}
			elastic: # {{{
				variant: true
				pool: []
				###
				/***
					_createElastic = function(n, f, def) {
						var C = _class("easing." + n, function(amplitude, period) {
								this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
								this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
								this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
								this._p2 = _2PI / this._p2; //precalculate to optimize
							}, true),
							p = C.prototype = new Ease();
						p.constructor = C;
						p.getRatio = f;
						p.config = function(amplitude, period) {
							return new C(amplitude, period);
						};
						return C;
					};
					_wrap("Elastic",
						_createElastic("ElasticOut", function(p) {
							return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
						}, 0.3),
						_createElastic("ElasticIn", function(p) {
							return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
						}, 0.3),
						_createElastic("ElasticInOut", function(p) {
							return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
						}, 0.45)
					);
				/***/
				func: (variant, x) ->
					switch variant
					| 'in' =>
						f = (p) ->
							return p
					| 'out' =>
						f = (p) ->
							return p
					| 'in-out' =>
						f = (p) ->
							return p
					| 'out-in' =>
						f = (p) ->
							return p
					return f
			# }}}
			step: # {{{
				func: (p) -> p
			# }}}
		# create input parsers
		parser = (name) -> # {{{
			# check
			if not name
				return null
			# extract from pool
			if pool.hasOwnProperty name
				return pool[name]
			# check ease type
			# CUSTOM: user specified parameters
			if (name.indexOf ' ') > 0
				return customParser name
			# FIXED: parameters are extracted from the pool
			# parse variant
			if (n = name.split '-').length < 2
				console.log 'redsock: ease variant is not specified "'+name+'"'
				return null
			# get it
			v = (n.slice 1).join '-'
			# check
			if (variant.indexOf v) < 0
				console.log 'redsock: incorrect ease variant "'+v+'"'
				return null
			# parse
			if not (n = n.0.match /([a-z]+)(\d*)/)
				console.log 'redsock: incorrect ease name "'+name+'"'
				return null
			# get name and parameter index
			[n, i] = n.slice 1
			# extract generator
			if not n or not (f = gen[n])
				if n != 'linear'
					console.log 'redsock: incorrect ease name "'+name+'"'
				return null
			# construct
			if f.pool
				# check index
				if not i or not (i = parseInt i)
					# check default index available
					if 'default' in f
						console.log 'redsock: ease parameter required "'+name+'"'
						return null
					# set default
					i = f.default
				else if i > f.pool.length
					console.log 'redsock: wrong ease parameter "'+name+'"'
					return null
				# call generator
				f = f.func v, f.pool[i - 1]
			else
				# call generator
				f = f.func v
			# store name
			f.keyword = name
			# store function
			pool[name] = f
			# done
			return f
		# }}}
		customParser = (name) -> # TODO {{{
			# extract name and parameter
			[n, i] = name.split ' '
			if not (n = name.split '-').length
				true
			# extract geneartor
			if not n or not gen.hasOwnProperty n
				console.log 'redsock: incorrect ease name "'+name+'"'
				return null
			# parse parameters
			if not (i = i.split ',')
				console.log 'redsock: incorrect ease parameters "'+name+'"'
				return null
			# call generator
			if not (f = gen[n] i)
				return null
			# store function
			f.keyword = name
			pool[name] = f
			return f
		# }}}
		parser.pool = pool
		parser.gen = gen
		# done
		return parser
	# }}}
	CSS = do -> # {{{
		# data
		# {{{
		# DOM node (target) storage
		TargetStorage = new WeakMap!
		# stylesheet rules and their properties
		Rules = []
		RuleProps = new WeakMap!
		# property name maps for convertion
		camelCaseMap = {}
		hyphenCaseMap = {}
		# }}}
		TYPE = # computed style types {{{
			Pixel: # {{{
				filter: (v) ->
					# convert numbers
					if typeof v == 'number'
						return v+'px'
					# empty string is not allowed,
					# loose check - value must finish with px
					if v == '' or (v.slice -2) != 'px'
						return null
					# done
					return v
				init: !->
					# parse computed style values
					@0 = parseFloat @first
					@1 = parseFloat @last
					# determine delta
					@delta = @1 - @0
				lerp: (scale) !->
					# determine current
					@current = (@0 + @delta * scale) + 'px'
			# }}}
			Color: do -> # {{{
				# {{{
				expRGBA = /(\d+),\s*(\d+),\s*(\d+)(,\s*(\d*(\.\d+)?))?/
				parseRGBA = (v) ->
					# use regular expression for extraction
					if not (v = v.match expRGBA)
						return null
					# cast RGB to integers
					v.1 = parseInt v.1
					v.2 = parseInt v.2
					v.3 = parseInt v.3
					# cast Alpha
					v.4 = if v.5
						then parseFloat v.5
						else 1
					# done
					# truncate result
					return v.slice 1, 5
				# }}}
				return
					filter: (v) -> # {{{
						return v
					# }}}
					initRGB2: !-> # {{{
						# parse values
						@0 = c1 = parseRGBA @first
						@1 = c2 = parseRGBA @last
						# correct for RGB^2 blending
						c1.0 = c1.0 ** 2
						c1.1 = c1.1 ** 2
						c1.2 = c1.2 ** 2
						# determine delta
						@delta = d = [
							c2.0 ** 2 - c1.0
							c2.1 ** 2 - c1.1
							c2.2 ** 2 - c1.2
							c2.3 - c1.3
						]
						# determine interpolation modes
						@mode = 0
						if @alpha = ((Math.abs d.3) > 0.001)
							# check for visible/invisible transition
							if c2.3 < 0.001
								# visible => invisible
								@mode = 2
							else if c1.3 < 0.001
								# invisible => visible
								@mode = 3
					# }}}
					initRGB: !-> # {{{
						# parse values
						@0 = c1 = parseRGBA @first
						@1 = c2 = parseRGBA @last
						# determine delta
						@delta = d = [
							c2.0 - c1.0
							c2.1 - c1.1
							c2.2 - c1.2
							c2.3 - c1.3
						]
						# determine interpolation modes
						@mode = 0
						if @alpha = ((Math.abs d.3) > 0.001)
							# check for visible/invisible transition
							if c2.3 < 0.001
								# visible => invisible
								@mode = 2
							else if c1.3 < 0.001
								# invisible => visible
								@mode = 3
					# }}}
					lerp: (scale) !-> # {{{
						# prepare
						a = @0
						b = @delta
						# determine color
						switch @mode
						| 0 =>
							# RGB^2 color
							R = (Math.sqrt (a.0 + b.0 * scale)) .|. 0
							G = (Math.sqrt (a.1 + b.1 * scale)) .|. 0
							B = (Math.sqrt (a.2 + b.2 * scale)) .|. 0
						| 1 =>
							# RGB color
							R = (a.0 + b.0 * scale) .|. 0
							G = (a.1 + b.1 * scale) .|. 0
							B = (a.2 + b.2 * scale) .|. 0
						| 2 =>
							# visible => invisible
							R = a.0
							G = a.1
							B = a.2
						| 3 =>
							# invisible => visible
							c = @1
							R = c.0
							G = c.1
							B = c.2
						# determine alpha
						a = if @alpha
							then (a.3 + b.3 * scale).toFixed 2
							else a.3
						# set
						@current = 'rgba('+R+','+G+','+B+','+a+')'
					# }}}
			# }}}
			Integer: # {{{
				filter: (v) ->
					return if not (v = parseInt v)
						then 0
						else v
				init: (list, p1, p2) !->
					for a in list
						# get values
						if not (v1 = parseInt p1[a])
							v1 = 0
						if not (v2 = parseInt p2[a])
							v2 = 0
						# initialize interpolator
						a.delta = v2 - v1
						a.current = v1
				lerp: (el, scale) !->
					for a in @
						# determine current
						c = (a.0 + a.delta * scale) .|. 0
						# allow only reasonable change
						if c != a.current
							# update
							a.current = c
				set: (el, index) !->
					for a in @
						# select value
						if (c = a[index]) != a.current
							# update
							a.current = c
			# }}}
			Float: # {{{
				filter: (v) ->
					return if not (v = parseFloat v)
						then 0
						else v
				init: (list, p1, p2) ->
					for a in list
						# get values
						if not (v1 = parseFloat p1[a.name])
							v1 = 0
						if not (v2 = parseFloat p2[a.name])
							v2 = 0
						# initialize interpolator
						a.delta = v2 - v1
						a.current = v1
				lerp: (el, scale) !->
					for a in @
						# determine current
						c = a.0 + a.delta * scale
						# allow only reasonable change
						if (Math.abs (c - a.current)) > 0.0001
							# update
							a.current = c
				set: (el, index) !->
					for a in @
						# select value
						if (c = a[index]) != a.current
							# update
							a.current = c
			# }}}
		# }}}
		PROP = # animatable, longhand properties {{{
			top: TYPE.Pixel
			bottom: TYPE.Pixel
			left: TYPE.Pixel
			right: TYPE.Pixel
			maxHeight: TYPE.Pixel
			height: TYPE.Pixel
			minHeight: TYPE.Pixel
			maxWidth: TYPE.Pixel
			width: TYPE.Pixel
			minWidth: TYPE.Pixel
			zIndex: TYPE.Integer
			perspective: TYPE.Pixel
			#perspectiveOrigin: TYPE._pixel2
			##
			flexGrow: TYPE.Float
			flexShrink: TYPE.Float
			flexBasis: TYPE.Pixel
			order: TYPE.Integer
			##
			gridRowGap: TYPE.Pixel
			gridColumnGap: TYPE.Pixel
			##
			columnCount: TYPE.Integer
			columnGap: TYPE.Pixel
			columnRuleWidth: TYPE.Pixel
			columnRuleColor: TYPE.Color
			##
			backgroundColor: TYPE.Color
			##
			borderTopWidth: TYPE.Pixel
			borderBottomWidth: TYPE.Pixel
			borderLeftWidth: TYPE.Pixel
			borderRightWidth: TYPE.Pixel
			borderTopColor: TYPE.Color
			borderBottomColor: TYPE.Color
			borderLeftColor: TYPE.Color
			borderRightColor: TYPE.Color
			borderTopLeftRadius: TYPE.Pixel
			borderTopRightRadius: TYPE.Pixel
			borderBottomLeftRadius: TYPE.Pixel
			borderBottomRightRadius: TYPE.Pixel
			##
			marginTop: TYPE.Pixel
			marginBottom: TYPE.Pixel
			marginLeft: TYPE.Pixel
			marginRight: TYPE.Pixel
			##
			paddingTop: TYPE.Pixel
			paddingBottom: TYPE.Pixel
			paddingLeft: TYPE.Pixel
			paddingRight: TYPE.Pixel
			##
			outlineColor: TYPE.Color
			outlineOffset: TYPE.Pixel
			outlineWidth: TYPE.Pixel
			##
			color: TYPE.Color
			opacity: TYPE.Float
			fontSize: TYPE.Pixel
			fontSizeAdjust: TYPE.Float
			fontWeight: TYPE.Integer
			lineHeight: TYPE.Pixel
			wordSpacing: TYPE.Pixel
			caretColor: TYPE.Color
			textIndent: TYPE.Pixel
			### TODO
			###
			#offsetPosition: 0
			#offsetDistance: 0
			#offsetAnchor: 0
			#offsetRotate: 0
			#offsetPath: 0
			###
			#objectPosition: 3
			#shapeImageThreshold: 0
			#shapeMargin: 1
			#shapeOutside: ?
			#translate: ?
			#zoom: ?
			#letterSpacing: ?
			#verticalAlign: ?
			#backgroundPositionX: ?
			#backgroundPositionY: ?
			#backgroundSize: ?
			#maskBorderSource: 7
			#maskBorderSlice: ?
			#fontVariationSettings: ?
			#textShadow: ?
			#boxShadow: ?
			#backdropFilter: ?
			#filter: ?
			#transform: ?
			#transformOrigin: ?
			#rotate: ?
			#scale: ?
			###
		# }}}
		do !-> # {{{
			# initialize types
			for a,b of TYPE
				b.name = a
			# initialize style rules
			for a in document.styleSheets
				# get rules (supress access errors)
				try
					b = a.cssRules
				catch
					b = null
				# store
				if b
					for c in b when c.type == 1
						Rules[*] = c
			# initialize case maps
			# prepare
			camelCaseExp = /([a-zA-Z])(?=[A-Z])/g
			# iterate animatable
			for a of PROP
				# store
				hyphenCaseMap[a] = b = (a.replace camelCaseExp, '$1-').toLowerCase!
				camelCaseMap[b] = a
				# add hyphenated name to all properties
				if not PROP.hasOwnProperty b
					PROP[b] = PROP[a]
		# }}}
		# helpers
		getNodeRules = (node) -> # {{{
			# collect current rules applied to the node
			d = []
			for a in Rules when node.matches a.selectorText
				# store rule
				d[*] = a
				# cache rule properties
				if not RuleProps.has a
					RuleProps.set a, getRuleProps a
			# done
			return d
		# }}}
		getRuleProps = (rule) -> # {{{
			# create list
			a = []
			a.has = {}
			# iterate CSSStyleDeclaration
			for c from 0 til (b = rule.style).length
				# get property name (longhand, hyphen-cased)
				c = b[c]
				# check animatable
				if PROP.hasOwnProperty c
					# set name and filtered value
					a[*] = c
					a[c] = PROP[c].filter b[camelCaseMap[c]]
					# set key to speedup checks
					a.has[c] = true
			# done
			return a
		# }}}
		resolveClassName = (className, op) !-> # {{{
			# get name string
			a = className.name + ' '
			# add
			if op.0
				for b in op.0 when not className.includes b
					a = a + b
			# remove
			if op.1
				for b in op.1 when className.includes b
					a = a.replace b, ''
			# switch (add or remove)
			if op.2
				for b in op.2
					if className.includes b
						a = a.replace b, ''
					else
						a = a + b
			# check the result
			if (a = a.trimEnd!) == className.name
				return false
			# convert string to a sorted array
			a = a.split ' ' .sort!
			a.name = a.join ' '
			a.first = className
			# done
			return a
		# }}}
		resolveClassProps = (rule1, rule2) -> # {{{
			# substract rules to determine
			# unique rules which differ between state change
			c = []
			for a in rule1 when not rule2.pool.has a
				c[*] = a
			for a in rule2 when not rule1.pool.has a
				c[*] = a
			# WARNING: impaling style of CSS control
			# sort rules by specificity (more weighted last)
			# for performance reason and for simplicity
			# the calculation considers *only* the number of classes,
			# which is enough for animations but may broke when
			# poorly declared inside the CSS shema.
			if c.length > 1
				# WARNING: no more optimization here
				# as the proper structure impaled, there will be very
				# little chance that there will be more that 2-3 elements
				c.sort (a, b) ->
					a = a.selectorText.split '.' .length
					b = b.selectorText.split '.' .length
					return if a == b
						then 0
						else if a < b
							then -1
							else 1
			# convert rules to property lists
			for a,b in c
				c[b] = RuleProps.get a
			# merge ordered property lists
			d = []
			d.has = {}
			for a in c
				for b in a
					# set name and key
					if not d.hasOwnProperty b
						d[*] = b
						d.has[b] = true
					# set value
					d[b] = a[b]
			# done
			return d
		# }}}
		createTweenStorage = do -> # {{{
			add = (a) -> # {{{
				# create new property tween
				@[*] = a
				@[a] = b = []
				# initialize it
				c = PROP[a]
				b.lerp = c.lerp
				b.init = c.init
				b.inline = false
				b.first = null
				b.current = null
				b.last = null
				b.active = 0
				# done
				return b
			# }}}
			return ->
				# create new storage
				a = []
				a.add = add
				# done
				return a
		# }}}
		TweenStorage = do -> # {{{
			add = (a) -> # {{{
				# create new property tween
				@[*] = a
				@[a] = b = []
				# initialize it
				c = PROP[a]
				b.lerp = c.lerp
				b.init = c.init
				b.inline = false
				b.first = null
				b.current = null
				b.last = null
				b.active = 0
				# done
				return b
			# }}}
			return ->
				# create new storage
				a = []
				a.add = add
				# done
				return a
		# }}}
		removeInactive = (store, tween) !-> # {{{
			# find first inactive animation index
			for a,b in (list = store.active) when not a.started
				break
			# remove it from the list
			list.splice b, 1
			# iterate previous animations
			for a from 0 til b
				# enable properties
				c = (list[a].tween.get target).enabled
				for d in tween.css
					c[d] = true
			# re-apply blocks to restore consistency
			# starting from the second animation,
			# as the first doesn't block anything
			for a from 1 til list.length
				# get animation property tweens
				tween = (list[a].tween.get target).css
				# iterate previous animations
				for b from 0 til a
					# disable properties
					c = (list[b].tween.get target).enabled
					for d in tween
						c[d] = false
		# }}}
		return
			# option handlers
			enableRGB2: # {{{
				configurable: false
				get: ->
					# determine
					return if (a = TYPE.Color).init == a.initRGB2
						then true
						else false
				set: (v) !->
					# check
					a = TYPE.Color
					a.init = if v
						then a.initRGB2
						else a.initRGB
			# }}}
			filter: (o) -> # {{{
				# prepare
				a = []
				a.dynamic = {}
				# iterate
				for b,c of o when PROP.hasOwnProperty b
					# convert property name to hyphen-case
					b = hyphenCaseMap[b]
					# add to the list
					a[*] = b
					# set value
					if (d = PROP[b].filter c) == null
						a.dynamic[b] = true
						a[b] = c
					else
						a.dynamic[b] = false
						a[b] = d
				# done
				return a
			# }}}
			set: (animation, options) -> # {{{
				# set target
				target = animation.target = options.target
				# create animation tween storage
				animation.tween = new WeakMap!
				# add owned targets to shared CSS storage
				for t from 0 til target.count
					# get target node
					t = target[t]
					# set animation tween for this target
					animation.tween.set t, {
						# animated class
						className: false
						# animated property list (class & inline)
						css: []
						# enabled/disabled properties
						# for overwrite management
						enabled: {}
						# initial, inline properties
						# for reverting
						first: {}
						# final, inline properties that
						# will stay upon completion (css option link)
						last: null
					}
					# get target storage
					if not (s = TargetStorage.get t)
						# create new
						s =
							# computed style
							style: window.getComputedStyle t
							# target animations
							animation: []
							# active animation stack
							active: []
							# target property tweens (all animations)
							tween: createTweenStorage!
							# current class
							className: null
							# matched stylesheet rules,
							# className => rules
							classRules: {}
							# differential property lists for className combinations,
							# class1 => class2 => css
							classProps: {}
							# target state flags
							# is prepared for animation (first done)
							ready: false
							# is ready to start and will start (last done)
							steady: false
							# interpolation state:
							# == 0, no updates
							# == 1, class attribute changed
							# == 2, style property changed
							# == 3, both
							state: 0
						# store
						TargetStorage.set t, s
					else
						# clear flag
						s.ready = false
					# add animation to the storage
					s.animation[*] = animation
				# done
				return true
			# }}}
			# FLS tech
			syncFirst: (target) -> # {{{
				# READ first style
				# iterate dirty targets
				for t in target when not (s = TargetStorage.get t).ready
					# prepare
					# checkout current class
					if not (c = s.className)
						c = s.className = t.className.split ' ' .sort!
						c.name = c.join ' '
					# checkout current rules
					if not (d = s.classRules[c.name])
						d = s.classRules[c.name] = getNodeRules t
					# update tweens
					# get target property tween
					x = s.tween
					# add new tweens from current rules
					for a in d
						for a in (RuleProps.get a) when not x.hasOwnProperty a
							x.add a
					# iterate all bound animations
					for a in s.animation
						# prepare
						o = a.options
						b = a.tween.get t
						c = b.css
						# set class
						if o.hasOwnProperty 'className'
							b.className = resolveClassName s.className, o.className
						# set inline
						if o.hasOwnProperty 'css'
							for a in (b.last = o.css)
								# add inline animation tween
								c[*] = a if not c.hasOwnProperty a
								c[a] = false
								# add target tween
								if not x.hasOwnProperty a
									x.add a
						# set count constant
						c.lastCount = c.length
					# update target state
					for a in x
						# get target property tween
						b = x[a]
						# read inline style
						if (c = t.style.getPropertyValue a) != ''
							b.inline = c
						# read absolute value from computed style
						b.first = s.style.getPropertyValue a
					# done
					s.ready = true
				# done
				return true
			# }}}
			syncLast: (animation) !-> # {{{
				# WRITE last style
				# get options
				o = animation.options
				# iterate owned targets
				for t from 0 til animation.target.count
					# prepare
					t = animation.target[t]
					s = TargetStorage.get t
					x = animation.tween.get t
					sTween = s.tween
					xTween = x.css
					# update animation class tween
					# {{{
					if b = x.className
						# check overwrite
						if (a = s.className) != b.first
							x.className = resolveClassName a, o.className
						# get names
						a = a.name            # old
						b = x.className.name  # new
						# set class
						t.setAttribute 'class', b
						# swap tweens (save the original)
						s.className = x.className
						x.className = c
						# get property list
						if not (c = (d = s.classProps)[a][b])
							# determine the list
							# WARNING: forced reflow probability
							# get current rules
							if not (c = s.classRules).hasOwnProperty b
								c[b] = getNodeRules t
							# get rule properties
							c = resolveClassProps c[a], c[b]
							# update cache
							d[a] = {}
							d[b] = {}
							d[a][b] = c
							d[b][a] = c
						# initialize animation tween
						# truncate list to inline-only
						xTween.length = xTween.lastCount
						# collect class properties
						for a in c when xTween[a] != false
							# check target tween
							if sTween.hasOwnProperty a
								# set final value
								(d = sTween[a]).last = c[a]
							else
								# create new
								# add to the storage
								d = sTween.add a
								# set final value
								d.last = c[a]
								# determine initial value
								# check inline-style
								if (b = t.style.getPropertyValue a) == ''
									# not inline, unknown
									d.first = null
									# let's look at previous class rules
									# and try to escape this situation
									for b in s.classRules[x.className.name]
										# check if the property defined in this rule
										# and overwrite previous value (following specificity order)
										if (b = RuleProps.get b).hasOwnProperty a
											d.first = b[a]
								else
									# inline, should be filtered
									d.inline = b
									d.first = PROP[a].filter b
							# check initial value
							if d.first == null
								# value is unknown due to absence of this property
								# in the previous class declaration
								console.warn 'redsock:css:'+a+': is not rendered, initial value is unknown'
							else
								# add property
								xTween[*] = a
								xTween[a] = true
					# }}}
					# update target tween
					# {{{
					b = x.last
					for a in xTween
						# check property type
						if xTween[a]
							# class
							# property value is set earlier
							# check value type
							if sTween[a].last == null
								# remove inline-style that blocks
								# property from revealing the value
								t.style.setProperty a, null
						else
							# inline
							# check value type
							if b.dynamic[a]
								# relative
								# deffer setup
								sTween[a].last = null
								# set inline-style property
								# to read it later as absolute
								t.style.setProperty a, b[a]
							else
								# absolute
								# set final value
								sTween[a].last = b[a]
					# }}}
					# overwrite management
					# {{{
					# enable this animation
					# to control target properties
					c = x.enabled
					for a in xTween
						# get target property tween
						b = sTween[a]
						# enable
						c[a] = true
						# increase count of active animations
						# working on the same property
						if ++b.active > 1
							# backup initial value (for reverting)
							x.first[a] = b.first
					# disable other animations
					# from controlling properties
					if (a = s.active.length) != 0
						# this animation is not added yet,
						# so, iterate all
						for b in s.active
							c = (b.tween.get t).enabled
							for d in xTween
								c[d] = false
					# add to the active
					s.active[a] = animation
					# }}}
					# done
					s.steady = true
			# }}}
			syncSteady: (target) !-> # {{{
				# READ last style (if necessary)
				# iterate steady targets
				for t in target when (s = TargetStorage.get t).steady
					# get computed style
					z = s.style
					# iterate target property tweens
					for a in (x = s.tween) when (b = x[a]).active != 0
						# check final value
						if b.last == null
							# WARNING: forced reflow
							# read style
							b.last = z.getPropertyValue a
						# initialize tween
						b.init!
					# clear flag
					s.steady = false
			# }}}
			lerpFirst: (tween, target) !-> # {{{
				# iterate owned targets
				for t from 0 til target.count
					# prepare
					s = TargetStorage.get target[t]
					x = tween.get target[t]
					sTween = s.tween
					xTween = x.css
					# revert class
					if (c = x.className)
						# swap current and initial
						x.className = s.className
						s.className = c
						# add state
						s.state = s.state .|. 1
					# revert properties
					if xTween.length != 0
						# set initial inline-style
						for a in xTween
							# get target property tween
							b = sTween[a]
							# deactivate it
							if --b.active == 0
								# exclusive mode
								# deffer deactivation
								b.active = -1
								# set to initial inline style (relative/absolute) or erase
								b.current = if b.inline
									then b.inline
									else null
							else
								# shared mode
								# set to initial inline style (absolute) or erase
								b.current = x.first[a]
						# add state
						s.state = s.state .|. 2
					# remove self
					removeInactive s, x
			# }}}
			lerpLast: (tween, target) !-> # {{{
				# iterate owned targets
				for t from 0 til target.count
					# prepare
					x = tween.get target[t]
					s = TargetStorage.get target[t]
					sTween = s.tween
					xTween = x.css
					# set final state
					if xTween.length != 0
						# iterate target property tweens
						for a in xTween
							# get tween
							b = sTween[a]
							# deactivate it
							if --b.active == 0
								# exclusive mode
								# deffer deactivation
								b.active = -1
								# set
								if xTween[a]
									# class property
									# erase
									b.current = null
								else
									# inline
									# set value
									b.current = if x.last.hasOwnProperty a
										then x.last[a]  # relative
										else b.last     # absolute
							else
								# shared mode
								# set absolute value (update both)
								b.current = b.first = b.last
						# add state
						s.state = s.state .|. 2
					# remove self
					removeInactive s, x
			# }}}
			lerpSteady: (tween, target, scale) !-> # {{{
				# iterate owned targets
				for t from 0 til target.count
					# prepare
					s = TargetStorage.get target[t]
					x = tween.get target[t]
					e = x.enabled
					z = s.tween
					# interpolate
					for a in x.css when e[a]
						z[a].lerp scale
					# set state
					s.state = s.state .|. 2
			# }}}
			render: -> # {{{
				# iterate target nodes
				for t in @target when (s = TargetStorage.get t).state != 0
					# set class attribute
					if s.state .&. 1
						t.setAttribute 'class', s.className.name
					# set inline-style properties
					if s.state .&. 2
						# prepare
						x = s.tween
						z = t.style
						# iterate active
						for a in x when (b = x[a]).active != 0
							# set current
							z.setProperty a, b.current
							# check edge case (first/last) and
							# correct active counter value
							if b.active == -1
								b.active = 0
					# done
					s.state = 0
				# done
				return @active
			# }}}
	# }}}
	ANIMATION = do -> # {{{
		/* {{{
		proto =
			# {{{
			constructed: false
			options: null       # filtered options
			parent: false       # backlink to the parent animation
			queue: false        # children/nested animations
			duration: 0         # in milliseconds
			delay: 0            # in milliseconds
			label: ''           # named position
			position: 0         # absolute position
			scale: 0            # normalized position [0..1]
			ease: null          # position change factor
			target: null        # DOM nodes
			tween: false        # individual tween
			started: false      # initialized and steady
			active: false       # running..
			callback:
				onStart: false
				onUpdate: false
				onComplete: false
			render: CSS.render
			# }}}
			construct: (parent, index) !-> # {{{
				# construct self
				# {{{
				# check animation type
				if parent
					# SLAVE
					# set parent
					@parent = parent
				else
					# MASTER
					# bind public methods
					for a in apiList
						@[a] = api[a] @
				# parse options
				# set cloneable
				options = @options
				o = []
				if options.hasOwnProperty 'clone'
					# check
					if not (c = options.clone) or not (c = c.redsock)
						console.error 'redsock:option:clone: incorrect value'
						return @
					# store
					c = c.options
					b = optionList.clonable
					for a in c when b.hasOwnProperty a
						o[a] = c[a]
				# set filterable
				# and create ordered list of all specified options
				for a in optionList.filterable
					if options.hasOwnProperty a
						# prepare
						b = options[a]
						c = option[a].filter
						d = typeof! b
						# apply filter
						if c.hasOwnProperty d
							if (c = c[d]) and (b = c b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						else
							if not c.hasOwnProperty 'other'
								console.error 'redsock:option:'+a+': incorrect type %o', options
								return @
							if (b = c.other b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						# store (overwrites cloneable)
						o[*] = a
						o[a] = b
					else if o.hasOwnProperty a
						# add cloneable to the list
						o[*] = a
				# iterate ordered list
				for a in o when (c = option[a].set)
					# set directly
					if c == true
						@[a] = o[a]
					# call setter
					else if not c @, o
						console.error 'redsock:option:'+a+': failed to set %o', o[a]
						return @
				# inherit options
				if parent
					for a in optionList.inheritable when not o.hasOwnProperty a
						option[a].inherit @, parent, index
				# }}}
				# construct queue
				if (q = @queue)
					# set children positions {{{
					d = 0
					for a,i in q
						# check
						if not a.hasOwnProperty 'position'
							# no position specified
							# APPEND
							a.position = d
							d = d + a.duration
							continue
						# parse
						switch typeof (b = a.position)
						| 'string' =>
							switch b.0
							# STAGGERED offset (%)
							# from the start of previous animation
							| '^' =>
								if i != 0
									# determine the shift
									# from the previous animation
									c = q[i - 1]
									b = parseInt (b.substring 1)
									b = parseInt (c.position + c.duration * b / 100)
								else
									# no shift
									# for the first animation
									b = 0
							# RELATIVE offset (seconds)
							# from current position
							| '+', '-' =>
								b = d + (parseInt 1000 * b)
							# LABELED offset
							# from the start of previous animation
							| otherwise =>
								# TODO
								true
						| 'number' =>
							if (b = parseInt 1000 * b) < 0
								# RELATIVE
								# negative offset from current position
								if (b = d + b) < 0
									b = 0
							else
								# ABSOLUTE
								# positive offset from the start
								b = b
						| otherwise =>
							return @
						# set position
						a.position = b
						# increase duration
						if (b = b + a.duration) > d
							d = b
					# }}}
					# correct duration {{{
					if o.hasOwnProperty 'duration'
						# CHILDREN
						# determine relative deviation
						b = (@duration - d) / d
						# correct
						for a in q
							a.position = a.position + b * a.position
							a.duration = a.duration + b * a.duration
					else
						# SELF
						@duration = d
					# }}}
					# create iterpolation ranges {{{
					# TODO: sort range elements by position
					# prepare
					q.range = []
					# collect starting/ending points
					d = []
					for a in q
						# prepare
						b = a.position
						c = b + a.duration
						# collect unique
						if not d.hasOwnProperty '_'+b
							d[*] = b
							d['_'+b] = true
						if not d.hasOwnProperty '_'+c
							d[*] = c
							d['_'+c] = true
					# order points
					# using inline INSERTION sort
					if (c = d.length) > 2
						# start from the second position,
						# splitting the array into left and right sections
						i = 1
						while i < c
							# get first element
							# from the right section
							a = d[i]
							# determine last position of the left section
							j = i - 1
							# shift all elements of the left section
							# to the right until the insert position found
							while j >= 0 and d[j] > a
								d[j + 1] = d[j]
								--j
							# insert and advance
							d[j + 1] = a
							++i
					# create ranges
					for j from 1 til d.length
						# prepare
						i = j - 1
						# create and store
						a = []
						b = []
						c = []
						k = q.range[i] = [a, b, c]
						# initialize
						# set range metrics
						k.beg = i = d[i]
						k.end = j = d[j]
						# add animation objects
						for k in q
							if k.position >= j
								# not started
								a[*] = k
							else if k.position + k.duration <= i
								# finished
								b[*] = k
							else
								# interpolated
								c[*] = k
					# }}}
					# add child targets {{{
					# get target storage
					if not (c = @target)
						# create new
						@target = c = []
						c.count = 0
						c.pool  = new WeakSet!
					# add unique elements from children
					for a in @queue when a.target
						for b in a.target when not c.pool.has b
							c[*] = b
							c.pool.add b
					# }}}
				# done
				@constructed = true
				@options = o
				return @
			# }}}
			construct1: (options, parent, index) !-> # {{{
				# construct self
				# {{{
				# check animation type
				if parent
					# SLAVE
					# set parent
					@parent = parent
				else
					# MASTER
					# bind public methods
					for a in apiList
						@[a] = api[a] @
				# create options
				@options = o = []
				# set cloneable
				if options.hasOwnProperty 'clone'
					# check
					if not (c = options.clone) or not (c = c.redsock)
						console.error 'redsock:option:clone: incorrect value'
						return @
					# store
					c = c.options
					b = optionList.clonable
					for a in c when b.hasOwnProperty a
						o[a] = c[a]
				# set filterable
				# and create ordered list of all specified options
				for a in optionList.filterable
					if options.hasOwnProperty a
						# prepare
						b = options[a]
						c = option[a].filter
						d = typeof! b
						# apply filter
						if c.hasOwnProperty d
							if (c = c[d]) and (b = c b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						else
							if not c.hasOwnProperty 'other'
								console.error 'redsock:option:'+a+': incorrect type %o', options
								return @
							if (b = c.other b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						# store (overwrites cloneable)
						o[*] = a
						o[a] = b
					else if o.hasOwnProperty a
						# add cloneable to the list
						o[*] = a
				# iterate ordered list
				for a in o when (c = option[a].set)
					# set directly
					if c == true
						@[a] = o[a]
					# call setter
					else if not c @, o
						console.error 'redsock:option:'+a+': failed to set %o', o[a]
						return @
				# inherit options
				if parent
					for a in optionList.inheritable when not o.hasOwnProperty a
						option[a].inherit @, parent, index
				# }}}
				# construct queue
				if (q = @queue)
					# set children positions {{{
					d = 0
					for a,i in q
						# check
						if not a.hasOwnProperty 'position'
							# no position specified
							# APPEND
							a.position = d
							d = d + a.duration
							continue
						# parse
						switch typeof (b = a.position)
						| 'string' =>
							switch b.0
							# STAGGERED offset (%)
							# from the start of previous animation
							| '^' =>
								if i != 0
									# determine the shift
									# from the previous animation
									c = q[i - 1]
									b = parseInt (b.substring 1)
									b = parseInt (c.position + c.duration * b / 100)
								else
									# no shift
									# for the first animation
									b = 0
							# RELATIVE offset (seconds)
							# from current position
							| '+', '-' =>
								b = d + (parseInt 1000 * b)
							# LABELED offset
							# from the start of previous animation
							| otherwise =>
								# TODO
								true
						| 'number' =>
							if (b = parseInt 1000 * b) < 0
								# RELATIVE
								# negative offset from current position
								if (b = d + b) < 0
									b = 0
							else
								# ABSOLUTE
								# positive offset from the start
								b = b
						| otherwise =>
							return @
						# set position
						a.position = b
						# increase duration
						if (b = b + a.duration) > d
							d = b
					# }}}
					# correct duration {{{
					if o.hasOwnProperty 'duration'
						# CHILDREN
						# determine relative deviation
						b = (@duration - d) / d
						# correct
						for a in q
							a.position = a.position + b * a.position
							a.duration = a.duration + b * a.duration
					else
						# SELF
						@duration = d
					# }}}
					# create iterpolation ranges {{{
					# TODO: sort range elements by position
					# prepare
					q.range = []
					# collect starting/ending points
					d = []
					for a in q
						# prepare
						b = a.position
						c = b + a.duration
						# collect unique
						if not d.hasOwnProperty '_'+b
							d[*] = b
							d['_'+b] = true
						if not d.hasOwnProperty '_'+c
							d[*] = c
							d['_'+c] = true
					# order points
					# using inline INSERTION sort
					if (c = d.length) > 2
						# start from the second position,
						# splitting the array into left and right sections
						i = 1
						while i < c
							# get first element
							# from the right section
							a = d[i]
							# determine last position of the left section
							j = i - 1
							# shift all elements of the left section
							# to the right until the insert position found
							while j >= 0 and d[j] > a
								d[j + 1] = d[j]
								--j
							# insert and advance
							d[j + 1] = a
							++i
					# create ranges
					for j from 1 til d.length
						# prepare
						i = j - 1
						# create and store
						a = []
						b = []
						c = []
						k = q.range[i] = [a, b, c]
						# initialize
						# set range metrics
						k.beg = i = d[i]
						k.end = j = d[j]
						# add animation objects
						for k in q
							if k.position >= j
								# not started
								a[*] = k
							else if k.position + k.duration <= i
								# finished
								b[*] = k
							else
								# interpolated
								c[*] = k
					# }}}
					# add child targets {{{
					# get target storage
					if not (c = @target)
						# create new
						@target = c = []
						c.count = 0
						c.pool  = new WeakSet!
					# add unique elements from children
					for a in @queue when a.target
						for b in a.target when not c.pool.has b
							c[*] = b
							c.pool.add b
					# }}}
				# done
				@constructed = true
				return @
			# }}}
			init: (noCondition) -> # {{{
				# conditional tween
				# trigger user callback
				if not noCondition and @callback.onStart and not @callback.onStart!
					return false
				# startup
				@started = true
				TICKER.sync @ if @tween
				# initialize queue at current position
				if q = @queue
					# activate all children
					for a in q
						a.active = true
					# determine master-position
					p = @duration * @scale
					# get interpolation range
					for b in q.range when p < b.end
						break
					# initialize completed
					for a in b.1
						a.scale = 1
						a.init noCondition
					# initialize interpolated
					for a in b.2
						a.scale = (p - a.position) / a.duration
						a.init noCondition
				# done
				return true
			# }}}
			update: (scale = @scale, noCallback) -> # {{{
				# prepare
				syncFlag = false
				d = @duration
				q = @queue
				p = if scale <= 0
					then 0
					else if scale < 1
						then scale * d
						else d
				# update children
				# {{{
				while q
					# get interpolation range
					for b in q.range when p < b.end
						break
					# REVERT (TODO)
					# when playhead moves backwards,
					# some animations must revert to initial state,
					# no callbacks should be triggered in this process
					#for a in b.0 when a.started
					#	a.update -1, true
					# COMPLETE
					for a in b.1 when a.scale != 1 and a.active
						if a.started
							# continual completion (synced)
							if a.update 1, noCallback
								syncFlag = true
						else
							# immediate completion (not synced)
							a.scale = 1
							if a.active = a.init noCallback
								syncFlag = true
					# INTERPOLATE
					# iterate active and determine count of interpolated
					c = 0
					for a in b.2 when a.active
						if a.started
							# update
							++c
							if a.update ((p - a.position) / a.duration), noCallback
								syncFlag = true
						else
							# initialize future update
							a.scale = (p - a.position) / a.duration
							if a.active = a.init noCallback
								syncFlag = true
								++c
					# check
					if c == 0 and p < d
						# nothing was interpolated but maybe will,
						# so do conditional jump
						p = b.end
						scale = p / d
						continue
					# done
					break
				# }}}
				# update self
				# {{{
				if @tween
					if scale < 1
						if scale < 0
							# stop and revert to initial state
							@started = false
							scale = 0
							CSS.lerpFirst @tween, @target
						else if @ease
							# interpolate with ease
							CSS.lerpSteady @tween, @target, @ease scale
						else
							# interpolate
							CSS.lerpSteady @tween, @target, scale
					else
						# stop animation and set final state
						@started = false
						scale = 1
						CSS.lerpLast @tween, @target
				else if scale < 0
					@started = false
					scale = 0
				else if scale >= 1
					@started = false
					scale = 1
				# }}}
				# set scale
				@scale = scale
				# change state of master-animation
				if not @parent
					@position = p
					@active = false if scale == 1
				# done
				return syncFlag
			# }}}
			move: (step) -> # {{{
				# convert step to the scale and apply the update
				return if (step = (@position + step) / @duration) < 1
					then @update step
					else @update 1
			# }}}
			api: -> # {{{
				return @api = new Proxy @, apiProxy
			# }}}
		/* }}} */
		proto =
			construct: !-> # {{{
				# construct self
				# {{{
				# check animation type
				if parent
					# SLAVE
					# set parent
					@parent = parent
				else
					# MASTER
					# bind public methods
					for a in apiList
						@[a] = api[a] @
				# create options
				@options = o = []
				# set cloneable
				if options.hasOwnProperty 'clone'
					# check
					if not (c = options.clone) or not (c = c.redsock)
						console.error 'redsock:option:clone: incorrect value'
						return @
					# store
					c = c.options
					b = optionList.clonable
					for a in c when b.hasOwnProperty a
						o[a] = c[a]
				# set filterable
				# and create ordered list of all specified options
				for a in optionList.filterable
					if options.hasOwnProperty a
						# prepare
						b = options[a]
						c = option[a].filter
						d = typeof! b
						# apply filter
						if c.hasOwnProperty d
							if (c = c[d]) and (b = c b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						else
							if not c.hasOwnProperty 'other'
								console.error 'redsock:option:'+a+': incorrect type %o', options
								return @
							if (b = c.other b) == null
								console.error 'redsock:option:'+a+': incorrect value %o', options
								return @
						# store (overwrites cloneable)
						o[*] = a
						o[a] = b
					else if o.hasOwnProperty a
						# add cloneable to the list
						o[*] = a
				# iterate ordered list
				for a in o when (c = option[a].set)
					# set directly
					if c == true
						@[a] = o[a]
					# call setter
					else if not c @, o
						console.error 'redsock:option:'+a+': failed to set %o', o[a]
						return @
				# inherit options
				if parent
					for a in optionList.inheritable when not o.hasOwnProperty a
						option[a].inherit @, parent, index
				# }}}
				# construct queue
				if (q = @queue)
					# set children positions {{{
					d = 0
					for a,i in q
						# check
						if not a.hasOwnProperty 'position'
							# no position specified
							# APPEND
							a.position = d
							d = d + a.duration
							continue
						# parse
						switch typeof (b = a.position)
						| 'string' =>
							switch b.0
							# STAGGERED offset (%)
							# from the start of previous animation
							| '^' =>
								if i != 0
									# determine the shift
									# from the previous animation
									c = q[i - 1]
									b = parseInt (b.substring 1)
									b = parseInt (c.position + c.duration * b / 100)
								else
									# no shift
									# for the first animation
									b = 0
							# RELATIVE offset (seconds)
							# from current position
							| '+', '-' =>
								b = d + (parseInt 1000 * b)
							# LABELED offset
							# from the start of previous animation
							| otherwise =>
								# TODO
								true
						| 'number' =>
							if (b = parseInt 1000 * b) < 0
								# RELATIVE
								# negative offset from current position
								if (b = d + b) < 0
									b = 0
							else
								# ABSOLUTE
								# positive offset from the start
								b = b
						| otherwise =>
							return @
						# set position
						a.position = b
						# increase duration
						if (b = b + a.duration) > d
							d = b
					# }}}
					# correct duration {{{
					if o.hasOwnProperty 'duration'
						# CHILDREN
						# determine relative deviation
						b = (@duration - d) / d
						# correct
						for a in q
							a.position = a.position + b * a.position
							a.duration = a.duration + b * a.duration
					else
						# SELF
						@duration = d
					# }}}
					# create iterpolation ranges {{{
					# TODO: sort range elements by position
					# prepare
					q.range = []
					# collect starting/ending points
					d = []
					for a in q
						# prepare
						b = a.position
						c = b + a.duration
						# collect unique
						if not d.hasOwnProperty '_'+b
							d[*] = b
							d['_'+b] = true
						if not d.hasOwnProperty '_'+c
							d[*] = c
							d['_'+c] = true
					# order points
					# using inline INSERTION sort
					if (c = d.length) > 2
						# start from the second position,
						# splitting the array into left and right sections
						i = 1
						while i < c
							# get first element
							# from the right section
							a = d[i]
							# determine last position of the left section
							j = i - 1
							# shift all elements of the left section
							# to the right until the insert position found
							while j >= 0 and d[j] > a
								d[j + 1] = d[j]
								--j
							# insert and advance
							d[j + 1] = a
							++i
					# create ranges
					for j from 1 til d.length
						# prepare
						i = j - 1
						# create and store
						a = []
						b = []
						c = []
						k = q.range[i] = [a, b, c]
						# initialize
						# set range metrics
						k.beg = i = d[i]
						k.end = j = d[j]
						# add animation objects
						for k in q
							if k.position >= j
								# not started
								a[*] = k
							else if k.position + k.duration <= i
								# finished
								b[*] = k
							else
								# interpolated
								c[*] = k
					# }}}
					# add child targets {{{
					# get target storage
					if not (c = @target)
						# create new
						@target = c = []
						c.count = 0
						c.pool  = new WeakSet!
					# add unique elements from children
					for a in @queue when a.target
						for b in a.target when not c.pool.has b
							c[*] = b
							c.pool.add b
					# }}}
				# done
				@constructed = true
				return @
			# }}}
			init: (noCondition) -> # {{{
				# trigger user callback
				if not noCondition and @callback.onStart and not @callback.onStart!
					# conditional stop
					return false
				# startup
				TICKER.init @ if @tween
				@started = true
				# initialize queue at current position
				if q = @queue
					# activate all children
					for a in q
						a.active = true
					# determine master-position
					p = @duration * @scale
					# get interpolation range
					for b in q.range when p < b.end
						break
					# initialize completed
					for a in b.1
						a.scale = 1
						a.sync noCondition
					# initialize interpolated
					for a in b.2
						a.scale = (p - a.position) / a.duration
						a.sync noCondition
				# done
				return true
			# }}}
			update: (scale = @scale, noCallback) -> # {{{
				# prepare
				syncFlag = false
				d = @duration
				q = @queue
				p = if scale <= 0
					then 0
					else if scale < 1
						then scale * d
						else d
				# update children
				# {{{
				while q
					# get interpolation range
					for b in q.range when p < b.end
						break
					# REVERT (TODO)
					# when playhead moves backwards,
					# some animations must revert to initial state,
					# no callbacks should be triggered in this process
					#for a in b.0 when a.started
					#	a.update -1, true
					# COMPLETE
					for a in b.1 when a.scale != 1 and a.active
						if a.started
							# continual completion (synced)
							if a.update 1, noCallback
								syncFlag = true
						else
							# immediate completion (not synced)
							a.scale = 1
							if a.active = a.init noCallback
								syncFlag = true
					# INTERPOLATE
					# iterate active and determine count of interpolated
					c = 0
					for a in b.2 when a.active
						if a.started
							# update
							++c
							if a.update ((p - a.position) / a.duration), noCallback
								syncFlag = true
						else
							# initialize future update
							a.scale = (p - a.position) / a.duration
							if a.active = a.init noCallback
								syncFlag = true
								++c
					# check
					if c == 0 and p < d
						# nothing was interpolated but maybe will,
						# so do conditional jump
						p = b.end
						scale = p / d
						continue
					# done
					break
				# }}}
				# update self
				# {{{
				if @tween
					if scale < 1
						if scale < 0
							# stop and revert to initial state
							@started = false
							scale = 0
							CSS.lerpFirst @tween, @target
						else if @ease
							# interpolate with ease
							CSS.lerpSteady @tween, @target, @ease scale
						else
							# interpolate
							CSS.lerpSteady @tween, @target, scale
					else
						# stop animation and set final state
						@started = false
						scale = 1
						CSS.lerpLast @tween, @target
				else if scale < 0
					@started = false
					scale = 0
				else if scale >= 1
					@started = false
					scale = 1
				# }}}
				# set scale
				@scale = scale
				# change state of master-animation
				if not @parent
					@position = p
					@active = false if scale == 1
				/***
				# trigger update
				x.onUpdate! if x.onUpdate
				# check complete
				if scale == 1
					# deactivate master-animation
					@active = false if not @parent
					# trigger complete
					x.onComplete! if x.onComplete
				/***/
				# done
				return syncFlag
			# }}}
			move: (step) -> # {{{
				# convert step to the scale and apply the update
				return if (step = (@position + step) / @duration) < 1
					then @update step
					else @update 1
			# }}}
			render: CSS.render
		api =
			start: (me) -> -> # {{{
				# activate
				me.active = TICKER.start me
				# done
				return me.api
			# }}}
			stop: (me) -> -> # {{{
				# deactivate
				me.active = false
				# done
				return me.api
			# }}}
			cancel: (me) -> -> # {{{
				# revert animation and stop it
				# TODO
				if me.active
					true
				# done
				return me.api
			# }}}
			complete: (me) -> (noCallback) -> # {{{
				# finish animation and stop it
				# TODO
				#TICKER.stop @ if @active
				#@update 1, !!noCallback
				#@started = false
				# done
				return me.api
			# }}}
			set: (me) -> (scale) -> # {{{
				# TODO
				# ...
				# done
				return me.api
			# }}}
		apiProxy =
			get: do -> # {{{
				apiAlias =
					play: 'start'
					pause: 'stop'
					revert: 'cancel'
					progress: 'set'
					finish: 'complete'
				return (me, k) ->
					# check custom property access
					switch k
					| 'target' =>
						# dont allow to spoil the source
						return me.target.slice!
					| 'duration' =>
						# convert to seconds
						return me.duration / 1000
					| 'scale', 'progress' =>
						# relative position 0..100%
						return 100 * me.scale
					| 'ease' =>
						# extract ease method string
						return if me.ease
							then me.ease.keyword
							else 'linear'
					| 'redsock' =>
						# self-extraction
						return me
					# check constructed (force it)
					if not me.constructed and not TICKER.complete!
						return null
					# default access (as is)
					if me.hasOwnProperty k
						return me[key]
					# alias access
					if apiAlias.hasOwnProperty k
						return me[apiAlias[k]]
					# nothing
					return null
			# }}}
			set: (me, k, v) -> # {{{
				# ...
				# done
				return true
			# }}}
		option =
			target: # {{{
				filter:
					Array: (v) ->
						# initialize
						v.count = v.length
						v.pool = new WeakSet v
						# done
						return v
					other: (v) ->
						# check DOM object
						if not v instanceof Element
							return null
						# wrap into array
						v = [v]
						# initialize
						v.count = 1
						v.pool = new WeakSet v
						# done
						return v
				set: CSS.set
			# }}}
			duration: # {{{
				filter:
					String: (v) ->
						# convert to number
						if isNaN (v = parseFloat v)
							return null
						# convert to milliseconds
						if (v = (1000 * v) .|. 0) < 1
							return null
						# done
						return v
					Number: (v) ->
						# convert to milliseconds
						if (v = (1000 * v) .|. 0) < 1
							return null
						# done
						return v
				set: true
			# }}}
			delay: # {{{
				filter:
					Number: (v) ->
						# convert to milliseconds
						if (v = (1000 * v) .|. 0) < 1
							return null
						# done
						return v
				set: (me, o) -> # TODO
					return false
			# }}}
			position: # {{{
				filter:
					Number: false
					String: false
				set: true
				inherit: (me, parent, index) !->
					# take from parent positions option
					do
						# get options
						o = parent.options
						# check option exist
						if o.hasOwnProperty 'positions'
							# check option type
							if typeof (v = o.positions) == 'string'
								# commonal
								me.position = v
							else
								# individual
								if index < v.length and v[index] != null
									me.position = v[index]
							# done
							return
						# do not traverse after the first queue
						# because this animation belongs only to it
						if parent.hasOwnProperty 'queue'
							break
						# continue
					while (parent = o.clone)
			# }}}
			label: # {{{
				filter:
					String: false
				set: true
			# }}}
			ease: # {{{
				filter:
					Boolean: false
					Function: false
					String: EASE
				set: true
				inherit: (me, parent, index) !->
					# take from parent
					if parent.options.hasOwnProperty 'ease'
						me.ease = parent.options.ease
						return
					# take from clone
					while (parent = parent.options.clone)
						if parent.options.hasOwnProperty 'ease'
							me.ease = parent.options.ease
							break
			# }}}
			className: # {{{
				filter:
					Array: false
					String: (v) ->
						# check empty
						if not v
							return null
						# convert into array
						a1 = []
						a2 = []
						a3 = []
						for a in (v.split ' ')
							# get operator
							b = a.0
							# get name and append space for future use
							a = (a.substr 1) + ' '
							# check
							switch b
							| '+' => a1[*] = a # add
							| '-' => a2[*] = a # remove
							| '!' => a3[*] = a # toggle
							| otherwise =>
								return null
						# discard empty
						a1 = null if a1.length == 0
						a2 = null if a2.length == 0
						a3 = null if a3.length == 0
						# check
						if not a1 and not a2 and not a3
							return null
						# done
						return [a1, a2, a3]
			# }}}
			css: # {{{
				filter:
					Object: CSS.filter
			# }}}
			queue: # {{{
				filter: # {{{
					Array: (v) ->
						# check empty
						if v.length == 0
							return null
						# parse
						q = []
						for a,b in v
							# check type
							if (c = typeof a) == 'function'
								# neutral callback
								a = {onUpdate: a}
							else if c != 'object'
								# unimplemented
								return null
							else if a.redsock
								# clone command
								a = {clone: a}
							# store
							q[b] = a
						# done
						return q
				# }}}
				set: (me, o) -> # {{{
					# prepare
					q = me.queue = []
					o = o.queue
					i = -1
					j = o.length
					# construct nested animations
					while ++i < j
						a = q[i] = ^^proto
						a.options = o[i]
						if not (a.construct me, i).constructed
							return false
					# done
					return true
				# }}}
			# }}}
			queue1: # {{{
				filter: # {{{
					Array: (v) ->
						# check empty
						if v.length == 0
							return null
						# parse
						q = []
						for a,b in v
							# check type
							if (c = typeof a) == 'function'
								# neutral callback
								a = {onUpdate: a}
							else if c != 'object'
								# unimplemented
								return null
							else if a.redsock
								# clone command
								a = {clone: a}
							# store
							q[b] = a
						# done
						return q
				# }}}
				set: (me, o) -> # {{{
					# prepare
					q = me.queue = []
					o = o.queue
					i = -1
					j = o.length
					# construct nested animations
					while ++i < j
						if not (q[i] = (^^proto).construct o[i], me, i).constructed
							return false
					# done
					return true
				# }}}
			# }}}
			positions: # {{{
				filter:
					Array: false
					Number: (v, o) ->
						# STAGGER value
						# check in range 0..100%
						if v < 0 or v > 100
							return null
						# convert to string
						return '^'+v
			# }}}
			onStart: # {{{
				filter:
					Function: false
				set: (me, o, name) ->
					# create context
					if not me.hasOwnProperty 'callback'
						# clone self
						# it will allow to check animation state
						# and store data using `this` keyword
						me.callback = ^^me <<< proto.callback
					# set
					me.callback[name] = o[name]
					return true
			# }}}
		option.onUpdate = option.onStart
		option.onComplete = option.onStart
		optionList = do -> # {{{
			# define
			x =
				# these are 'real' options, that have input filter
				filterable:
					'target'
					'duration'
					'delay'
					'position'
					'label'
					'ease'
					'className'
					'css'
					'queue'
					'positions'
					'onStart'
					'onUpdate'
					'onComplete'
				# these can cloned
				clonable:
					'target'
					'duration'
					'label'
					'ease'
					'className'
					'css'
					'queue'
					'positions'
					'onStart'
					'onUpdate'
					'onComplete'
				# these are taken from parent if not specified
				inheritable:
					'position'
					'ease'
				# these form a tween
				tweenable:
					'className'
					'css'
			# initialize
			for a,b of x
				for a in b
					b[a] = option[a]
			return x
		# }}}
		return do ->
			# initialize
			protoList = Object.keys proto
			apiList   = Object.keys api
			# create constructor
			return (options, parent) !-> # {{{
				# set methods
				for a in protoList
					@[a] = proto[a]
				# set properties
				# ordered list of filtered options
				@options = options
				# backlink for nested animations
				@parent = if parent
					then parent
					else null
				# children/nested animations ordered by position
				@queue = null
				# base timings (in milliseconds)
				@duration = 0
				@delay = 0
				@position = 0
				# relative, normalized position [0..1]
				@scale = 0
				# named position
				@label = ''
				# position change factor
				@ease = null
				# list of DOM nodes
				@target = null
				# individual tween
				@tween = null
				# state flags
				@ready   = false
				@started = false
				@active  = false
				# public api for master-animation
				@api = if parent
					then null
					else new Proxy @, apiProxy
				# user-defined callbacks
				@callback = null
		# }}}
	# }}}
	return do ->
		me = (options) -> # {{{
			# check
			if (typeof! options) != 'Object'
				console.error 'redsock:options: incorrect type'
				return null
			# create master-animation
			# and return proxy object api
			a = new ANIMATION options
			return a.api
		# }}}
		# global options {{{
		# define
		Object.defineProperty me, 'minFPS', TICKER.minFPS
		Object.defineProperty me, 'FPS', TICKER.FPS
		Object.defineProperty me, 'enableRGB2', CSS.enableRGB2
		# set defaults
		me.minFPS = 10
		me.enableRGB2 = true
		me.ease = EASE
		# }}}
		return Object.seal me

# vim: set noet ts=2 sw=2 sts=2 fdm=marker fenc=utf-8 ff=dos:
