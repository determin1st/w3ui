// Generated by LiveScript 1.6.0
"use strict";
var w3ui, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
w3ui = function(){
  var metacall;
  metacall = function(f){
    var reqs, meta, a;
    if (typeof console === 'undefined') {
      return null;
    }
    reqs = f.toString();
    reqs = reqs.substring(1 + reqs.indexOf('('), reqs.indexOf(')'));
    reqs = reqs.split(',');
    meta = [reqs];
    a = 0;
    while (++a < reqs.length) {
      reqs[a] = reqs[a].trim();
      meta[a] = eval('typeof ' + reqs[a]) === 'undefined'
        ? null
        : eval(reqs[a]);
    }
    return f.apply(null, meta);
  };
  return metacall(function(REQS, console, document, performance, HTMLElement, w3fetch){
    var a, w3ui, events, blocks, Console;
    a = REQS.length - 1;
    while (--a) {
      if (!arguments[a]) {
        console.log('%c' + 'w3ui requires ' + REQS[a], 'color:violet;font-weight:bold;font-size:2em');
        return null;
      }
    }
    w3ui = Object.create(null);
    events = Object.create(null);
    blocks = Object.create(null);
    Console = function(brand){
      this.brand = brand;
      this.style = null;
    };
    Console.prototype = {
      console: console,
      isdebug: true,
      styles: ['font-weight:bold;color:skyblue', 'color:aquamarine', 'color:violet', 'color:slateblue', 'color:slategray'],
      'new': function(brand){
        return new Console(this.brand + ':' + brand);
      },
      log: function(m){
        var s;
        s = this.style || this.styles;
        m = '%c' + this.brand + ': %c' + m;
        this.console.log(m, s[0], s[1]);
      },
      error: function(m){
        var s;
        s = this.style || this.styles;
        m = '%c' + this.brand + ': %c' + m;
        this.console.log(m, s[0], s[2]);
      },
      debug: function(e, ok){
        var s, m;
        if (this.isdebug) {
          s = this.style || this.styles;
          m = '%c' + this.brand + ': ';
          if (typeof e === 'string') {
            m += '%c' + e;
            if (arguments.length === 1) {
              this.console.log(m, s[3], s[4]);
            } else {
              ok = typeof ok === 'string'
                ? ok
                : (ok && 'ok') || '';
              m += '.. %c' + ok;
              this.console.log(m, s[3], s[4], s[1]);
            }
          } else {
            this.console.log(e);
          }
        }
      }
    };
    console = new Console('w3ui');
    Object.assign(w3ui, {
      console: console,
      metacall: metacall,
      metaconstruct: function(){
        var map, construct;
        map = Object.create(null);
        construct = function(props){
          return function(){
            var i$, ref$, len$, prop;
            for (i$ = 0, len$ = (ref$ = props).length; i$ < len$; ++i$) {
              prop = ref$[i$];
              this[prop] = null;
            }
          };
        };
        return function(props, defs){
          var key, f;
          if (!(props instanceof Array)) {
            defs = props;
            props = Object.getOwnPropertyNames(props);
          }
          key = props.join(',');
          if (!(f = map[key])) {
            map[key] = f = construct(props);
          }
          return defs
            ? Object.assign(new f(), defs)
            : new f();
        };
      }(),
      merge: function(cfg, defs){
        var a;
        if (defs) {
          defs = w3ui.metaconstruct(defs);
          if (cfg) {
            for (a in defs) {
              if (cfg.hasOwnProperty(a)) {
                defs[a] = cfg[a];
              }
            }
          }
        }
        return defs
          ? defs
          : Object.create(null);
      },
      promise: function(a){
        var f, p;
        f = null;
        p = new Promise(function(resolve){
          f = resolve;
        });
        p.pending = a || -1;
        p.resolve = function(a){
          if (!arguments.length) {
            a = p.pending;
          }
          p.pending = 0;
          f(a);
        };
        return p;
      },
      delay: function(t, a){
        var f, p, x;
        t == null && (t = 0);
        f = null;
        p = new Promise(function(resolve){
          f = resolve;
        });
        p.pending = a || -1;
        x = setTimeout(function(){
          p.resolve();
        }, t);
        p.resolve = function(a){
          a == null && (a = p.pending);
          clearTimeout(x);
          p.pending = 0;
          f(a);
        };
        p.cancel = function(){
          clearTimeout(x);
          p.pending = 0;
          f(0);
        };
        return p;
      },
      template: function(f){
        var a, b;
        f = f.toString();
        a = f.indexOf('/*') + 2;
        b = f.lastIndexOf('*/') - 1;
        f = f.substring(a, b).trim().replace(/>\s+</g, '><');
        return f;
      },
      parse: function(template, tags){
        var a, i, j, k, b;
        a = '';
        i = 0;
        while (~(j = template.indexOf('{{', i))) {
          a += template.substring(i, j);
          i = j;
          j += 2;
          if ((k = template.indexOf('}}', j)) === -1) {
            break;
          }
          if (k - j > 16) {
            a += '{{';
            i += 2;
            continue;
          }
          b = template.substring(j, k);
          if (!tags.hasOwnProperty(b)) {
            a += '{{';
            i += 2;
            continue;
          }
          a += tags[b];
          i = k + 2;
        }
        return a + template.substring(i);
      },
      append: function(box, item){
        var i$, len$, a;
        if (!(box instanceof Element)) {
          if (!(box = box.root)) {
            return null;
          }
        }
        if (item instanceof Array) {
          for (i$ = 0, len$ = item.length; i$ < len$; ++i$) {
            a = item[i$];
            if (a instanceof Element) {
              box.appendChild(a);
            } else if (a.root) {
              box.appendChild(a.root);
            }
          }
        } else if (item instanceof Element) {
          box.appendChild(item);
        } else if (item.root) {
          box.appendChild(item.root);
        }
        return item;
      },
      queryChildren: function(node, selector){
        var a, i$, ref$, len$, b;
        a = [];
        if (!node || !node.children.length) {
          return a;
        }
        for (i$ = 0, len$ = (ref$ = node.querySelectorAll(selector)).length; i$ < len$; ++i$) {
          b = ref$[i$];
          if (b.parentNode === node) {
            a[a.length] = b;
          }
        }
        return a;
      },
      queryChild: function(node, selector){
        var a;
        if (!node) {
          return null;
        }
        a = w3ui.queryChildren(node, selector);
        return a.length ? a[0] : null;
      },
      getArrayObjectProps: function(a, prop, compact){
        var c, x, i, b;
        compact == null && (compact = false);
        if (!a || !(c = a.length)) {
          return null;
        }
        x = [];
        i = -1;
        while (++i < c) {
          if ((b = a[i]) && prop in b) {
            x[x.length] = b[prop];
          } else if (!compact) {
            x[x.length] = null;
          }
        }
        return x;
      },
      debounce: function(f, t, max){
        var timer, count;
        t == null && (t = 100);
        max == null && (max = 3);
        timer = w3ui.delay();
        count = 0;
        return async function(){
          var e, res$, i$, to$;
          res$ = [];
          for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
            res$.push(arguments[i$]);
          }
          e = res$;
          while (e.length === f.length) {
            if (timer.pending) {
              timer.cancel();
              if (max && (count = count + 1) > max) {
                break;
              }
            }
            if ((await (timer = w3ui.delay(t)))) {
              break;
            }
            return false;
          }
          count = 0;
          return f.apply(null, e);
        };
      }
    });
    Object.assign(events, function(){
      var nodeEvents, blockEvents, Events, getEvents;
      nodeEvents = new WeakMap();
      blockEvents = new WeakMap();
      Events = function(){
        this.hover = null;
        this.focus = null;
        this.click = null;
        this.mmove = null;
      };
      getEvents = function(node){
        var e;
        if (!(e = nodeEvents.get(node))) {
          nodeEvents.set(node, e = new Events());
        }
        return e;
      };
      return {
        attach: function(block, o){
          var e, a;
          if (!(e = blockEvents.get(block))) {
            blockEvents.set(block, e = new Events());
          }
          for (a in e) {
            if (o.hasOwnProperty(a)) {
              if (e[a]) {
                events[a](block.root);
              }
              events[a](block, o[a]);
              e[a] = 1;
            }
          }
        },
        hover: function(item, f, o){
          var a, e;
          if (item instanceof HTMLElement) {
            if (a = (e = getEvents(item)).hover) {
              e.hover = null;
              item.removeEventListener('pointerenter', a[0]);
              item.removeEventListener('pointerleave', a[1]);
            }
            if (!f) {
              return;
            }
            if (arguments.length < 3) {
              o = item;
            }
            a = e.hover = [
              function(e){
                if (e.pointerType === 'mouse') {
                  e.preventDefault();
                  f(o, 1, e);
                }
              }, function(e){
                if (e.pointerType === 'mouse') {
                  e.preventDefault();
                  f(o, 0, e);
                }
              }
            ];
            item.addEventListener('pointerenter', a[0]);
            item.addEventListener('pointerleave', a[1]);
          } else {
            item.hovered = 0;
            events.hover(item.root, function(root, v, e){
              if (!item.locked || !v) {
                item.hovered = v;
                root.classList.toggle('h', v);
                if (f) {
                  f(o, v, e);
                }
              }
            });
          }
        },
        hovers: function(B, F, t, N){
          var omap;
          t == null && (t = 100);
          N == null && (N = B.root);
          omap = new WeakMap();
          return async function(item, v, e){
            var o;
            if (!(o = omap.get(item))) {
              o = [0, w3ui.delay()];
              o[1].cancel();
              omap.set(item, o);
            }
            if (!e) {
              if (!v) {
                if (!o[0]) {
                  return false;
                } else if (o[1].pending) {
                  o[1].cancel();
                }
                o[0] = 0;
              } else if (v === -1) {
                if (!o[0]) {
                  return false;
                }
                o[0] = o[0] === -1
                  ? 1
                  : -1;
                return true;
              } else {
                return false;
              }
            } else if (v === 1) {
              if (o[1].pending) {
                o[1].cancel();
                return true;
              } else if (o[0]) {
                return false;
              }
              o[0] = 1;
            } else {
              if (!o[0]) {
                return false;
              }
              if (o[1].pending) {
                o[1].cancel();
              }
              if (~o[0] && !(await (o[1] = w3ui.delay(t)))) {
                return false;
              }
              o[0] = 0;
            }
            if (o[0]) {
              if (++B.hovered === 1 && N) {
                N.classList.add('h');
              }
            } else {
              if (--B.hovered === 0 && N) {
                N.classList.remove('h');
              }
            }
            F(item, v, e);
            return true;
          };
        },
        focus: function(item, f, o){
          var a, e;
          if (item instanceof HTMLElement) {
            if (a = (e = getEvents(item)).focus) {
              e.focus = null;
              item.removeEventListener('focus', a[0]);
              item.removeEventListener('blur', a[1]);
            }
            if (!f) {
              return;
            }
            if (arguments.length < 3) {
              o = item;
            }
            a = e.focus = [
              function(e){
                f(o, 1, e);
              }, function(e){
                f(o, 0, e);
              }
            ];
            item.addEventListener('focus', a[0]);
            item.addEventListener('blur', a[1]);
          } else {
            events.focus(item.root, function(root, v, e){
              item.focused = v;
              root.classList.toggle('f', v);
              if (f) {
                f(o, v, e);
              }
            });
            return true;
          }
        },
        click: function(item, f, o){
          var a, e;
          if (item instanceof HTMLElement) {
            if (a = (e = getEvents(item)).click) {
              e.click = null;
              item.removeEventListener('click', a);
            }
            if (!f) {
              return;
            }
            if (arguments.length < 3) {
              o = item;
            }
            item.addEventListener('click', e.click = function(e){
              e.preventDefault();
              f(o, e);
            });
          } else {
            events.click(item.root, async function(root, e){
              if (item.locked) {
                return false;
              }
              switch ((await f(o, null))) {
              case 1:
                e.stopImmediatePropagation();
                item.setLocked(2);
                if ((await f(o, e))) {
                  if (item.locked === 2) {
                    item.setLocked(0);
                  }
                }
              }
              return true;
            });
          }
        },
        mmove: function(item, f, o){
          var a, e;
          if (item instanceof HTMLElement) {
            if (a = (e = getEvents(item)).mmove) {
              e.mmove = null;
              item.removeEventListener('pointermove', a);
            }
            if (!F) {
              return;
            }
            if (arguments.length < 3) {
              o = item;
            }
            item.addEventListener('pointermove', e.mmove = function(e){
              if (e.pointerType === 'mouse') {
                e.preventDefault();
                f(o, e);
              }
            });
          } else {
            events.mmove(item.root, async function(root, e){
              if (item.locked) {
                return false;
              }
              switch ((await f(o, e))) {
              case 1:
                e.stopImmediatePropagation();
              }
              return true;
            });
          }
        },
        detach: function(block){
          var e, a;
          if (e = eventMap.get(block)) {
            for (a in e) {
              if (e[a]) {
                events[a](block.root);
                e[a] = 0;
              }
            }
          }
        }
      };
    }());
    Object.assign(blocks, {
      construct: function(){
        var Block;
        Block = function(map, o){
          var a;
          this.console = o.console;
          this.root = o.root;
          this.rootBox = o.root.firstChild;
          this.cfg = o.cfg;
          this.focused = this.hovered = 0;
          this.locked = 1;
          this.init = this.init(map.init);
          this.lock = this.lock(map.lock);
          for (a in map) {
            if (!this.hasOwnProperty(a)) {
              this[a] = map[a];
            }
          }
          this.construct(o);
        };
        Block.prototype = {
          init: function(func){
            var this$ = this;
            return function(){
              func.call(this$);
              this$.root.classList.add('v');
            };
          },
          lock: function(func){
            var this$ = this;
            return function(v){
              this$.rootBox.classList.toggle('v', !(this$.locked = v));
              func.call(this$, v);
            };
          }
        };
        return function(name, map){
          if (typeof map === 'function') {
            map = map();
          }
          map = w3ui.metaconstruct(map);
          return function(o){
            var a, b, c, i$, ref$, len$, d, e;
            a = o.root
              ? o.root.className
              : o.className;
            b = ['w3ui', name];
            c = [];
            if (a) {
              for (i$ = 0, len$ = (ref$ = a.split(' ')).length; i$ < len$; ++i$) {
                d = ref$[i$];
                if (!b.includes(d)) {
                  c[c.length] = d;
                }
              }
            }
            o.console = console;
            if (c.length) {
              a = c.slice(0, 2).join(':');
              o.console = console['new'](a);
            }
            o.className = a = (b.concat(c)).join(' ');
            if (o.root) {
              if ((b = o.root).className !== a) {
                o.root.className = a;
              }
              if (!(c = b.firstChild)) {
                c = document.createElement('div');
                b.appendChild(c);
              } else if (a = c.innerHTML) {
                while (c.firstChild) {
                  c.removeChild(c.lastChild);
                }
                if (a.length > 9) {
                  try {
                    c = a.slice(4, a.length - 3);
                    c = JSON.parse(c);
                  } catch (e$) {
                    e = e$;
                    o.console.error('incorrect SSR input (JSON-in-HTML)');
                    o.console.debug(a);
                    c = {};
                  }
                  o.cfg = o.cfg ? Object.assign(c, o.cfg) : c;
                }
              }
            } else {
              b = o.root = document.createElement('div');
              c = document.createElement('div');
              b.appendChild(c);
              b.className = a;
              if (o.style) {
                switch (typeof o.style) {
                case 'object':
                  a = '';
                  for (c in o.style) {
                    a += a + ':' + o.style[c] + ';';
                  }
                  b.setAttribute('style', a);
                  break;
                case 'string':
                  b.setAttribute('style', o.style);
                }
              }
              if (o.html) {
                box.innerHTML = o.html;
              } else if (o['export'] && o.cfg) {
                box.innerHTML = '<!--' + JSON.stringify(o.cfg) + '-->';
              }
            }
            o.cfg = w3ui.merge(o.cfg, map.defs);
            return new Block(map, o);
          };
        };
      }(),
      group: function(){
        var Block, Group;
        Block = function(root, group, o){
          this.root = root;
          this.rootBox = root.firstChild;
          this.level = o.hasOwnProperty('level')
            ? o.level
            : group.level;
          this.config = group['super'].config;
          this.state = group['super'].state;
          this.sync = o.sync;
          this.check = o.check || null;
          this.charge = this.charge(group);
          this.locked = 1;
          if (o.construct.call(this)) {
            this.init = this.init(o.init);
            this.lock = this.lock(o.lock);
          } else {
            this.init = o.init;
            this.lock = o.lock;
          }
        };
        Block.prototype = {
          init: function(func){
            var this$ = this;
            return function(){
              func.call(this$);
              this$.root.classList.add('v');
            };
          },
          lock: function(func){
            var this$ = this;
            return function(v){
              this$.rootBox.classList.toggle('v', !(this$.locked = v));
              func.call(this$, v);
            };
          },
          charge: function(group){
            var this$ = this;
            return function(){
              group.sync(this$);
              if (this$.level && !this$.locked) {
                group['super'].charge(this$);
              }
            };
          }
        };
        Group = function(name, level, sup){
          this.console = sup.console;
          this.name = name;
          this.level = level;
          this['super'] = sup;
          this.blocks = [];
        };
        Group.prototype = {
          init: function(){
            var i$, ref$, len$, a;
            for (i$ = 0, len$ = (ref$ = this.blocks).length; i$ < len$; ++i$) {
              a = ref$[i$];
              a.init();
            }
          },
          sync: function(block){
            var i$, ref$, len$, a;
            for (i$ = 0, len$ = (ref$ = this.blocks).length; i$ < len$; ++i$) {
              a = ref$[i$];
              if (a !== block) {
                a.sync();
              }
            }
          }
        };
        return function(name, level, sup, o){
          var console, group, blocks, a, b, c, d;
          console = sup.console;
          group = new Group(name, level, sup);
          blocks = group.blocks;
          for (a in o) {
            b = sup.root.querySelectorAll('.' + sup.brand + '.' + a);
            if (!(c = b.length)) {
              console.debug('block <' + a + '>', 0);
              continue;
            }
            b = Array.from(b);
            d = -1;
            while (++d < c) {
              blocks[blocks.length] = new Block(b[d], group, o[a]);
            }
            console.debug('block <' + a + '>', 1);
          }
          if (!blocks.length) {
            return null;
          }
          blocks.sort(function(a, b){
            return a.level < b.level
              ? -1
              : a.level === b.level ? 0 : 1;
          });
          return group;
        };
      }(),
      buffer: function(){
        var Block;
        Block = function(){
          this.total = -1;
          this.bufA = [];
          this.bufB = [];
          this.range = [0, 0, 0, 0, 0];
          this.offset = [0, 0, 0];
        };
        Block.prototype = {
          init: function(total){}
          /***
          load: (i, record) -> # {{{
          	# check range and buffer are valid
          	if not (o = @offset).2
          		return false
          	# determine where to store this record
          	if i < @range.2
          		# store forward
          		i = @bufA.length
          		@bufA[i] = record
          		# determine display offset
          		i = if (o = o.0 - o.1) >= 0
          			then i - o
          			else i - @group.config.total - o
          		# update item if it's displayed
          		if i >= 0 and i < @count
          			@items[i].set record
          	else
          		# store backward
          		i = @bufB.length
          		@bufB[i] = record
          		# determine display offset
          		i = if (o = o.1 - o.0) > 0
          			then i - o
          			else i - @group.config.total - o
          		# update item if it's displayed
          		if i < 0 and i + @count >= 0
          			@items[-i - 1].set record
          	# done
          	return true
          # }}}
          /***/,
          load: function(record){
            var o, A, B, i;
            if (!(o = this.offset)[2]) {
              return false;
            }
            o = this.offset;
            A = this.bufA;
            B = this.bufB;
            if (i < this.range[2]) {
              i = A.length;
              A[i] = record;
              i = (o = o[0] - o[1]) >= 0
                ? i - o
                : i - this.group.config.total - o;
              if (i >= 0 && i < this.count) {
                this.items[i].set(record);
              }
            } else {
              i = this.bufB.length;
              this.bufB[i] = record;
              i = (o = o[1] - o[0]) > 0
                ? i - o
                : i - this.group.config.total - o;
              if (i < 0 && i + this.count >= 0) {
                this.items[-i - 1].set(record);
              }
            }
            return true;
          },
          setBuffer: function(){
            var A, B, R, a, b, c, d, o, O, i, j, k;
            A = this.bufA;
            B = this.bufB;
            R = this.range;
            a = A.length;
            b = B.length;
            c = this.group.config.total;
            d = this.page;
            o = this.offset[0];
            O = this.offset[1];
            if ((i = o - O) > 0 && c - i < i) {
              i = i - c;
            } else if (i < 0 && c + i < -i) {
              i = c + i;
            }
            if (Math.abs(i) > d + d - 1) {
              this.clearBuffer();
              return 2;
            }
            d = d >>> 1;
            if (i === 0 || (i > 0 && d - i > 0)) {
              j = -1;
              while (++j < this.count) {
                if (i < a) {
                  this.items[j].set(A[i++]);
                } else {
                  this.items[j].set();
                }
              }
              return 0;
            }
            if (i < 0 && d + i >= 0) {
              j = -1;
              k = -i - 1;
              while (++j < this.count) {
                if (k >= 0 && b - k > 0) {
                  this.items[j].set(B[k]);
                } else if (k < 0 && a + k > 0) {
                  if (this.config.wrapAround) {
                    this.items[j].set(A[-k - 1]);
                  } else {
                    this.items[j].set();
                  }
                } else {
                  this.items[j].set();
                }
                --k;
              }
              return 0;
            }
            if (i > 0 && a - i > 0) {
              j = b;
              while (j < i) {
                B[j++] = null;
              }
              j = i;
              k = 0;
              while (k < b && j < this.page) {
                B[j++] = B[k++];
              }
              B.length = j;
              j = i - 1;
              k = 0;
              while (~j) {
                B[j--] = A[k++];
              }
              while (k < a) {
                A[++j] = A[k++];
              }
              A.length = k = j + 1;
              j = this.count;
              while (j) {
                if (--j < k) {
                  this.items[j].set(A[j]);
                } else {
                  this.items[j].set();
                }
              }
              this.setRange(o, true);
              return 1;
            }
            if (i < 0 && b + i > 0) {
              i = -i;
              j = a;
              while (j < i) {
                A[j++] = null;
              }
              j = i;
              k = 0;
              while (k < a && j < this.page) {
                A[j++] = A[k++];
              }
              A.length = j;
              j = i - 1;
              k = 0;
              while (~j) {
                A[j--] = B[k++];
              }
              while (k < b) {
                B[++j] = B[k++];
              }
              B.length = j + 1;
              j = -1;
              k = A.length;
              while (++j < this.count) {
                if (j < k) {
                  this.items[j].set(A[j]);
                } else {
                  this.items[j].set();
                }
              }
              this.setRange(o, true);
              return -1;
            }
            this.clearBuffer();
            return -2;
          },
          setRange: function(o, gaps){
            var a, c, b;
            a = this.range;
            c = this.cfg.limit;
            if (!~this.total) {
              a[0] = o;
              a[2] = a[4] = c;
              a[1] = a[3] = -1;
            } else if (gaps) {
              a[0] = o;
              if ((b = this.bufA.length) < c) {
                if ((a[1] = o + b) >= this.total) {
                  a[1] = a[1] - this.total;
                }
                a[2] = c - b;
              } else {
                a[1] = a[2] = 0;
              }
              if ((b = this.bufB.length) < c) {
                if ((a[3] = o - 1 - b) < 0) {
                  a[3] = a[3] + this.total;
                }
                a[4] = c - b;
              } else {
                a[3] = a[4] = 0;
              }
            } else {
              a[0] = a[1] = o;
              a[2] = a[4] = c;
              a[3] = o
                ? o - 1
                : this.total - 1;
            }
            return true;
          },
          clearBuffer: function(){
            var i;
            this.setRange(this.offset[0]);
            this.bufA.length = this.bufB.length = 0;
            i = this.count;
            while (i) {
              this.items[--i].set();
            }
          }
        };
        return Block;
      }(),
      resizer: function(){
        var Slave, Master;
        Slave = function(master, node){
          this.parent = master;
          this.node = node;
          this.blocks = null;
          this.factor = 1;
          this.emitter = null;
          this.handler = null;
        };
        Master = function(selector, blocks){
          var s, n, i$, len$, a, b, c, j$, len1$, d, e;
          this.slaves = s = [];
          n = arrayFrom$(document.querySelectorAll(selector));
          for (i$ = 0, len$ = n.length; i$ < len$; ++i$) {
            a = n[i$];
            s[s.length] = b = new Slave(this, a);
            b.blocks = c = [];
            for (j$ = 0, len1$ = blocks.length; j$ < len1$; ++j$) {
              d = blocks[j$];
              e = d.root;
              while (e && e !== a && n.indexOf(e) === -1) {
                e = e.parentNode;
              }
              if (e === a) {
                c[c.length] = d;
              }
            }
            b.handler = e = this.handler(b);
            for (j$ = 0, len1$ = c.length; j$ < len1$; ++j$) {
              d = c[j$];
              if (d.resizer) {
                d.resizer.onChange = e;
              }
            }
          }
        };
        Master.prototype = {
          handler: function(s){
            return function(e){
              var c;
              if (s.factor > e || s.emitter === this.block) {
                s.factor = e;
                c = '--w3-factor';
                if (e === 1) {
                  s.node.style.removeProperty(c);
                  s.emitter = null;
                } else {
                  s.node.style.setProperty(c, e);
                  s.emitter = this.block;
                }
              } else {
                e = s.factor;
              }
              return e;
            };
          }
        };
        return Master;
      }(),
      button: function(){
        var Block;
        Block = function(root, o){
          this.root = root;
          this.cfg = o.cfg || null;
          this.label = w3ui.queryChild(root, '.label');
          this.rect = null;
          this.hovered = 0;
          this.focused = 0;
          this.locked = 1;
          events.attach(this, o.event);
        };
        Block.prototype = {
          lock: function(v){
            v == null && (v = 1);
            if (this.locked !== v) {
              switch (v) {
              case 2:
                this.root.classList.add('w');
                this.root.disabled = true;
                this.locked = 2;
                break;
              case 1:
                if (this.locked) {
                  this.root.classList.remove('w');
                } else {
                  this.root.disabled = true;
                }
                this.root.classList.remove('v');
                this.locked = 1;
                break;
              default:
                if (this.locked === 2) {
                  this.root.classList.remove('w');
                } else {
                  this.root.classList.add('v');
                }
                this.root.disabled = false;
                this.locked = 0;
              }
            }
          }
        };
        return function(o){
          var a, b, e;
          o == null && (o = {});
          a = document.createElement('button');
          a.type = 'button';
          a.disabled = true;
          a.className = 'w3-button' + ((o.name && ' ' + o.name) || '');
          if (o.hint) {
            a.setAttribute('title', o.hint);
          }
          if (o.label) {
            b = document.createElement('div');
            b.className = 'label';
            b.textContent = o.label;
            a.appendChild(b);
          } else if (o.html) {
            a.innerHTML = o.html;
          }
          e = {
            hover: 0,
            focus: 0
          };
          o.event = o.event ? Object.assign(e, o.event) : e;
          a = new Block(a, o);
          return a;
        };
      }(),
      select: function(){
        var template, Block;
        template = w3ui.template(function(){
          /*
          <svg preserveAspectRatio="none" viewBox="0 0 48 48">
          	<polygon class="b" points="24,32 34,17 36,16 24,34 "/>
          	<polygon class="b" points="24,34 12,16 14,17 24,32 "/>
          	<polygon class="b" points="34,17 14,17 12,16 36,16 "/>
          	<polygon class="a" points="14,17 34,17 24,32 "/>
          </svg>
          */
        });
        Block = function(root, select){
          var this$ = this;
          this.root = root;
          this.select = select;
          this.current = -1;
          this.hovered = false;
          this.focused = false;
          this.locked = true;
          this.onHover = null;
          this.onFocus = null;
          this.onChange = null;
          this.hover = function(e){
            e.preventDefault();
            if (!this$.locked && !this$.hovered) {
              this$.hovered = true;
              this$.root.classList.add('h');
              if (e = this$.onHover) {
                e(this$);
              }
            }
          };
          this.unhover = function(e){
            e.preventDefault();
            if (this$.hovered) {
              this$.hovered = false;
              this$.root.classList.remove('h');
              if (e = this$.onHover) {
                e(this$);
              }
            }
          };
          this.focus = function(e){
            if (this$.locked) {
              e.preventDefault();
              e.stopPropagation();
            } else if (!this$.focused) {
              this$.focused = true;
              this$.root.classList.add('f');
              if (e = this$.onFocus) {
                e(this$);
              }
            }
          };
          this.unfocus = function(e){
            e.preventDefault();
            if (this$.focused) {
              this$.focused = false;
              this$.root.classList.remove('f');
              if (e = this$.onFocus) {
                e(this$);
              }
            }
          };
          this.input = function(e){
            e.preventDefault();
            if (this$.locked || ((e = this$.onChange) && !e(this$.select.selectedIndex))) {
              this$.select.selectedIndex = this$.current;
            } else {
              this$.current = this$.select.selectedIndex;
            }
          };
        };
        Block.prototype = {
          init: function(list, index){
            var i$, len$, a, b;
            list == null && (list = null);
            index == null && (index = -1);
            if (list) {
              for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
                a = list[i$];
                b = document.createElement('option');
                b.textContent = a;
                this.select.appendChild(b);
              }
              this.current = this.select.selectedIndex = index;
            } else {
              this.current = this.select.selectedIndex = -1;
              this.select.innerHTML = '';
            }
            a = this.root;
            b = list ? 'addEventListener' : 'removeEventListener';
            a[b]('pointerenter', this.hover);
            a[b]('pointerleave', this.unhover);
            a[b]('focusin', this.focus);
            a[b]('focusout', this.unfocus);
            a[b]('input', this.input);
          },
          lock: function(locked){
            if (this.locked !== locked) {
              this.root.classList.toggle('v', !(this.locked = locked));
              this.select.disabled = locked;
            }
          },
          set: function(i){
            if (i !== this.current) {
              this.current = this.select.selectedIndex = i;
            }
            return i;
          },
          get: function(){
            return this.current;
          }
        };
        return function(o){
          var a, b;
          o == null && (o = {});
          a = document.createElement('div');
          a.className = 'w3-select' + ((o.name && ' ' + o.name) || '');
          a.innerHTML = o.hasOwnProperty('svg') ? o.svg : template;
          b = document.createElement('select');
          a.appendChild(b);
          return new Block(a, b);
        };
      }(),
      checkbox: function(){
        var template, Block;
        template = w3ui.template(function(){
          /*
          <button type="button" class="sm-checkbox" disabled>
          <svg preserveAspectRatio="none" viewBox="0 0 48 48">
          	<circle class="a" cx="24" cy="24" r="12"/>
          	<path class="b" d="M24 6a18 18 0 110 36 18 18 0 010-36zm0 6a12 12 0 110 24 12 12 0 010-24z"/>
          	<path class="c" d="M24 4a20 20 0 110 40 20 20 0 010-40zm0 2a18 18 0 110 36 18 18 0 010-36z"/>
          	<path class="d" d="M48 27v-6H0v6z"/>
          	<path class="e" d="M27 48V0h-6v48z"/>
          </svg>
          </button>
          */
        });
        Block = function(root, cfg){
          var this$ = this;
          this.root = root;
          this.cfg = cfg;
          this.current = -2;
          this.hovered = false;
          this.focused = false;
          this.locked = true;
          this.onHover = null;
          this.onFocus = null;
          this.onChange = null;
          this.hover = async function(e){
            e.preventDefault();
            if (!this$.locked) {
              if (!this$.onHover || (await this$.onHover(this$, true))) {
                this$.setHovered(true);
              }
            }
          };
          this.unhover = async function(e){
            e.preventDefault();
            if (!this$.onHover || (await this$.onHover(this$, false))) {
              this$.setHovered(false);
            }
          };
          this.focus = async function(e){
            if (this$.locked) {
              e.preventDefault();
              e.stopPropagation();
            } else {
              if (!this$.onFocus || (await this$.onFocus(this$, true))) {
                this$.setFocused(true);
              }
            }
          };
          this.unfocus = async function(e){
            e.preventDefault();
            if (!this$.onFocus || (await this$.onFocus(this$, false))) {
              this$.setFocused(false);
            }
          };
          this.click = function(e){
            e.preventDefault();
            e.stopPropagation();
            if (!this$.locked && (~this$.current || ~this$.cfg.intermediate)) {
              this$.event();
            }
          };
          this.event = async function(){
            var c;
            c = ~(c = this$.current)
              ? 1 - c
              : this$.cfg.intermediate;
            if (!this$.focused) {
              this$.root.focus();
            }
            if (!this$.onChange || (await this$.onChange(this$, c))) {
              this$.set(c);
            }
          };
        };
        Block.prototype = {
          init: function(v){
            var a, b;
            v == null && (v = -1);
            this.set(v);
            if (~this.cfg.intermediate) {
              this.root.classList.add('i');
            }
            if (a = this.cfg.master) {
              if (!this.onHover) {
                this.onHover = a.onHover;
              }
              if (!this.onFocus) {
                this.onFocus = a.onFocus;
              }
            }
            a = this.root;
            b = 'addEventListener';
            a[b]('pointerenter', this.hover);
            a[b]('pointerleave', this.unhover);
            a[b]('focusin', this.focus);
            a[b]('focusout', this.unfocus);
            a[b]('click', this.click);
          },
          lock: function(flag){
            flag == null && (flag = true);
            if (this.locked !== flag) {
              this.root.classList.toggle('v', !(this.locked = flag));
              if (flag || ~this.current || ~this.cfg.intermediate) {
                this.root.disabled = flag;
              }
            }
          },
          set: function(v){
            var i;
            if (this.current === v) {
              return v;
            }
            if ((i = this.current + 1) >= 0) {
              this.root.classList.remove('x' + i);
            }
            this.root.classList.add('x' + (v + 1));
            return this.current = v;
          },
          setHovered: function(v){
            if (this.hovered === v) {
              return false;
            }
            this.hovered = v;
            this.root.classList.toggle('h');
            return true;
          },
          setFocused: function(v){
            if (this.focused === v) {
              return false;
            }
            this.focused = v;
            this.root.classList.toggle('f');
            return true;
          }
        };
        return function(o){
          var a;
          o == null && (o = {});
          o.intermediate = o.intermediate
            ? o.intermediate
            : -1;
          a = document.createElement('template');
          a.innerHTML = template;
          a = a.content.firstChild;
          if (o.svg) {
            a.innerHTML = o.svg;
          }
          return new Block(a, o);
        };
      }()
    });
    Object.assign(w3ui, {
      blocks: Object.freeze(blocks),
      events: Object.freeze(events),
      grid: blocks.construct('grid', function(){
        /***
        Block = (o) !->
        	# {{{
        	# base
        	@root    = o.root
        	@rootBox = o.root.firstChild
        	@cfg     = o.cfg or null
        	# controls
        	# ...
        	# state
        	@hovered = 0
        	@focused = 0
        	@locked  = 1
        	# traps
        	# ...
        	# handlers
        	#e = {hover:0}
        	#e = Object.assign e, o.event if o.event
        	#events.attach @, e
        	# }}}
        Block.prototype =
        	name: 'grid'
        	init: !-> # {{{
        		true
        	# }}}
        return w3ui.factory 'grid', Block
        /***/
        return {
          construct: function(o){
            true;
          },
          init: function(){
            true;
          }
        };
      }),
      gridlist: blocks.construct('gridlist', function(){
        /***
        @intersect = (e) ~>> # {{{
        	# fixed rows
        	# {{{
        	a = @block.config.layout
        	if (c = @block.rows) or (c = a.1) == a.3
        		# update
        		if (a = @layout).1 != c
        			@block.root.style.setProperty '--rows', (a.1 = c)
        			a.0 and @block.setCount (a.0 * c)
        		# done
        		return true
        	# }}}
        	# dynamic rows
        	# check locked
        	if @dot.pending or not e
        		console.log 'intersect skip'
        		return true
        	# prepare
        	e = e.0.intersectionRatio
        	o = @layout
        	c = o.1
        	b = a.3
        	a = a.1
        	# get scrollable container (aka viewport)
        	if not (w = v = @i_opt.root)
        		w = window
        		v = document.documentElement
        	# get viewport, row and dot heights
        	h = v.clientHeight
        	y = (@gaps.1 + @sizes.1) * @factor
        	z = (@sizes.2 * @factor)
        	# determine scroll parking point (dot offset),
        	# which must be smaller than threshold trigger
        	x = z * (1 - @i_opt.threshold.1 - 0.01) .|. 0
        	# handle finite scroll
        	# {{{
        	if b
        		# ...
        		return true
        	# }}}
        	# handle infinite scroll
        	# {{{
        	# fill the viewport (extend scroll height)
        	b = v.scrollHeight
        	if e and b < h + z
        		# determine exact minimum
        		e  = Math.ceil ((b - c*y - z) / y)
        		c += e
        		b += y*e
        		# update
        		@block.root.style.setProperty '--rows', (o.1 = c)
        		if o.0 and @block.setCount (o.0 * c) and @ready.pending
        			@ready.resolve!
        		# adjust scroll position
        		@s_opt.0 = v.scrollTop
        		@s_opt.1.top = b - h - x
        		@s_opt.2.top = b - h - z
        		# wait repositions (should be cancelled)
        		await (@dot = w3ui.promise -1)
        		@observer.1.disconnect!
        		@observer.1.observe @block.dot
        		# done
        		return true
        	# adjust the viewport
        	while e
        		# determine scroll options and
        		# set scroll (after increment)
        		@s_opt.1.top = b - h - x
        		@s_opt.2.top = b - h - z
        		if e > 0
        			w.scrollTo @s_opt.1
        		else if @s_opt.0 == -2
        			w.scrollTo @s_opt.2
        		# determine decrement's trigger point
        		i = @s_opt.1.top - y - @pads.2
        		# wait triggered
        		if not (e = await (@dot = w3ui.promise i))
        			break
        		# check
        		if e == 1
        			# increment,
        			# TODO: uncontrolled?
        			c += 1
        			b += y
        		else
        			# decrement,
        			# determine intensity value
        			i = 1 + (i - v.scrollTop) / y
        			e = -(i .|. 0)
        			console.log 'decrement', e
        			# apply intensity
        			c += e
        			b += y*e
        			# apply limits
        			while c < a or b < h + z
        				c += 1
        				b += y
        				i -= 1
        				e  = 0 # sneaky escape (after update)
        			# check exhausted
        			if c == o.1
        				console.log 'decrement exhausted'
        				break
        			# check last decrement
        			if e and b - y < h + z and b - z > h + v.scrollTop
        				e = 0
        			# apply scroll adjustment (dot start)
        			if (i - (i .|. 0))*y < (z - x + 1)
        				if e
        					console.log 'scroll alignment'
        					@s_opt.0 = -2
        				else
        					console.log 'scroll alignment last'
        					w.scrollTo @s_opt.2
        		# update
        		@block.root.style.setProperty '--rows', (o.1 = c)
        		if o.0 and @block.setCount (o.0 * c) and @ready.pending
        			@ready.resolve!
        		# continue..
        	# }}}
        	# done
        	return true
        # }}}
        @scroll = (e) ~>> # {{{
        	# check intersection locked (upper limit determined)
        	if not (a = @dot.pending)
        		console.log 'scroll skip'
        		return true
        	# increase intensity
        	if @intense.pending
        		@intense.pending += 1
        		return false
        	# skip first scroll (programmatic)
        	c = @s_opt.2.top
        	d = @s_opt.1.top
        	if (b = @s_opt.0) < 0
        		console.log 'first scroll skip'
        		@s_opt.0 = if ~b
        			then c
        			else d
        		return false
        	# get scrollable container (aka viewport)
        	e = @i_opt.root or document.documentElement
        	i = if e.scrollTop > b
        		then 60  # increase
        		else 100 # decrease
        	# throttle (lock and accumulate)
        	while (await (@intense = w3ui.delay i, 1)) > 1
        		true
        	# get current position
        	e = e.scrollTop
        	# check changed
        	if (Math.abs (e - b)) < 0.2
        		console.log 'small scroll skip'
        		return true
        	# save position
        	@s_opt.0 = e
        	# reposition?
        	console.log 'reposition?', e, b, c, d
        	if b > c + 1 and e < b and e > c - 1
        		# exit (dot start)
        		@s_opt.0 = -2
        		a = window if not (a = @i_opt.root)
        		a.scrollTo @s_opt.2
        		console.log 'exit', @s_opt.2.top
        		return true
        	if b < d - 1 and e > b and e > c
        		# enter (dot trigger)
        		@s_opt.0 = -1
        		a = window if not (a = @i_opt.root)
        		a.scrollTo @s_opt.1
        		console.log 'enter', @s_opt.1.top
        		return true
        	# increment?
        	if e > d
        		# reset and resolve positive
        		console.log 'increment'
        		@s_opt.0 = -1
        		@dot.resolve 1
        		return true
        	# cancellation?
        	if a < 0
        		# negative upper limit means decrement is not possible
        		# reset and cancel scroll observations
        		console.log 'cancelled'
        		@s_opt.0 = -1
        		@dot.resolve 0
        		return true
        	# decrement?
        	if e < a
        		# resolve negative
        		@dot.resolve -1
        	# done
        	return true
        # }}}
        /***/
        var Resizer;
        Resizer = function(block){
          var this$ = this;
          this.block = block;
          this.rootCS = null;
          this.rootBoxCS = null;
          this.ppb = 0;
          this.pads = [0, 0, 0, 0];
          this.gaps = [0, 0];
          this.size = [0, 0, 0, 0];
          this.factor = 1;
          this.obs = null;
          this.ready = w3ui.promise();
          this.resize = w3ui.debounce(function(e){
            var w, ref$, a, b, c;
            if (e) {
              w = e[0].contentRect.width;
            } else {
              w = this$.block.root.clientWidth - this$.pads[0];
            }
            ref$ = this$.getColsAndWidth(w, 1), a = ref$[0], b = ref$[1];
            b = b > w ? w / b : 1;
            if (this$.block.onResize) {
              if ((c = this$.block.onResize(b)) < b) {
                ref$ = this$.getColsAndWidth(w, c), a = ref$[0], b = ref$[1];
              }
            } else {
              c = Math.abs(this$.factor - b);
              if (c && (b === 1 || c > 0.005)) {
                c = this$.block.root.style;
                if ((this$.factor = b) < 1) {
                  c.setProperty('--w3-factor', b);
                } else {
                  c.removeProperty('--w3-factor');
                }
              }
            }
            this$.block.setLayout(a);
            if (this$.ready.pending) {
              this$.ready.resolve();
              this$.obs.observe(this$.block.root);
            }
            return true;
          }, 300, 10);
        };
        Resizer.prototype = {
          init: function(){
            var s0, s1, ppb, a, b, c, d;
            if (this.obs) {
              this.obs.disconnect();
              this.obs = null;
              this.ready = w3ui.promise();
            }
            this.rootCS = s0 = getComputedStyle(this.block.root);
            this.rootBoxCS = s1 = getComputedStyle(this.block.rootBox);
            this.ppb = ppb = parseInt(s0.getPropertyValue('--w3-ppb'));
            a = this.pads;
            b = 'getPropertyValue';
            a[0] = parseFloat(s0[b]('padding-left')) / ppb;
            a[2] = parseFloat(s0[b]('padding-right')) / ppb;
            a[0] += a[2];
            a[1] = parseFloat(s0[b]('padding-top')) / ppb;
            a[3] = parseFloat(s0[b]('padding-bottom')) / ppb;
            a[1] += a[3];
            a = this.gaps;
            a[0] = parseFloat(s0[b]('--col-gap'));
            a[1] = parseFloat(s0[b]('--row-gap'));
            c = this.block.cfg;
            if (this.block.layout[3]) {
              c = c.lines;
              d = 'line';
            } else {
              c = c.cards;
              d = 'card';
            }
            a = this.size;
            a[0] = c[0] || parseInt(s0[b]('--' + d + '-sx'));
            a[1] = c[1] || parseInt(s0[b]('--' + d + '-sy'));
            a[2] = a[0] + this.gaps[0];
            a[3] = a[1] + this.gaps[1];
            a = this.block.cfg;
            this.block.setLayout(a.cols[0], a.rows[0]);
            this.obs = new ResizeObserver(this.resize);
            this.resize();
          },
          getColsAndWidth: function(w, e){
            var a, b, c;
            e = this.ppb * e;
            if (this.block.cfg.mode) {
              a = 1;
              b = e * this.size[0];
            } else {
              a = this.block.cfg.cols;
              if (a[0] === a[1] || !a[1]) {
                a = a[0];
                b = e * (a * this.size[0] + (a - 1) * this.gaps[0]);
              } else {
                c = a[0];
                a = a[1];
                while ((b = e * (a * this.size[0] + (a - 1) * this.gaps[0])) > w && a > c) {
                  --a;
                }
              }
            }
            return [a, b];
          }
        };
        return {
          defs: {
            mode: 0,
            cols: [1, 4],
            rows: [2, 0],
            cards: [0, 0],
            lines: [0, 0],
            order: ['default', -1],
            wraparound: 1
          },
          construct: function(o){
            var e;
            this.item = o.item || w3ui.grid;
            this.buffer = new blocks.buffer();
            this.resizer = new Resizer(this);
            this.items = [];
            this.layout = [0, 0, 0, 0];
            this.charged = 0;
            this.onChange = null;
            this.onResize = null;
            e = {
              hover: 0,
              focus: 0
            };
            if (o.event) {
              e = Object.assign(e, o.event);
            }
            events.attach(this, e);
          },
          init: function(){
            this.setMode(this.cfg.mode);
            this.resizer.init();
            this.buffer.init();
          },
          lock: function(){
            this.console.debug('locked == ' + this.locked);
          },
          setMode: function(mode){
            var a, b, c;
            a = 'cards';
            b = 'lines';
            c = a;
            if (mode) {
              a = b;
              b = c;
            }
            c = this.root.classList;
            if (!c.contains(a)) {
              c.add(a);
            }
            if (c.contains(b)) {
              c.remove(b);
            }
            this.layout[3] = mode;
            this.console.debug(a);
          },
          setLayout: function(cols, rows){
            var layout, items, count, a, b;
            layout = this.layout;
            items = this.items;
            if (!cols) {
              cols = layout[0];
            }
            if (!rows) {
              rows = layout[1];
            }
            count = cols * rows;
            if ((a = layout[2]) < count) {
              --a;
              while (++a < count) {
                if (b = items[a]) {
                  b.root.classList.add('v');
                } else {
                  items[a] = b = this.item({
                    className: 'item'
                  });
                  this.rootBox.appendChild(b.root);
                  b.init();
                }
              }
              /***
              # update buffer offsets
              # determine initial shift size and direction
              o = @offset
              c = c - 1
              if (d = o.0 - o.1) >= 0
              	d = d - @total if d > @cfg.limit
              else
              	d = d + @total if d < -@cfg.limit
              # operate
              while ++c < count
              	# TODO: fix
              	# determine item's location in the buffer
              	i = c + d
              	if d >= 0
              		# forward buffer
              		b = @bufA[i]
              	else if i >= 0
              		# last page is not aligned with the total and
              		# wrap around option may prescribe to display
              		# records from the first page, blanks otherwise
              		b = if @config.wrapAround
              			then @bufA[i]
              			else null
              	else
              		# backward buffer
              		i = -i - 1
              		b = @bufB[i]
              	# set content (may be empty)
              	a[c].set b
              	a[c].root.classList.add 'v'
              /***/
            } else if (a > count) {
              while (--a >= count) {
                items[a].root.classList.remove('v');
              }
            }
            if (layout[0] === cols && layout[1] === rows) {
              return false;
            }
            a = this.root.style;
            if (layout[0] !== cols) {
              a.setProperty('--cols', layout[0] = cols);
            }
            if (layout[1] !== rows) {
              a.setProperty('--rows', layout[1] = rows);
            }
            this.layout[2] = count;
            if (this.onChange) {
              this.onChange(this, 'layout');
            }
          },
          setOffset: function(i){
            this.offset[0] = a;
            if (this.setBuffer()) {
              this.offset[1] = a;
              this.offset[2] = 0;
              this.charged++;
              this.group.charge(this);
            }
            return true;
          },
          setTotal: function(i){
            return this.buffer.init(i);
          },
          setItem: function(record){
            var i;
            return i = this.buffer.set(record);
          }
        };
      }),
      section: function(){
        var Title, Item, Block;
        Title = function(node){
          this.root = node;
          this.box = node = node.firstChild;
          this.h3 = node.children[0];
          this.arrow = node.children[1];
          this.label = this.h3.firstChild;
        };
        Item = function(block, node, parent){
          var cfg, sect, c, i$, len$, b, a, hoverBounce, focusBounce, this$ = this;
          this.block = block;
          this.node = node;
          this.parent = parent;
          this.config = cfg = JSON.parse(node.dataset.cfg);
          this.title = new Title(w3ui.queryChild(node, '.title'));
          this.extra = null;
          this.section = sect = w3ui.queryChild(node, '.section');
          this.children = c = w3ui.queryChildren(sect, '.item');
          if (c) {
            for (i$ = 0, len$ = c.length; i$ < len$; ++i$) {
              b = i$;
              a = c[i$];
              c[b] = new Item(block, a, this);
            }
          }
          this.hovered = 0;
          this.focused = 0;
          this.opened = false;
          this.locked = true;
          hoverBounce = w3ui.delay();
          focusBounce = w3ui.delay();
          this.onHover = async function(e, hovered){
            var a, x, h;
            if (hoverBounce.pending) {
              hoverBounce.cancel();
            }
            if ((await (hoverBounce = w3ui.delay(66)))) {
              a = this$.title.arrow;
              x = this$.extra;
              hovered = !hovered
                ? 0
                : !x || e === a ? 1 : 2;
              if (hovered !== (h = this$.hovered)) {
                this$.hovered = hovered;
                if (hovered === 1) {
                  if (h) {
                    x.setHovered(false);
                  }
                  a.classList.add('h');
                } else if (hovered === 2) {
                  x.setHovered(true);
                  if (h) {
                    a.classList.remove('h');
                  }
                } else if (h === 2) {
                  x.setHovered(false);
                } else {
                  a.classList.remove('h');
                }
                a = this$.node.classList;
                if (h) {
                  a.remove('h' + h);
                }
                if (hovered) {
                  a.add('h' + hovered);
                }
                if ((!hovered || !h) && this$.block.onHover) {
                  this$.block.onHover(this$, hovered);
                }
              }
            }
            return false;
          };
          this.onFocus = async function(e, focused){
            var a, x, f;
            if (focusBounce.pending) {
              focusBounce.cancel();
            }
            if ((await (focusBounce = w3ui.delay(66)))) {
              a = this$.title.arrow;
              x = this$.extra;
              focused = !focused
                ? 0
                : !x || e === a ? 1 : 2;
              if (focused !== (f = this$.focused)) {
                this$.focused = focused;
                this$.node.classList.toggle('f', !!focused);
                if (this$.block.onFocus) {
                  this$.block.onFocus(this$, focused);
                }
              }
            }
            return true;
          };
          this.focus = function(e){
            e.preventDefault();
            if (!this$.locked) {
              (e = this$.title.arrow).classList.add('f');
              this$.onFocus(e, true);
            }
          };
          this.unfocus = function(e){
            e.preventDefault();
            (e = this$.title.arrow).classList.remove('f');
            this$.onFocus(e, false);
          };
          this.keydown = function(e){
            if (this$.locked) {
              return false;
            }
            switch (e.keyCode) {
            case 38:
            case 75:
              if (e = this$.searchArrow(true)) {
                e.title.arrow.focus();
              }
              break;
            case 40:
            case 74:
              if (e = this$.searchArrow(false)) {
                e.title.arrow.focus();
              }
              break;
            case 37:
            case 72:
            case 39:
            case 76:
              if (this$.section) {
                this$.onSwitch();
              }
              console.log('open/close section?');
              break;
            default:
              return false;
            }
            e.preventDefault();
            e.stopPropagation();
            return true;
          };
        };
        Item.prototype = {
          init: function(){
            var a, b, i$, len$;
            this.opened = this.config.opened;
            if (a = this.config.name) {
              this.title.label.textContent = a;
            }
            b = 'addEventListener';
            a = this.title.h3;
            a[b]('pointerenter', this.hover(a));
            a[b]('pointerleave', this.unhover(a));
            a[b]('click', this.click(a));
            a = this.title.arrow;
            a[b]('pointerenter', this.hover(a));
            a[b]('pointerleave', this.unhover(a));
            a[b]('click', this.click(a));
            a[b]('focusin', this.focus);
            a[b]('focusout', this.unfocus);
            a[b]('keydown', this.keydown);
            a = 'e' + ((this.extra && '1') || '0');
            b = 'o' + ((this.opened && '1') || '0');
            this.node.classList.add(a, b);
            if (this.config.arrow) {
              this.title.arrow.classList.add('v');
            }
            if (this.extra) {
              this.extra.root.classList.add('extra');
            }
            if (a = this.children) {
              for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
                b = a[i$];
                b.init();
              }
            }
          },
          lock: function(flag){
            var a, i$, len$, b;
            if (this.locked !== flag) {
              this.locked = flag;
              this.node.classList.toggle('v', !flag);
              if (a = this.title) {
                a.arrow.disabled = flag;
              }
              if (a = this.extra) {
                a.lock(flag);
              }
            }
            if (a = this.children) {
              for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
                b = a[i$];
                b.lock(flag);
              }
            }
            return flag;
          },
          hover: function(o){
            var this$ = this;
            return function(e){
              e.preventDefault();
              if (!this$.locked) {
                this$.onHover(o, true);
              }
            };
          },
          unhover: function(o){
            var this$ = this;
            return function(e){
              e.preventDefault();
              this$.onHover(o, false);
            };
          },
          click: function(o){
            var this$ = this;
            return async function(e){
              e.preventDefault();
              if (!this$.locked) {
                if (this$.extra && o === this$.title.h3) {
                  this$.extra.event();
                } else if (this$.section) {
                  e = !this$.opened;
                  if (!this$.block.onChange || (await this$.block.onChange(this$, e))) {
                    this$.set(e);
                  }
                  if (!this$.focused) {
                    this$.title.arrow.focus();
                  }
                }
              }
            };
          },
          set: function(v){
            if (this.opened === v) {
              return false;
            }
            this.opened = v;
            v = (v && 1) || 0;
            this.node.classList.remove('o' + (1 - v));
            this.node.classList.add('o' + v);
            return true;
          },
          searchArrow: function(direction){
            var a, b, c, d;
            if (direction) {
              if ((a = this).parent) {
                b = a.parent.children;
                c = b.indexOf(a);
                while (--c >= 0) {
                  if (b[c].children) {
                    if (!(a = b[c]).opened) {
                      return a;
                    }
                    break;
                  }
                }
                if (!~c) {
                  return a.parent;
                }
              }
              while (b = a.children) {
                c = b.length;
                while (--c >= 0) {
                  if (b[c].children) {
                    if (!(a = b[c]).opened) {
                      return a;
                    }
                    break;
                  }
                }
                if (!~c) {
                  break;
                }
              }
            } else {
              if ((a = this).opened) {
                if (!(b = a.children)) {
                  return a;
                }
                c = -1;
                while (++c < b.length) {
                  if (b[c].children) {
                    return b[c];
                  }
                }
              }
              while (b = a.parent) {
                c = b.children;
                d = c.indexOf(a);
                while (++d < c.length) {
                  if (c[d].children) {
                    return c[d];
                  }
                }
                a = a.parent;
              }
            }
            return a;
          },
          getLastVisible: function(){
            var a;
            if (!(a = this.children) || !this.opened) {
              return this;
            }
            return a[a.length - 1].getLastVisible();
          },
          getNextVisible: function(){
            var a, b, c, d;
            if (this.children && this.opened) {
              return this.children[0];
            }
            a = this;
            while (b = a.parent) {
              c = b.children;
              if ((d = c.indexOf(a)) < c.length - 1) {
                return c[d + 1];
              }
              a = b;
            }
            return a;
          }
        };
        Block = function(root){
          var box, sect, items, list, a, b;
          this.root = root;
          this.rootBox = box = root.firstChild;
          this.lines = w3ui.queryChildren(box, 'svg');
          this.item = root = new Item(this, box, null);
          this.sect = sect = {};
          this.items = items = {};
          this.list = list = [root];
          a = -1;
          while (++a < list.length) {
            if ((b = list[a]).children) {
              sect[b.config.id] = b;
              list.push.apply(list, b.children);
            }
            items[b.config.id] = b;
          }
          this.hovered = false;
          this.focused = false;
          this.locked = true;
          this.onHover = null;
          this.onFocus = null;
          this.onChange = null;
        };
        Block.prototype = {
          init: function(title){
            if (!this.item.config.name && title) {
              this.item.title.label.textContent = title;
            }
            this.item.init();
          },
          lock: function(flag){
            flag == null && (flag = true);
            if (this.locked !== flag) {
              this.locked = this.item.lock(flag);
            }
          }
          /***
          S.onRefocus = (i1, i2, direction) ~> # {{{
          	# prepare
          	a = null
          	# check destination
          	if i2
          		# up/down navigation for root
          		if not i1.parent
          			# pass to checkbox
          			# get item
          			if direction
          				# last
          				a = i1.getLastVisible!
          				a = @checks.get a.config.id
          			else
          				# first
          				a = @checks.get i1.children.0.config.id
          	else
          		# left/right breakout
          		# direction doesn't matter for single checkbox
          		a = @checks.get i1.config.id
          	# custom
          	if a and a.checkbox
          		a.checkbox.focus!
          	# default
          	return !!a
          # }}}
          @onFocus = S.onFocus = do ~> # {{{
          	p = null
          	return (item) ~>>
          		# check
          		if p and p.pending
          			p.resolve false
          		# set
          		if item.focused
          			@focused = true
          			@root.classList.add 'f'
          		else if await (p := w3ui.delay 60)
          			@focused = false
          			@root.classList.remove 'f'
          		# done
          		return true
          # }}}
          @onAutofocus = S.onAutofocus = (node) !~> # {{{
          	if not @focused and \
          		(a = S.rootItem).config.autofocus
          		###
          		if a.arrow
          			a.arrow.focus!
          		else
          			a.checks.checkbox.focus!
          # }}}
          /***/
        };
        return function(o){
          return new Block(o);
        };
      }(),
      catalog: function(){
        var configGroups, groupLevel, stateGroups, SuperVisor;
        configGroups = ['locale', 'routes', 'order', 'currency', 'cart', 'price', 'layout', 'total'];
        groupLevel = w3ui.metaconstruct({
          lang: 4,
          route: 3,
          category: 2,
          price: 2,
          range: 1,
          order: 1
        });
        stateGroups = Object.getOwnPropertyNames(groupLevel);
        SuperVisor = function(o){
          this.console = o.console;
          this.root = o.root;
          this.brand = o.brand;
          this.map = o.blocks;
          this.fetch = w3fetch.create({
            baseUrl: o.api,
            mounted: true,
            notNull: true,
            method: 'POST'
          });
          this.stream = w3fetch.create({
            baseUrl: o.api,
            mounted: true,
            notNull: true,
            method: 'POST',
            timeout: 0,
            parseResponse: 'stream'
          });
          this.blocks = [];
          this.groups = [];
          this.state = w3ui.metaconstruct(stateGroups);
          this.config = o.config ? w3ui.merge(o.config, configGroups) : null;
          this.counter = 0;
          this.lock = null;
          this.level = 0;
          this.dirty = -1;
          this.req = null;
          this.view = null;
          this.steady = null;
        };
        SuperVisor.prototype = {
          loop: async function(){
            var console, blocks, a, b, i$, len$, res;
            if (this.counter) {
              return false;
            }
            console = this.console;
            blocks = this.blocks;
            this.steady = w3ui.promise();
            console.log('loop started');
            while (++this.counter) {
              this.lock = this.dirty
                ? w3ui.delay((~this.dirty && 400) || 0)
                : w3ui.promise(1);
              if (!(await this.lock)) {
                continue;
              }
              this.dirty = 0;
              a = blocks.length;
              while (~--a) {
                if ((b = blocks[a]).check && !b.check(this.level)) {
                  this.dirty = -1;
                  break;
                }
              }
              if (this.dirty || !this.level) {
                continue;
              }
              for (i$ = 0, len$ = blocks.length; i$ < len$; ++i$) {
                b = blocks[i$];
                if (b.level < this.level && !b.locked) {
                  b.locked = this.level;
                  b.rootBox.classList.remove('v');
                  if (b.lock) {
                    b.lock(this.level);
                  }
                }
              }
              (await w3ui.delay(0));
              if (this.dirty) {
                continue;
              }
              res = (await (this.req = this.stream(this.state)));
              this.req = null;
              if (res instanceof Error) {
                if (res.id === 4) {
                  continue;
                }
                console.error('stream failed: ' + res.message);
                console.debug(res);
                break;
              }
              if ((this.config.total = (await res.readInt())) === null) {
                console.error('stream failed');
                res.cancel();
                break;
              }
              for (i$ = 0, len$ = blocks.length; i$ < len$; ++i$) {
                b = blocks[i$];
                b.sync();
                if (b.locked) {
                  b.locked = 0;
                  b.rootBox.classList.add('v');
                  if (b.lock) {
                    b.lock(0);
                  }
                }
              }
              this.level = 0;
              if (!this.view) {
                res.cancel();
                continue;
              }
              this.view.setItem(null);
              while (!this.dirty && (a = (await res.readJSON()))) {
                if (a instanceof Error) {
                  console.error('stream failed: ' + a.message);
                  console.debug(a);
                  res.cancel();
                  break;
                }
                if (this.view.setItem(a)) {
                  a = null;
                  res.cancel();
                  break;
                }
              }
              if (a) {
                break;
              }
            }
            this.counter = 0;
            this.steady.resolve();
            console.log('loop finished');
            return true;
          },
          charge: function(block){
            if (block.level > this.level) {
              this.level = block.level;
            }
            if (this.lock.pending) {
              this.lock.resolve(this.lock.pending === 1);
            } else {
              this.dirty = 1;
              if (this.req) {
                this.req.cancel();
              }
            }
          },
          stop: function(){
            if (this.counter) {
              if (this.lock) {
                this.lock.resolve();
              }
              if (this.req) {
                this.req.cancel();
              }
              this.dirty = this.counter = -1;
              this.lock = this.req = null;
            }
            return this.steady;
          }
        };
        return async function(o, autoloop){
          var console, sup, root, blocks, groups, time, i$, ref$, len$, a, b, j$, len1$, timed, e;
          autoloop == null && (autoloop = true);
          o.brand = o.brand || 'catalog';
          console = o.console = w3ui.console['new'](o.brand);
          console.log('new supervisor');
          if (!w3fetch) {
            console.error('missing requirement: w3fetch');
            return null;
          }
          if (!o.api) {
            console.error('stateless: no api endpoint');
            return null;
          }
          sup = new SuperVisor(o);
          root = sup.root;
          blocks = sup.blocks;
          groups = sup.groups;
          time = performance.now();
          for (i$ = 0, len$ = (ref$ = stateGroups).length; i$ < len$; ++i$) {
            a = ref$[i$];
            if (b = sup.map[a]) {
              b = w3ui.blocks.group(a, groupLevel[a], sup, b);
              if (b) {
                groups[groups.length] = b;
              }
            }
          }
          if (!groups.length) {
            console.error('stateless: no state blocks');
            return null;
          }
          for (i$ = 0, len$ = groups.length; i$ < len$; ++i$) {
            a = groups[i$];
            for (j$ = 0, len1$ = (ref$ = a.blocks).length; j$ < len1$; ++j$) {
              b = ref$[j$];
              blocks[blocks.length] = b;
            }
          }
          blocks.sort(function(a, b){
            return a.level < b.level
              ? -1
              : a.level === b.level ? 0 : 1;
          });
          for (i$ = 0, len$ = blocks.length; i$ < len$; ++i$) {
            a = blocks[i$];
            if (a.view) {
              sup.view = a;
            }
          }
          timed = performance.now();
          console.log('constructed ' + blocks.length + ' (' + (timed - time | 0) + 'ms)');
          time = timed;
          (await w3ui.delay(0));
          if (!sup.config) {
            if ((a = (await sup.fetch(sup.state))) instanceof Error) {
              console.error('failed to fetch configuration');
              console.debug(a);
              return null;
            }
            sup.config = w3ui.merge(a, configGroups);
          }
          try {
            for (i$ = 0, len$ = groups.length; i$ < len$; ++i$) {
              a = groups[i$];
              a.init();
            }
            for (i$ = 0, len$ = groups.length; i$ < len$; ++i$) {
              a = groups[i$];
              a.sync();
            }
          } catch (e$) {
            e = e$;
            console.error(a.name + ' group failed');
            console.debug(e);
            return null;
          }
          for (i$ = 0, len$ = blocks.length; i$ < len$; ++i$) {
            a = blocks[i$];
            a.lock(0);
          }
          timed = performance.now();
          console.log('initialized (' + (timed - time | 0) + 'ms)');
          (await w3ui.delay(0));
          if (autoloop) {
            console.debug('autoloop');
            sup.loop();
          }
          return sup;
        };
      }()
    });
    return Object.freeze(w3ui);
  });
}();